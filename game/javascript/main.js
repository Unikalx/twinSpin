Sys.ns("Core");
Core.StateHandler = {
    constructor: function () {
        var a = this;
        Core.StateHandler.superclass.constructor.apply(a, arguments);
        a.useLogging = false;
        a.states = window.GenericStates || {};
        a.stateStack = [];
        a.runningStateMachine = false
    }, registerEvents: function (c) {
        var d = this, b = c.length, a;
        if (Sys.isArray(c)) {
            for (a = -1; ++a < b;) {
                d.addListener(c[a], d.onDefaultEventHandler.bind(d, c[a]))
            }
        } else {
            if (Sys.isString(c)) {
                d.addListener(c, d.onDefaultEventHandler.bind(d, c))
            }
        }
    }, onDefaultEventHandler: function (a) {
        this.dispatchEvent(a);
        this.activateStateMachine()
    }, initStateHandler: function () {
        var b = this, a;
        Sys.iterate(window.GenericStates || {}, function (c, d) {
            b._registerTrigger(d)
        });
        EventHandler.sortEventListeners(this);
        a = Resources.readData("gameServerInitResponse");
        if (a.restore !== true) {
            this.pushState(this.states.idle)
        }
        this.pushState(this.states.beforeLoaderClose);
        this.pushState(this.states.setupGame);
        this.activateStateMachine()
    }, activateStateMachine: function () {
        var a = this, b;
        if (a.runningStateMachine) {
            return
        }
        a.runningStateMachine = true;
        while (a.hasStatesInStack()) {
            if (!Sys.isEmpty(a.currentState)) {
                for (b in a.currentState.waitEvents) {
                    if (a.currentState.waitEvents.hasOwnProperty(b) && !a.currentState.waitEvents[b]) {
                        a.runningStateMachine = false;
                        return
                    }
                }
                setTimeout(a.leaveCurrentState.bind(a), 1);
                return
            }
            a.currentState = a.stateStack.pop();
            a.currentState.execute({stateHandler: a, states: a.states});
            a.processModuleQueue();
            if (Sys.isDefined(a.currentState.executeLast)) {
                a.currentState.executeLast({stateHandler: a, states: a.states})
            }
            a.fireEvent("notify:stateHandler.entering" + a.currentState.name + "State")
        }
        a.runningStateMachine = false
    }, leaveCurrentState: function () {
        var a = this;
        a.fireEvent("notify:stateHandler.leaving" + a.currentState.name + "State");
        a.currentState = undefined;
        a.runningStateMachine = false;
        a.activateStateMachine()
    }, processModuleQueue: function () {
        var c = this, a = Game.moduleLoader.getModuleQueueForState(c.currentState.name), d = a.length, b;
        for (b = 0; b < d; b++) {
            a[b]({stateHandler: c, states: c.states})
        }
    }, addState: function (a, b) {
        if (!Sys.isDefined(this.states[a])) {
            this.states[a] = b;
            this._registerTrigger(b)
        }
    }, _registerTrigger: function (a) {
        if (Sys.isDefined(Services.trigger)) {
            Services.trigger.registerTrigger("notify:stateHandler.entering" + a.name + "State", this, "When entering the state " + a.name);
            Services.trigger.registerTrigger("notify:stateHandler.leaving" + a.name + "State", this, "When leaving the state " + a.name)
        }
    }, pushState: function (a) {
        var b;
        if (this.stateStack.indexOf(a) > -1) {
            return
        }
        for (b in a.waitEvents) {
            if (a.waitEvents.hasOwnProperty(b)) {
                a.waitEvents[b] = false
            }
        }
        this.stateStack.push(a)
    }, dispatchEvent: function (b) {
        var a = this;
        if (!Sys.isEmpty(a.currentState) && !Sys.isEmpty(a.currentState.waitEvents[b])) {
            a.currentState.waitEvents[b] = true
        }
        Sys.each(a.stateStack, function (c) {
            if (!Sys.isEmpty(c.waitEvents[b])) {
                c.waitEvents[b] = true
            }
        })
    }, dumpStack: function (d) {
        var c = this, f = "", e, a, b;
        if (c.useLogging) {
            if (!this.currentState) {
            } else {
                e = d;
                Sys.each(Object.getOwnPropertyNames(this.currentState.waitEvents), function (g) {
                    a = c.currentState.waitEvents[g] ? "*" : " ";
                    f += "\n\t\t(" + a + ") " + g.replace(/\s/g, "")
                });
                e += "\nCurrent state:\t" + this.currentState.name + f;
                for (b = this.stateStack.length - 1; b >= 0; b--) {
                    e += "\n\t" + this.stateStack[b].name
                }
            }
        }
    }, hasStates: function () {
        return Object.keys(this.states).length > 0
    }, hasStatesInStack: function () {
        return this.stateStack.length > 0
    }, isRunning: function () {
        return this.runningStateMachine
    }
};
Core.StateHandler = Sys.extend(Sys.Observable, Core.StateHandler, "Core.StateHandler");
window.GenericStates = {
    beforeLoaderClose: {
        name: "BeforeLoaderClose", execute: function () {
        }, waitEvents: {}
    }, setupGame: {
        name: "SetupGame", execute: function () {
        }, waitEvents: {}
    }, idle: {
        name: "Idle", execute: function (a) {
        }, waitEvents: {}
    }
};
Sys.ns("Core");
Core.ModuleLoader = {
    constructor: function (a) {
        Core.ModuleLoader.superclass.constructor.apply(this, arguments);
        this.init(a)
    }, getModuleQueueForState: function (b) {
        var a = this.stateOrder[b];
        if (Sys.isDefined(a)) {
            return a
        }
        return []
    }, init: function (a) {
        var c = this, b = Resources.readData("modules");
        c.stateHandler = a.stateHandler;
        c.stateOrder = c.getCommonStateOrder();
        c.addGameSpecificStateOrder();
        c.loadModules(b);
        c.updateStates();
        c.cleanStateQueue();
        c.fireEvent("notify:moduleLoader.finishedLoadingModules")
    }, loadModules: function (d) {
        var c = this, e = Environment.getCurrentPlatform(), b, a;
        c.modules = {};
        Sys.iterate(d, function (g, f) {
            b = (Sys.isArray(f.platforms) && f.platforms.indexOf(e) === -1);
            if (!Sys.isDefined(c.modules[g]) && !b) {
                a = c.getClassFromString(f.module);
                if (!Sys.isDefined(a) && f.optional === true) {
                    return
                }
                c.modules[g] = new a({
                    name: g,
                    model: c.getPlatformSpecificClass(f.model),
                    view: c.getPlatformSpecificClass(f.view),
                    controller: c.getClassFromString(f.controller)
                });
                if (Sys.isString(f.global)) {
                    if (!Sys.isDefined(window[f.global])) {
                        window[f.global] = {}
                    }
                    window[f.global][g] = c.modules[g].controller
                }
                c.applyMixins(c.modules[g], c.combineMixins(c.modules[g].getMixinDependencies(), f.mixins))
            }
        })
    }, combineMixins: function (b, g) {
        var f = {}, j, a, h, d, e, c, k = Environment.getCurrentPlatform();
        if (Sys.isArray(b)) {
            e = b;
            c = b.length
        } else {
            e = (b.hasOwnProperty(k)) ? b[k] : b.fallback;
            c = e.length
        }
        for (d = -1; ++d < c;) {
            j = e[d];
            if (Sys.isObj(j)) {
                h = Object.keys(j)[0];
                a = j[h];
                f[h] = a
            } else {
                if (Sys.isString(j)) {
                    f[j] = undefined
                }
            }
        }
        if (Sys.isArray(g)) {
            c = g.length;
            for (d = -1; ++d < c;) {
                j = g[d];
                if (!Sys.isDefined(f[j])) {
                    f[j] = undefined
                }
            }
        }
        return f
    }, applyMixins: function (a, h) {
        var d = ["controller", "model", "view"], n = Object.keys(h), g = n.length, c = d.length, m, k, b, l, f, e;
        for (f = -1; ++f < g;) {
            l = n[f];
            b = h[l] || {};
            m = Mixins[l];
            if (Sys.isDefined(m)) {
                for (e = -1; ++e < c;) {
                    k = d[e];
                    if (Sys.isDefined(m[k]) && Sys.isDefined(a[k]) && Sys.isDefined(m[k].methods)) {
                        this.applyMixinProperties(a[k], m[k].methods)
                    }
                }
                for (e = -1; ++e < c;) {
                    k = d[e];
                    if (Sys.isDefined(m[k]) && Sys.isDefined(a[k]) && Sys.isDefined(m[k].executeOnInstantiation)) {
                        this.executeMixinProperties(a[k], m[k].executeOnInstantiation, b)
                    }
                }
            }
        }
    }, applyMixinProperties: function (f, a) {
        var d = Object.keys(a), e = d.length, c, b = 0;
        while (b < e) {
            c = d[b];
            if (!Sys.isDefined(f[c])) {
                f[c] = a[c]
            }
            ++b
        }
    }, executeMixinProperties: function (f, c, d) {
        var b = Object.keys(c), a = b.length, e = 0;
        while (e < a) {
            c[b[e]].call(f, d);
            ++e
        }
    }, updateStates: function () {
        var b = this, a = b.modules, c = b.stateHandler.states;
        b.moduleQueues = {};
        Sys.iterate(a, function (d, f) {
            var e = f.getStateChanges();
            Sys.iterate(e, function (i, h) {
                var g = [];
                if (Sys.isDefined(h.state)) {
                    b.stateHandler.addState(i, h.state);
                    Sys.iterate(h.state.waitEvents, function (j) {
                        g.push(j)
                    });
                    if (g.length > 0) {
                        b.registerListenersOnStateHandler(f.controller, g)
                    }
                }
            })
        });
        Sys.iterate(a, function (d, f) {
            var e = f.getStateChanges();
            Sys.iterate(e, function (h, g) {
                if (!Sys.isDefined(g.state) && Sys.isDefined(c[h])) {
                    if (Sys.isArray(g.waitEvents)) {
                        Sys.each(g.waitEvents, function (i) {
                            c[h].waitEvents[i] = false
                        });
                        b.registerListenersOnStateHandler(f.controller, g.waitEvents)
                    }
                    if (Sys.isArray(g.queue)) {
                        b.updateModuleQueue(d, c[h].name, g.queue)
                    }
                }
            })
        })
    }, registerListenersOnStateHandler: function (d, c) {
        var b = c.length, a;
        for (a = -1; ++a < b;) {
            if (!this.stateHandler.hasListener(c[a])) {
                this.stateHandler.registerEvents(c[a])
            }
        }
    }, updateModuleQueue: function (c, e, a) {
        var d = this.stateOrder[e], b;
        if (Sys.isDefined(d)) {
            b = d.indexOf(c);
            if (b >= 0) {
                d.splice.apply(d, [b, 1].concat(a));
                this.stateOrder[e] = d
            } else {
            }
        } else {
        }
    }, cleanStateQueue: function () {
        var a = this;
        Sys.iterate(a.stateOrder, function (d, b) {
            var c;
            for (c = 0; c < b.length; c++) {
                if (Sys.isString(b[c]) || !Sys.isDefined(b[c])) {
                    b.splice(c, 1);
                    c--
                }
            }
        })
    }, addGameSpecificStateOrder: function () {
        var d = this, c = d.stateOrder, b = Resources.readData("config"), a = b.stateOrder;
        if (Sys.isDefined(a)) {
            Sys.iterate(a, function (f, e) {
                Sys.each(e, function (h) {
                    var g;
                    if (!Sys.isDefined(c[f])) {
                        c[f] = h.modules
                    } else {
                        if (Sys.isDefined(h.insertBefore)) {
                            g = c[f].indexOf(h.insertBefore) + 1;
                            if (g < 0) {
                                c[f] = h.modules.concat(c[f])
                            } else {
                                c[f].splice.apply(c[f], [g, 0].concat(h.modules))
                            }
                        } else {
                            c[f].push.apply(c[f], h.modules)
                        }
                    }
                })
            })
        }
    }, getClassFromString: function (c) {
        var d, b, a, e;
        if (Sys.isString(c)) {
            d = c.split(".");
            b = window;
            e = d.length;
            for (a = 0; a < e; a++) {
                if (Sys.isDefined(b)) {
                    b = b[d[a]]
                }
            }
            return b
        }
        return undefined
    }, getPlatformSpecificClass: function (c) {
        var b = this, a = c;
        if (Sys.isObj(a)) {
            if (b.isMVCSupported(a)) {
                a = b.getPlatformView(a)
            } else {
            }
        }
        return b.getClassFromString(a)
    }, isMVCSupported: function (b) {
        var c = Environment.getSupportedPlatforms(), a = true;
        Sys.iterate(b, function (e, d) {
            if (c.indexOf(e) < 0) {
                a = false
            }
        });
        return a
    }, getPlatformView: function (a) {
        var b = Environment.getCurrentPlatform();
        if (b === "desktop" && !Sys.isDefined(a[b])) {
            b = "tablet"
        }
        if (b === "tablet" && !Sys.isDefined(a[b])) {
            b = "mobile"
        }
        if (b === "tabletLow" && !Sys.isDefined(a[b])) {
            b = "mobileLow"
        }
        if (b === "mobileLow" && !Sys.isDefined(a[b])) {
            b = "mobile"
        }
        return a[b]
    }, getCommonStateOrder: function () {
        return {BeforeLoaderClose: ["stage"], Idle: ["playForRealPromo"]}
    }
};
Core.ModuleLoader = Sys.extend(Sys.Observable, Core.ModuleLoader, "Core.ModuleLoader");
Sys.ns("Core.Slots");
Core.Slots.ModuleLoader = {
    constructor: function (a) {
        Core.Slots.ModuleLoader.superclass.constructor.apply(this, arguments)
    }, getCommonStateOrder: function () {
        return {
            SetupGame: ["blurredSymbols"],
            BeforeLoaderClose: ["freeSpinOutro", "spinTypeFreespin", "spinTypeRespin", "countDownFreespins", "freeSpinIntro", "bonusProgramWidget", "disclaimer", "freeRounds", "introMovie", "stage"],
            Idle: ["spin", "playForRealPromo", "customMessages"],
            Spinning: ["serverManager"],
            ProcessServerResponse: [],
            BeforeStopping: ["customMessages"],
            Stopping: ["spin"],
            Stopped: ["spinTypeRespin", "spinTypeBasic", "freeRounds", "realityCheck", "autoPlayer", "freeSpinOutro", "spinTypeFreespin", "g4", "freeSpinIntro", "freeSpinIntroMovie", "countDownFreespins", "additionalFreespins", "standardWin", "bigWin", "freeSpinSymbolAttentionAnimation", "stickySymbols", "spreadingWild"],
            FreeSpinIntro: ["freeRounds"],
            spinTypeRespinRestore: ["freeRounds"],
            NoWinPresentation: ["customMessages"]
        }
    }
};
Core.Slots.ModuleLoader = Sys.extend(Core.ModuleLoader, Core.Slots.ModuleLoader, "Core.Slots.ModuleLoader");
Sys.ns("Core");
Core.Heart = {
    constructor: function (a) {
        var b = this;
        Core.Heart.superclass.constructor.apply(b, arguments);
        b.pulse = 5000;
        b.pulseDelay = 1000;
        b.timeOutDelay = 2000;
        if (Sys.isDefined(a)) {
            b.pulse = a.pulse || b.pulse;
            b.pulseDelay = a.pulseDelay || b.pulseDelay
        }
        b.lastBeat = 0;
        b.flatlined = false;
        b.on({scope: b, "notify:loader.closed": b.init})
    }, init: function () {
        this.revive()
    }, flatline: function () {
        this.flatlined = true;
        clearTimeout(this.currentBeatTimeout)
    }, revive: function () {
        this.flatlined = false;
        this.lastBeat = Date.now();
        this.beat()
    }, beat: function () {
        var b = this, a = Date.now();
        if ((a - b.lastBeat) >= (b.pulse + b.pulseDelay)) {
            b.fireEvent("request:errorManager.handleGameInactive");
            this.flatline()
        }
        b.lastBeat = a;
        if (!b.flatlined) {
            clearTimeout(b.currentBeatTimeout);
            b.currentBeatTimeout = setTimeout(function () {
                b.beat()
            }, b.timeOutDelay)
        }
    }
};
Core.Heart = Sys.extend(Sys.Observable, Core.Heart, "Core.Heart");
Sys.ns("Mixins");
Mixins.animation = {
    controller: {
        methods: {
            initAnimations: function () {
                this.view.initAnimations()
            }
        }, executeOnInstantiation: {
            setupEvents: function () {
                this.on({"notify:animationManager.allImagesLoaded": this.initAnimations})
            }
        }
    }, view: {
        methods: {
            initAnimations: function () {
            }
        }
    }
};
Sys.ns("Mixins");
Mixins.orientation = {
    controller: {
        methods: {
            onPortrait: function () {
                this.view.onPortrait()
            }, onLandscape: function () {
                this.view.onLandscape()
            }
        }, executeOnInstantiation: {
            setupEvents: function () {
                this.on({"notify:viewport.PORTRAIT": this.onPortrait, "notify:viewport.LANDSCAPE": this.onLandscape})
            }
        }
    }, view: {
        methods: {
            onPortrait: function () {
                this.adaptToOrientation("PORTRAIT");
                this.currentOrientation = "PORTRAIT"
            }, onLandscape: function () {
                this.adaptToOrientation("LANDSCAPE");
                this.currentOrientation = "LANDSCAPE"
            }, adaptToOrientation: function (a) {
                this.setSize(a);
                this.setPosition(a);
                this.setStyle(a)
            }, setSize: function (c) {
                var f = this, a = f.container, g = Sys.isDefined(a) ? a.el.style : undefined, j = f[c + "_SIZE"], d, h,
                    k = 0, e = 0, i, b;
                if (!Sys.isDefined(j) || !Sys.isDefined(a)) {
                    return
                }
                d = j.RELATIVE_SCREEN ? Environment.getInnerScreenSize() : Environment.getResolution();
                h = j.RELATIVE_SCREEN ? 1 / Environment.getScale() : 1;
                if (Sys.isDefined(j.HEIGHT)) {
                    i = Math.round(d.height * j.HEIGHT * h);
                    b = Sys.isDefined(j.WIDTH) ? Math.round(d.width * j.WIDTH * h) : Math.round(i * j.ASPECT_RATIO)
                } else {
                    b = Math.round(d.width * j.WIDTH * h);
                    i = Math.round(b / j.ASPECT_RATIO)
                }
                if (j.VERTICAL_OFFSET === "bottom") {
                    k = "-" + i + "px"
                } else {
                    if (j.VERTICAL_OFFSET === "center") {
                        k = "-" + Math.round(i / 2) + "px"
                    }
                }
                if (j.HORIZONTAL_OFFSET === "right") {
                    e = "-" + b + "px"
                } else {
                    if (j.HORIZONTAL_OFFSET === "center") {
                        e = "-" + Math.round(b / 2) + "px"
                    }
                }
                g.width = b + "px";
                g.height = i + "px";
                g.backgroundSize = b + "px " + i + "px";
                g.margin = k + " 0 0 " + e
            }, setPosition: function (c) {
                var h = this, e = h[c + "_POSITION"], j, i, f, b, g, d, a;
                if (!Sys.isDefined(e) || !Sys.isDefined(h.container)) {
                    return
                }
                j = h.container.el.style;
                if (Sys.isDefined(e.BOTTOM)) {
                    f = "BOTTOM";
                    b = "top";
                    a = "getBottom"
                } else {
                    f = "TOP";
                    b = "bottom";
                    a = "getTop"
                }
                if (Sys.isDefined(e.RIGHT)) {
                    g = "RIGHT";
                    d = "left"
                } else {
                    g = "LEFT";
                    d = "right"
                }
                if (e.BELOW_GAME) {
                    i = Environment[a + "BelowGame"](e[f])
                } else {
                    if (e.ABOVE_GAME) {
                        i = Environment[a + "AboveGame"](e[f])
                    } else {
                        i = Environment[a + "InGame"](e[f])
                    }
                }
                if (e["MIN_" + f]) {
                    i = Math.max(e["MIN_" + f], i)
                }
                j[f.toLowerCase()] = i + "px";
                j[b] = "auto";
                j[g.toLowerCase()] = (100 * e[g]) + "%";
                j[d] = "auto"
            }, setStyle: function (a) {
                var c = this, d = a + "_CSS", b = a === "LANDSCAPE" ? "PORTRAIT_CSS" : "LANDSCAPE_CSS";
                if (c.container && c[d]) {
                    c.container.removeCls(c[b]);
                    c.container.addCls(c[d])
                }
            }
        }
    }
};
Sys.ns("Mixins");
Mixins.userInput = {
    controller: {
        methods: {
            startListeningToUserInput: function () {
                this.on(this.USED_INPUT_HANDLERS);
                this.isListeningToUserInput = true
            }, stopListeningToUserInput: function () {
                var a = this;
                Sys.iterate(a.USED_INPUT_HANDLERS, a.removeListener.bind(a));
                a.isListeningToUserInput = false
            }, onUserInputStart: function () {
            }, onUserInputEnd: function () {
            }, onUserInputMove: function () {
            }, onUserInputHover: function () {
            }, onUserInputCanceled: function () {
            }, onUserInputScroll: function () {
            }, onUserInputKeyUp: function () {
            }, onUserInputKeyDown: function () {
            }, isUserInputInSegment: function (b, a) {
                Sys.UserInputUtils.isUserInputInSegment(b, a)
            }
        }, executeOnInstantiation: {
            init: function (c) {
                var d = this, e = Sys.isDefined(c.inputEvents) ? c.inputEvents : ["start", "end", "cancel", "move"],
                    a = {}, b;
                for (b = 0; b < e.length; b++) {
                    switch (e[b]) {
                        case"start":
                            a["notify:userInputManager.userInputStarted"] = d.onUserInputStart;
                            break;
                        case"end":
                            a["notify:userInputManager.userInputEnded"] = d.onUserInputEnd;
                            break;
                        case"move":
                            a["notify:userInputManager.userInputMove"] = d.onUserInputMove;
                            break;
                        case"hover":
                            a["notify:userInputManager.userInputHover"] = d.onUserInputHover;
                            break;
                        case"cancel":
                            a["notify:userInputManager.userInputCanceled"] = d.onUserInputCanceled;
                            break;
                        case"scroll":
                            a["notify:userInputManager.userInputScroll"] = d.onUserInputScroll;
                            break;
                        case"keyUp":
                            a["notify:userInputManager.userInputKeyUp"] = d.onUserInputKeyUp;
                            break;
                        case"keyDown":
                            a["notify:userInputManager.userInputKeyDown"] = d.onUserInputKeyDown;
                            break;
                        default:
                    }
                }
                d.USED_INPUT_HANDLERS = a;
                if (c.listenToUserInput) {
                    d.startListeningToUserInput()
                }
            }
        }
    }
};
Sys.ns("Mixins");
Mixins.serverResponse = {
    controller: {
        methods: {
            onServerResponse: function (a) {
                this.model.processServerResponse(a)
            }
        }, executeOnInstantiation: {
            setupEvents: function () {
                this.on({"notify:responseParser.responseParsed": this.onServerResponse})
            }
        }
    }, model: {
        methods: {
            processServerResponse: function (a) {
            }
        }
    }
};
Sys.ns("Mixins");
Mixins.waitSequence = {
    controller: {
        methods: {
            initializeWaitSequence: function (c, a) {
                var b = this;
                b.clearWaitSequence();
                b.waiting = true;
                if (Sys.isDefined(c)) {
                    b.fireEvent(c, a);
                    b.checkForCompletion()
                }
            }, clearWaitSequence: function () {
                var a = this;
                Sys.each(a.eventsToWaitFor, a.removeWaitEventListener.bind(a));
                a.eventsToWaitFor.length = 0;
                a.waiting = false
            }, removeWaitEventListener: function (a) {
                if (Sys.isDefined(this.customListeners[a])) {
                    this.removeListener(a);
                    delete this.customListeners[a]
                }
            }, checkForCompletion: function () {
                if (this.eventsToWaitFor.length === 0) {
                    this.onWaitIsComplete();
                    this.waiting = false
                }
            }, onWaitRequested: function (a) {
                var b = this, c;
                if (b.waiting && !b.eventsToWaitFor.contains(a)) {
                    if (!Sys.isDefined(b.events[a]) && !Sys.isDefined(b.handlers[a])) {
                        c = b.onWaitEventReceived.bind(b, a);
                        b.addListener(a, c, b);
                        b.customListeners[a] = c
                    }
                    b.eventsToWaitFor.push(a)
                }
            }, onWaitEventReceived: function (a) {
                var c = this, b = c.eventsToWaitFor.indexOf(a);
                if (b >= 0) {
                    c.eventsToWaitFor.splice(b, 1);
                    c.removeWaitEventListener(a)
                }
                c.checkForCompletion()
            }, onWaitIsComplete: function () {
            }
        }, executeOnInstantiation: {
            initialize: function () {
                var a = this;
                a.eventsToWaitFor = [];
                a.waiting = false;
                a.customListeners = {};
                if (!Sys.isDefined(a.events)) {
                    a.events = {}
                }
            }
        }
    }
};
Sys.ns("Mixins");
Mixins.properties = {
    model: {
        methods: {
            hasProperty: function (b) {
                var a = this.readData("properties")[b];
                return Sys.isDefined(a) && a.length > 0
            }, addProperty: function (c, b) {
                var a = this.readData("properties");
                if (!Sys.isDefined(a[c])) {
                    a[c] = [b]
                } else {
                    if (!a[c].contains(b)) {
                        a[c].push(b)
                    }
                }
                this.storeData("properties", a)
            }, removeProperty: function (c, b) {
                var a = this.readData("properties")[c];
                if (Sys.isDefined(a) && a.contains(b)) {
                    a.splice(a.indexOf(b), 1)
                }
            }
        }
    }, controller: {
        executeOnInstantiation: {
            setupEvents: function (a) {
                var c = this, b = this.model.PROPERTIES || {},
                    d = {"view:addProperty": c.addProperty, "view:removeProperty": c.removeProperty};
                c.model.storeData("properties", b);
                d["request:" + c.MODULE_NAME + ".addProperty"] = c.addProperty;
                d["request:" + c.MODULE_NAME + ".removeProperty"] = c.removeProperty;
                c.on(d);
                if (Sys.isDefined(a) && a.updateOnStartup === true) {
                    c.updateAppearance()
                }
            }
        }, methods: {
            addProperty: function (c, b) {
                var a = !this.model.hasProperty(c);
                this.model.addProperty(c, b);
                if (a) {
                    this.updateAppearance()
                }
            }, updateAppearance: function () {
            }, removeProperty: function (c, b) {
                var a = this;
                if (a.model.hasProperty(c)) {
                    a.model.removeProperty(c, b);
                    if (!a.model.hasProperty(c)) {
                        a.updateAppearance()
                    }
                }
            }
        }
    }
};
Sys.ns("Mixins");
Mixins.trigger = {
    controller: {
        methods: {
            registerTriggers: function (a) {
                throw new Error("Abstract method! Must be implemented!")
            }, onTriggerReady: function () {
                this.registerTriggers(Services.trigger)
            }
        }, executeOnInstantiation: {
            setupEvents: function () {
                this.on({"notify:trigger.ready": this.onTriggerReady})
            }
        }
    }
};
Sys.ns("NetEntExtend.API");
NetEntExtend.API.BaseGetter = {
    platforms: ["desktop", "mobile"], isAvailable: function () {
        return true
    }, validateNumArguments: function () {
        return arguments.length === 3
    }, validateArguments: function () {
        return true
    }, func: function () {
    }
};
Sys.ns("NetEntExtend.API");
NetEntExtend.API.BaseSetter = {
    platforms: ["desktop", "mobile"], isAvailable: function (a) {
        return this.model.readData("inIdleState") && Services.settingsManager.isSettable(a)
    }, validateNumArguments: function () {
        return arguments.length === 4
    }, validateArguments: function () {
        return true
    }, func: function () {
    }
};
Sys.ns("NetEntExtend.API");
NetEntExtend.API.BaseCall = {
    platforms: ["desktop", "mobile"], isAvailable: function () {
        return this.model.readData("inIdleState") && !Services.storage.readData("dialog.showing")
    }, validateNumArguments: function () {
        return arguments.length === 3
    }, validateArguments: function () {
        return true
    }, func: function () {
    }
};
Sys.ns("NetEntExtend.API");
NetEntExtend.API.Getters = {
    balanceInCurrency: Sys.applyPropertiesIf({
        func: function () {
            var d = this, b = Services.moneyManager, a = b.getBalanceCents(), e = b.formatMoneyCurrencySign(a),
                c = Array.prototype.slice.call(arguments), f = d.addParamsToArgument(c, e);
            d.success.apply(d, f)
        }
    }, NetEntExtend.API.BaseGetter), betInCurrency: Sys.applyPropertiesIf({
        func: function () {
            var d = this, a = Services.moneyManager, c = a.getBetCents(), e = a.formatMoneyCurrencySign(c),
                b = Array.prototype.slice.call(arguments), f = d.addParamsToArgument(b, e);
            d.success.apply(d, f)
        }
    }, NetEntExtend.API.BaseGetter), winInCurrency: Sys.applyPropertiesIf({
        func: function () {
            var d = this, a = Services.storage.readData("cashField.winInCents"),
                b = Services.moneyManager.formatMoneyCurrencySign(a), c = Array.prototype.slice.call(arguments),
                e = d.addParamsToArgument(c, b);
            d.success.apply(d, e)
        }
    }, NetEntExtend.API.BaseGetter), audio: Sys.applyPropertiesIf({
        func: function () {
            var b = this, d = Services.settingsManager.getSetting("volume") > 0,
                a = Array.prototype.slice.call(arguments), c = b.addParamsToArgument(a, d);
            b.success.apply(b, c)
        }
    }, NetEntExtend.API.BaseGetter), currentPlayMode: Sys.applyPropertiesIf({
        func: function () {
            var b = Services.storage.readData("playModeManager.modes"), a = Array.prototype.slice.call(arguments),
                c = this.addParamsToArgument(a, b);
            this.success.apply(this, c)
        }
    }, NetEntExtend.API.BaseGetter), autoplayNumberOfRoundsAvailable: Sys.applyPropertiesIf({
        func: function () {
            var c = this, a = c.autoplayNumberOfRoundsAvailable(), b = Array.prototype.slice.call(arguments),
                d = c.addParamsToArgument(b, a);
            c.success.apply(c, d)
        }
    }, NetEntExtend.API.BaseGetter), autoplayCurrentRoundsLeft: Sys.applyPropertiesIf({
        func: function () {
            var d = this, b = Services.storage.readData("autoPlayer.roundsLeft"),
                a = Sys.isDefined(b) && b > 0 ? b : null, c = Array.prototype.slice.call(arguments),
                e = d.addParamsToArgument(c, a);
            d.success.apply(d, e)
        }
    }, NetEntExtend.API.BaseGetter), paytableCount: Sys.applyPropertiesIf({
        func: function () {
            var a = Services.storage.readData("paytable.numberOfPages"), b = Array.prototype.slice.call(arguments),
                c = this.addParamsToArgument(b, a);
            this.success.apply(this, c)
        }
    }, NetEntExtend.API.BaseGetter), paytablePage: Sys.applyPropertiesIf({
        func: function () {
            var b = null, a = Array.prototype.slice.call(arguments);
            if (Services.storage.readData("paytable.showing")) {
                b = Services.storage.readData("paytable.currentPage")
            }
            this.success.apply(this, this.addParamsToArgument(a, b))
        }
    }, NetEntExtend.API.BaseGetter), volumeLevel: Sys.applyPropertiesIf({
        func: function () {
            var c = this, b = Sys.utils.toInt(Services.settingsManager.getSetting("volume") * 100),
                a = Array.prototype.slice.call(arguments), d = c.addParamsToArgument(a, b);
            c.success.apply(c, d)
        }
    }, NetEntExtend.API.BaseGetter), debugMode: Sys.applyPropertiesIf({
        func: function () {
            var c = this, a = false, b = Array.prototype.slice.call(arguments), d;
            d = c.addParamsToArgument(b, a);
            c.success.apply(c, d)
        }
    }, NetEntExtend.API.BaseGetter)
};
Sys.ns("NetEntExtend.API");
NetEntExtend.API.Setters = {
    volumeLevel: Sys.applyPropertiesIf({
        platforms: ["desktop"], isAvailable: function () {
            return true
        }, validateArguments: function () {
            return Sys.isNumber(arguments[3]) && 0 <= arguments[3] && arguments[3] <= 100
        }, func: function () {
            var b = this, c = arguments[3] / 100, a = Array.prototype.slice.call(arguments);
            b.updateSetting("volume", c, a)
        }
    }, NetEntExtend.API.BaseSetter),
    audio: Sys.applyPropertiesIf({
        isAvailable: function () {
            return true
        }, validateArguments: function () {
            return typeof arguments[3] === "boolean"
        }, func: function () {
            var c = this, a = arguments[3] ? 1 : 0, b = Array.prototype.slice.call(arguments);
            c.updateSetting("volume", a, b)
        }
    }, NetEntExtend.API.BaseSetter),
    inGameMessage: Sys.applyPropertiesIf({
        platforms: ["mobile"], isAvailable: function () {
            return true
        }, validateArguments: function () {
            var a = arguments[3], b;
            if (Sys.isArray(a) && a.length > 0) {
                b = Sys.find(a, function (c) {
                    if (Sys.isObj(c) && Sys.isString(c.text)) {
                        if (Sys.isDefined(c.type)) {
                            if (c.type !== "link" && c.type !== "text") {
                                return true
                            }
                            if (c.type === "link" && Sys.isDefined(c.url) && !Sys.isString(c.url)) {
                                return true
                            }
                        }
                        return false
                    }
                    return true
                });
                return !Sys.isDefined(b)
            }
            return false
        }, func: function () {
            var f = this, g = arguments[3], e = [], c = 60, d, h = "", a = 0, b = Array.prototype.slice.call(arguments);
            g.forEach(function (i) {
                a++;
                h += i.text;
                if (h.length > c) {
                    i.text = i.text.substring(0, i.text.length - h.length + c)
                }
                if (i.text.length > 0) {
                    if (Sys.isDefined(i.type) && i.type === "link") {
                        d = new Interface.utils.Button({
                            id: "ticker_lnk_" + a,
                            label: i.text,
                            clickCallback: function () {
                                Sys.utils.openURL(i.url)
                            }
                        });
                        d.enable();
                        window.linkContainer = d.getContainer();
                        window.linkContainer.addCSSClass("netEntExtend_button");
                        e.push(window.linkContainer)
                    } else {
                        e.push(new Sys.Element({tag: "span", textContent: i.text}))
                    }
                }
            });
            f.fireEvent("request:ticker.enable", "netEntExtend");
            f.fireEvent("request:ticker.setText", e);
            f.success.apply(f, b)
        }
    }, NetEntExtend.API.BaseSetter)
};
Sys.ns("NetEntExtend.API");
NetEntExtend.API.Calls = {
    stopAutoplay: Sys.applyPropertiesIf({
        platforms: ["desktop"], isAvailable: function () {
            var b = Services.storage.readData("dialog.showing"), a = Services.storage.readData("autoPlayer.roundsLeft");
            return !b && a > 0
        }, func: function () {
            var b = this, a = Array.prototype.slice.call(arguments);
            b.fireEvent("request:autoPlayer.stop");
            b.success.apply(b, a)
        }
    }, NetEntExtend.API.BaseCall),
    reloadBalance: Sys.applyPropertiesIf({
        func: function () {
            var b = this, a = Array.prototype.slice.call(arguments);
            b.fireEvent("request:serverManager.sendAction", "reloadbalance", "notify:responseParser.reloadBalanceResponseParsed", "notify:serverManager.reloadBalanceFailed");
            b.model.storeData("reloadBalanceArguments", a);
            b.model.storeData("reloadBalanceSpin", false)
        }
    }, NetEntExtend.API.BaseCall),
    createDialogbox: Sys.applyPropertiesIf({
        platforms: ["mobile"], isAvailable: function () {
            return true
        }, validateNumArguments: function () {
            return arguments.length === 7
        }, validateArguments: function () {
            var d = arguments[3], c = arguments[4], b = arguments[5], a = arguments[6];
            return Sys.isString(d) && Sys.isString(c) && Sys.isString(b) && Sys.isArray(a) && a.length > 0 && a.length <= 2 && typeof Sys.find(a, function (e) {
                return !(Sys.isString(e.buttonid) && Sys.isString(e.buttontext))
            }) === "undefined"
        }, func: function () {
            var d = this, g = arguments[3], f = arguments[4].substring(0, 20), e = arguments[5], c = arguments[6],
                b = {id: "netEntExtend_" + g, title: f, text: e, buttons: [], stopAutoplay: true},
                a = Array.prototype.slice.call(arguments);
            Sys.each(c, function (h) {
                var i = {};
                i.action = function () {
                    var j = Sys.isDefined(this.buttontype) ? this.buttontype.toLowerCase() : "";
                    d.fireEvent("request:postman.sendMessage", ["event", "dialogBoxClosed", this.dialogid, this.buttonid]);
                    switch (j) {
                        case"gotolobby":
                            Environment.goToLobby(this.reason);
                            break;
                        case"reload":
                            Environment.reload();
                            break;
                        default:
                            break
                    }
                };
                i.scope = {dialogid: g, buttonid: h.buttonid, buttontype: h.action, reason: h.reason};
                i.text = h.buttontext;
                i.buttonid = h.buttonid;
                b.buttons.push(i)
            });
            d.fireEvent("request:customMessages.showDialog", b);
            d.success.apply(d, a)
        }
    }, NetEntExtend.API.BaseCall),
    removeDialogbox: Sys.applyPropertiesIf({
        platforms: ["mobile"], isAvailable: function () {
            return true
        }, validateNumArguments: function () {
            return arguments.length === 4
        }, validateArguments: function () {
            return Sys.isString(arguments[3])
        }, func: function () {
            var b = this, a = Array.prototype.slice.call(arguments);
            b.fireEvent("request:customMessages.removeDialog", "netEntExtend_" + arguments[3]);
            b.success.apply(b, a)
        }
    }, NetEntExtend.API.BaseCall),
    pluginError: Sys.applyPropertiesIf({
        platforms: ["mobile"], isAvailable: function () {
            return true
        }, func: function () {
            var a = Array.prototype.slice.call(arguments);
            this.fireEvent("request:errorManager.handleError");
            this.success.apply(this, a)
        }
    }, NetEntExtend.API.BaseCall),
    deactivatePluginMenu: Sys.applyPropertiesIf({
        platforms: ["mobile"], isAvailable: function () {
            return true
        }, func: function () {
            var a = Array.prototype.slice.call(arguments);
            this.fireEvent("request:pluginMenu.deactivate");
            this.success.apply(this, a)
        }
    }, NetEntExtend.API.BaseCall),
    pluginNotification: Sys.applyPropertiesIf({
        platforms: ["mobile"], isAvailable: function () {
            return true
        }, validateNumArguments: function () {
            return arguments.length === 4
        }, validateArguments: function () {
            return Sys.isString(arguments[3])
        }, func: function () {
            var a = Array.prototype.slice.call(arguments);
            this.fireEvent("request:pluginMenu.notification", arguments[3]);
            this.success.apply(this, a)
        }
    }, NetEntExtend.API.BaseCall),
    pluginChangeMenuHeight: Sys.applyPropertiesIf({
        platforms: ["mobile"], isAvailable: function () {
            return true
        }, validateNumArguments: function () {
            return arguments.length === 4
        }, validateArguments: function () {
            return Sys.isNumber(arguments[3]) || Sys.isObj(arguments[3])
        }, func: function () {
            var a = Array.prototype.slice.call(arguments);
            this.fireEvent("request:pluginMenu.changeMenuHeight", arguments[3]);
            this.success.apply(this, a)
        }
    }, NetEntExtend.API.BaseCall),
    showSystemClock: Sys.applyPropertiesIf({
        platforms: ["desktop", "mobile"], isAvailable: function () {
            return true
        }, func: function () {
            var a = Array.prototype.slice.call(arguments);
            this.fireEvent("request:systemClock.show");
            this.success.apply(this, a)
        }
    }, NetEntExtend.API.BaseCall)
};
Sys.ns("NetEntExtend.API");
Sys.apply(NetEntExtend.API.Getters, {
    balanceInCoins: Sys.applyPropertiesIf({
        func: function () {
            var d = this, b = Services.moneyManager, a = b.getBalanceCoins(), c = d.addParamsToArgument(arguments, a);
            d.success.apply(d, c)
        }
    }, NetEntExtend.API.BaseGetter), betInCoins: Sys.applyPropertiesIf({
        func: function () {
            var d = this, a = Services.moneyManager, c = a.getBetCoins(), b = d.addParamsToArgument(arguments, c);
            d.success.apply(d, b)
        }
    }, NetEntExtend.API.BaseGetter), availableCoins: Sys.applyPropertiesIf({
        func: function () {
            var d = this, c = Resources.readData("gameServerInitResponse"), a = c["denomination.all"],
                b = d.addParamsToArgument(arguments, a);
            d.success.apply(d, b)
        }
    }, NetEntExtend.API.BaseGetter), selectedCoinValue: Sys.applyPropertiesIf({
        func: function () {
            var c = this, a = Services.moneyManager, d = a.model.readData("denomination"),
                b = c.addParamsToArgument(arguments, d);
            c.success.apply(c, b)
        }
    }, NetEntExtend.API.BaseGetter), winInCoins: Sys.applyPropertiesIf({
        func: function () {
            var d = this, b = Services.storage.readData("cashField.winInCents"),
                e = Services.moneyManager.model.readData("denomination"), a = Math.floor(b / e),
                c = d.addParamsToArgument(arguments, a);
            d.success.apply(d, c)
        }
    }, NetEntExtend.API.BaseGetter), freeRoundsLeft: Sys.applyPropertiesIf({
        func: function () {
            var d = this, c = Services.storage.readData("freeRounds.roundsLeft"),
                a = Sys.isDefined(c) && c > 0 ? c : null, b = d.addParamsToArgument(arguments, a);
            d.success.apply(d, b)
        }
    }, NetEntExtend.API.BaseGetter), freeSpinsLeft: Sys.applyPropertiesIf({
        func: function () {
            var c = this, b = Services.storage.readData("freespin.freespinsLeft"),
                a = Sys.isDefined(b) && b >= 0 && ["FREESPIN", "SUPERSPIN"].contains(c.model.readData("gameMode")) ? b : null;
            c.success.apply(c, c.addParamsToArgument(arguments, a))
        }
    }, NetEntExtend.API.BaseGetter)
});
Sys.ns("NetEntExtend.API");
Sys.apply(NetEntExtend.API.Setters, {});
Sys.ns("NetEntExtend.API");
Sys.apply(NetEntExtend.API.Calls, {});
Sys.ns("NetEntExtend.API.Restricted");
NetEntExtend.API.Restricted.Getters = Sys.apply(Sys.clone(NetEntExtend.API.Getters), {});
Sys.ns("NetEntExtend.API.Restricted");
NetEntExtend.API.Restricted.Setters = Sys.apply(Sys.clone(NetEntExtend.API.Setters), {});
Sys.ns("NetEntExtend.API.Restricted");
NetEntExtend.API.Restricted.Calls = Sys.apply(Sys.clone(NetEntExtend.API.Calls), {
    startAutoplay: Sys.applyPropertiesIf({
        platforms: ["desktop"],
        validateNumArguments: function () {
            return arguments.length === 4
        },
        validateArguments: function () {
            var c = this, b = c.autoplayNumberOfRoundsAvailable(), d = b === null ? [] : b.split(","), a = arguments[3];
            return Sys.isString(a) && d.contains(a)
        },
        func: function () {
            var b = this, a = arguments[3];
            Services.settingsManager.storeSetting("autoPlayNrSpins", Number(a), false);
            b.fireEvent("request:autoPlayer.start");
            b.success.apply(b, arguments)
        }
    }, NetEntExtend.API.BaseCall),
    showAutoplay: Sys.applyPropertiesIf({
        platforms: ["desktop"], isAvailable: function () {
            var d = Services.storage.readData("autoplaySettings.showing"),
                c = Services.storage.readData("spinSettings.showing"), e = Services.storage.readData("dialog.showing"),
                b = Services.storage.readData("IntroMovie.showing"), a = this.model.readData("featureSplash.showing");
            return !(d || c || e || b || a)
        }, func: function () {
            var a = this;
            a.fireEvent("request:autoplaySettings.show");
            a.fireEvent("request:spinSettings.show");
            if (!(Services.storage.readData("autoplaySettings.showing") || Services.storage.readData("spinSettings.showing"))) {
                a.error(arguments, a.model.ERROR_CODES.UNKNOWN_ERROR)
            } else {
                a.success.apply(a, arguments)
            }
        }
    }, NetEntExtend.API.BaseCall),
    hideAutoplay: Sys.applyPropertiesIf({
        platforms: ["desktop"], isAvailable: function () {
            return !Services.storage.readData("dialog.showing") && (Services.storage.readData("autoplaySettings.showing") || Services.storage.readData("spinSettings.showing"))
        }, func: function () {
            var a = this;
            a.fireEvent("request:autoplaySettings.hide");
            a.fireEvent("request:spinSettings.hide");
            a.success.apply(a, arguments)
        }
    }, NetEntExtend.API.BaseCall),
    showPaytable: Sys.applyPropertiesIf({
        platforms: ["desktop"], isAvailable: function () {
            return !Services.storage.readData("dialog.showing")
        }, validateNumArguments: function () {
            return arguments.length === 4
        }, validateArguments: function () {
            var b = arguments[3], a = Services.storage.readData("paytable.numberOfPages");
            return Sys.isNumber(b) && (1 <= b && b <= a)
        }, func: function () {
            var a = this, b = arguments[3];
            a.fireEvent("request:paytable.show", b);
            a.success.apply(a, arguments)
        }
    }, NetEntExtend.API.BaseCall),
    hidePaytable: Sys.applyPropertiesIf({
        platforms: ["desktop"], isAvailable: function () {
            return !Services.storage.readData("dialog.showing") && Services.storage.readData("paytable.showing")
        }, func: function () {
            var a = this;
            a.fireEvent("request:paytable.hide");
            a.success.apply(a, arguments)
        }
    }, NetEntExtend.API.BaseCall),
    paytableForward: Sys.applyPropertiesIf({
        platforms: ["desktop"], isAvailable: function () {
            return !Services.storage.readData("dialog.showing") && Services.storage.readData("paytable.showing")
        }, func: function () {
            var a = this;
            a.fireEvent("request:paytable.forward");
            a.success.apply(a, arguments)
        }
    }, NetEntExtend.API.BaseCall),
    paytableBackward: Sys.applyPropertiesIf({
        platforms: ["desktop"], isAvailable: function () {
            return !Services.storage.readData("dialog.showing") && Services.storage.readData("paytable.showing")
        }, func: function () {
            var a = this;
            a.fireEvent("request:paytable.backward");
            a.success.apply(a, arguments)
        }
    }, NetEntExtend.API.BaseCall),
    closeSplash: Sys.applyPropertiesIf({
        platforms: ["desktop"], isAvailable: function () {
            var a = this;
            return !Services.storage.readData("dialog.showing") && a.model.readData("featureSplash.showing")
        }, func: function () {
            var a = this;
            a.fireEvent("request:featureSplash.close");
            a.success.apply(a, arguments)
        }
    }, NetEntExtend.API.BaseCall),
    startFreespins: Sys.applyPropertiesIf({
        platforms: ["desktop"], isAvailable: function () {
            return !Services.storage.readData("dialog.showing") && Services.storage.readData("freeSpins.canStart")
        }, func: function () {
            var a = this;
            a.fireEvent("request:freeSpins.start");
            a.success.apply(a, arguments)
        }
    }, NetEntExtend.API.BaseCall),
    openHelp: Sys.applyPropertiesIf({
        platforms: ["desktop"], isAvailable: function () {
            var a = this;
            return !Services.storage.readData("dialog.showing") && a.model.readData("inIdleState") && !Services.storage.readData("gameRules.showing")
        }, func: function () {
            var a = this;
            a.fireEvent("request:gameRules.show");
            a.success.apply(a, arguments)
        }
    }, NetEntExtend.API.BaseCall),
    skipIntro: Sys.applyPropertiesIf({
        platforms: ["desktop"], isAvailable: function () {
            return !Services.storage.readData("dialog.showing") && Services.storage.readData("IntroMovie.showing")
        }, func: function () {
            var a = this;
            a.fireEvent("request:introMovie.close");
            a.success.apply(a, arguments)
        }
    }, NetEntExtend.API.BaseCall)
});
Sys.ns("NetEntExtend.API");
Sys.apply(NetEntExtend.API.Restricted.Setters, {
    betLevel: Sys.applyPropertiesIf({
        platforms: ["desktop"],
        isAvailable: function () {
            return NetEntExtend.API.BaseSetter.isAvailable.call(this, "betLevel")
        },
        validateArguments: function () {
            var c = arguments[3], a = Resources.readData("gameServerInitResponse"), b = a["betlevel.all"].split(",");
            return Sys.isNumber(c) && b.contains(String(c))
        },
        func: function () {
            var a = this;
            a.updateSetting("betLevel", arguments[3], arguments)
        }
    }, NetEntExtend.API.BaseSetter),
    coinValue: Sys.applyPropertiesIf({
        platforms: ["desktop"], isAvailable: function () {
            return NetEntExtend.API.BaseSetter.isAvailable.call(this, "denomination")
        }, validateArguments: function () {
            var b = arguments[3], c = Resources.readData("gameServerInitResponse"),
                a = c["denomination.all"].split(",");
            return Sys.isNumber(b) && a.contains(String(b))
        }, func: function () {
            var a = this;
            a.updateSetting("denomination", arguments[3], arguments)
        }
    }, NetEntExtend.API.BaseSetter)
});
Sys.ns("NetEntExtend.API");
Sys.apply(NetEntExtend.API.Restricted.Calls, {
    startSpin: Sys.applyPropertiesIf({
        platforms: ["desktop"],
        isAvailable: function () {
            return NetEntExtend.API.BaseCall.isAvailable.call(this) && Services.moneyManager.canPlaceAnotherBet()
        },
        func: function () {
            var a = this;
            a.fireEvent("request:spin.startNewRound");
            a.success.apply(a, arguments)
        }
    }, NetEntExtend.API.BaseCall),
    startQuickSpin: Sys.applyPropertiesIf({
        platforms: ["desktop"], isAvailable: function () {
            return NetEntExtend.API.BaseCall.isAvailable.call(this) && Services.settingsManager.isSettable("quickSpin") && Services.moneyManager.canPlaceAnotherBet()
        }, func: function () {
            var b = this, a = Services.settingsManager.getSetting("quickSpin");
            b.fireEvent("request:settingsManager.storeData", "quickSpin", true);
            b.fireEvent("request:spin.startNewRound");
            b.onEnteringIdleState.push(function () {
                b.fireEvent("request:settingsManager.storeData", "quickSpin", a)
            });
            b.success.apply(b, arguments)
        }
    }, NetEntExtend.API.BaseCall),
    maxBetSpin: Sys.applyPropertiesIf({
        platforms: ["desktop"], func: function () {
            var b = this, c = Resources.readData("gameServerInitResponseObject").betlevel.all,
                a = Math.max.apply(null, c);
            b.fireEvent("request:settingsManager.storeData", "betLevel", a);
            b.startRound();
            b.success.apply(b, arguments)
        }
    }, NetEntExtend.API.BaseCall),
    featurePreview: Sys.applyPropertiesIf({
        platforms: ["desktop"], func: function () {
            var a = this;
            a.success.apply(a, arguments)
        }
    }, NetEntExtend.API.BaseCall)
});
Sys.ns("Core.NetEntExtend");
Core.NetEntExtend = {
    constructor: function () {
        Core.NetEntExtend.superclass.constructor.apply(this, arguments)
    }, getDefaultMVCClasses: function () {
        return {model: Core.NetEntExtendModel, controller: Core.NetEntExtendController}
    }
};
Core.NetEntExtend = Sys.extend(Core.Module, Core.NetEntExtend, "Core.NetEntExtend");
Sys.ns("Core");
Core.NetEntExtendController = {
    USE_LOGGING: false,
    ROUND_START_EVENT: "request:spin.startNewRound",
    constructor: function () {
        Core.NetEntExtendController.superclass.constructor.apply(this, arguments)
    },
    init: function () {
        var a = this;
        Core.NetEntExtendController.superclass.init.apply(a, arguments);
        a.onEnteringIdleState = [];
        a.setupAPI()
    },
    setupEvents: function () {
        var a = this;
        a.on({
            "notify:stateHandler.enteringIdleState": a.enteringIdleState,
            "notify:stateHandler.leavingIdleState": a.leavingIdleState,
            "notify:netEntExtendEvents.eventTriggered": a.sendMessage,
            "notify:responseParser.reloadBalanceResponseParsed": a.onReloadBalanceResponse,
            "notify:serverManager.reloadBalanceFailed": a.onReloadBalanceFailed,
            "notify:featureSplash.showing": a.onFeatureSplashShowing,
            "notify:featureSplash.closed": a.onFeatureSplashClosed,
            "notify:gameModeChanged": a.onGameModeChanged,
            "request:NetEntExtend.newMessage": a.handleIncomingMessage
        })
    },
    setupAPI: function () {
        var b = this, c = b.model.readData("useRestricted"),
            a = (c === true) ? NetEntExtend.API.Restricted : NetEntExtend.API;
        b.API = {get: a.Getters, set: a.Setters, call: a.Calls}
    },
    enteringIdleState: function () {
        var a = this;
        a.onEnteringIdleState.forEach(function (b) {
            b.apply(a, arguments)
        });
        a.onEnteringIdleState = [];
        a.model.storeData("inIdleState", true)
    },
    leavingIdleState: function () {
        var a = this;
        a.model.storeData("inIdleState", false);
        a.model.storeData("reloadBalanceSpin", true)
    },
    handleIncomingMessage: function () {
        var d = this, b = arguments[0], c = arguments[1], a = arguments[2], f;
        if (arguments.length < 3 || !Sys.isString(b) || !Sys.isNumber(c) || !Sys.isString(a)) {
            d.error(arguments, d.model.ERROR_CODES.WRONG_NUMBER_OF_ARGUMENTS)
        } else {
            if (!Sys.isDefined(d.API[b]) || !Sys.isDefined(d.API[b][a])) {
                d.error(arguments, d.model.ERROR_CODES.FUNCTIONALITY_NOT_AVAILABLE)
            } else {
                f = d.API[b][a];
                if ((Platform.isDesktopDevice && f.platforms.indexOf("desktop") === -1) || ((Platform.isMobileDevice || Platform.isTabletDevice) && f.platforms.indexOf("mobile") === -1)) {
                    d.error(arguments, d.model.ERROR_CODES.FUNCTIONALITY_NOT_AVAILABLE)
                } else {
                    if (!f.isAvailable.apply(d, arguments)) {
                        d.error(arguments, d.model.ERROR_CODES.NOT_AVAILABLE_IN_CURRENT_STATE)
                    } else {
                        if (!f.validateNumArguments.apply(d, arguments)) {
                            d.error(arguments, d.model.ERROR_CODES.WRONG_NUMBER_OF_ARGUMENTS)
                        } else {
                            if (!f.validateArguments.apply(d, arguments)) {
                                d.error(arguments, d.model.ERROR_CODES.ILLEGAL_ARGUMENT)
                            } else {
                                try {
                                    f.func.apply(d, arguments)
                                } catch (g) {
                                    d.error(arguments, d.model.ERROR_CODES.UNKNOWN_ERROR)
                                }
                            }
                        }
                    }
                }
            }
        }
    },
    success: function () {
        var b = this, a = b.getResponseArguments.apply(b, arguments);
        b.sendMessage(["success", a.callId].concat(a.rest))
    },
    error: function (c, a, e) {
        var d = this, b = d.getResponseArguments.apply(d, c);
        d.sendMessage(["error", b.callId, a, e])
    },
    sendMessage: function (a) {
        var b = "";
        this.fireEvent("request:postman.sendMessage", a)
    },
    getResponseArguments: function () {
        var a = Array.prototype.slice.call(arguments), c = a[1], b = a.splice(3);
        return {callId: c, rest: b}
    },
    addParamsToArgument: function (c, b) {
        var a = Array.prototype.slice.call(c);
        if (Sys.isArray(b)) {
            b.forEach(function (d) {
                a.push(d)
            })
        } else {
            a.push(b)
        }
        return a
    },
    updateSetting: function (c, f, b) {
        var e = this, a = Services.settingsManager, d = this.model.ERROR_CODES;
        a.storeSetting(c, f, false);
        if (a.getSetting(c) === f) {
            e.success.apply(e, b)
        } else {
            e.error(b, d.UNKNOWN_ERROR)
        }
    },
    autoplayNumberOfRoundsAvailable: function () {
        var a = Services.storage.readData("spinSettings.autoplayRoundsAvailable");
        return Sys.isDefined(a) ? a.toString() : null
    },
    onReloadBalanceResponse: function (a) {
        var c = this, b = c.model.readData("reloadBalanceArguments"), d = c.model.readData("reloadBalanceSpin"),
            e = a.credit;
        if (d) {
            c.success.apply(c, c.addParamsToArgument(b, "busy"))
        } else {
            if (Sys.isNumber(e)) {
                Services.moneyManager.setBalance(e);
                c.success.apply(c, c.addParamsToArgument(b, e))
            }
        }
    },
    onReloadBalanceFailed: function () {
        var b = this, a = b.model.readData("reloadBalanceArguments");
        b.error(a, b.model.UNKNOWN_ERROR)
    },
    onFeatureSplashShowing: function () {
        this.model.storeData("featureSplash.showing", true)
    },
    onFeatureSplashClosed: function () {
        this.model.storeData("featureSplash.showing", false)
    },
    startRound: function () {
        var a = this;
        a.fireEvent(a.ROUND_START_EVENT)
    },
    onGameModeChanged: function (a) {
        this.model.storeData("gameMode", a)
    }
};
Core.NetEntExtendController = Sys.extend(Core.Controller, Core.NetEntExtendController, "Core.NetEntExtendController");
Sys.ns("Core");
Core.NetEntExtendModel = {
    ERROR_CODES: {
        UNKNOWN_ERROR: 0,
        ILLEGAL_ARGUMENT: 1,
        EVENTS_NOT_AVAILABLE_IN_GAME: 7,
        CALLBACK_NOT_PROVIDED: 8,
        FUNCTIONALITY_NOT_AVAILABLE: 9,
        WRONG_NUMBER_OF_ARGUMENTS: 10,
        NO_RESPONSE_FROM_GAME: 11,
        NOT_AVAILABLE_IN_CURRENT_STATE: 12,
        HTML_GAME_LAUNCH_FAILED: 18
    }, constructor: function () {
        Core.NetEntExtendModel.superclass.constructor.apply(this, arguments)
    }, setupData: function () {
        var d = this, c = Resources.readData("gameServerInitResponse"),
            b = (Sys.isDefined(c)) ? c["gameEventSetters.enabled"] : false, a = false;
        if (Sys.isDefined(b) && b === true) {
            a = true
        }
        d.storeData("useRestricted", a);
        d.storeData("locked", true);
        d.storeData("inIdleState", false);
        d.storeData("featureSplash.showing", false)
    }
};
Core.NetEntExtendModel = Sys.extend(Core.Model, Core.NetEntExtendModel, "Core.NetEntExtendModel");
Sys.ns("Core.NetEntExtendEvents");
Core.NetEntExtendEvents = {
    constructor: function () {
        Core.NetEntExtendEvents.superclass.constructor.apply(this, arguments)
    }, getDefaultMVCClasses: function () {
        return {model: Core.NetEntExtendEventsModel, controller: Core.NetEntExtendEventsController}
    }
};
Core.NetEntExtendEvents = Sys.extend(Core.Module, Core.NetEntExtendEvents, "Core.NetEntExtendEvents");
Sys.ns("Core");
Core.NetEntExtendEventsController = {
    USE_LOGGING: false, constructor: function () {
        Core.NetEntExtendEventsController.superclass.constructor.apply(this, arguments)
    }, setupEvents: function () {
        var b = this, a = {
            "notify:autoPlayer.starting": b.onAutoplayStarting,
            "notify:autoPlayer.startRound": b.onAutoplayStartRound,
            "notify:settingsManager.settingChanged": b.onSettingsChanged,
            "notify:spin.spinAnimationStarted": b.onSpinStart,
            "notify:spin.spinAnimationComplete": b.onSpinEnded,
            "notify:stateHandler.enteringStandardWinPresentationState": b.onWinPresentationStarted,
            "notify:responseParser.responseParsed": b.onServerResponseParsed,
            "notify:standardWin.presentationComplete": b.onWinPresentationComplete,
            "notify:paytable.shown": b.sendEvent.bind(b, "paytableToggle", true),
            "notify:paytable.hidden": b.sendEvent.bind(b, "paytableToggle", false),
            "notify:bonusGameIntro.bonusGameStarted": b.onBonusGameStarted,
            "notify:bonusGameOutro.bonusGameEnded": b.onBonusGameEnded,
            "notify:gameModeChanged": b.onGameModeChanged,
            "notify:stateHandler.enteringIdleState": b.onEnteringIdleState,
            "notify:stateHandler.leavingIdleState": b.onLeavingIdleState,
            "notify:cashField.update": b.onCashFieldUpdate,
            "notify:freeRounds.started": b.onFreeRoundsStarted,
            "notify:freeRounds.ended": b.onFreeRoundsEnded,
            "notify:freeRounds.nextRound": b.onFreeRoundsNextRound,
            "notify:pluginMenu.activated": b.onPluginMenuActivated,
            "notify:pluginMenu.deactivated": b.onPluginMenuDeactivated,
            "notify:viewport.PORTRAIT": b.onPortrait,
            "notify:viewport.LANDSCAPE": b.onLandscape,
            "notify:loader.closed": b.onLoaderClosed,
            "notify:customMessages.fatalMessageShowing": b.onFatalCustomMessage
        };
        Sys.iterate(b.model.EVENT_MAP, function (c, d) {
            a[c] = b.sendEvent.bind(b, d)
        });
        b.on(a)
    }, onLoaderClosed: function () {
        if (this.model.readData("isRestore") === true) {
            this.sendEvent("gameRoundStarted")
        }
    }, onFatalCustomMessage: function (b, a) {
        if (b === 990 || b === 992) {
            this.sendEvent("gameError", 18, a)
        }
    }, onFreeRoundsStarted: function (a) {
        this.sendEvent("freeRoundsStarted", a)
    }, onFreeRoundsEnded: function () {
        this.sendEvent("freeRoundsEnded")
    }, onFreeRoundsNextRound: function (a, b) {
        this.sendEvent("freeRoundsNextRound", a, b)
    }, sendEvent: function () {
        var a = Array.prototype.slice.call(arguments), b = "";
        this.fireEvent("notify:netEntExtendEvents.eventTriggered", ["event"].concat(a))
    }, onSpinStart: function () {
        var a = Services.storage.readData("playModeManager.modes");
        this.model.storeData("spinStarted", true);
        this.sendEvent("spinStarted", a)
    }, onSpinEnded: function () {
        this.model.storeData("spinStarted", false);
        this.sendEvent("spinEnded")
    }, onWinPresentationStarted: function () {
        this.sendEvent("spinProgress", "initialWinPresentationStarted")
    }, onServerResponseParsed: function (c) {
        var a = this, b;
        if (a.model.readData("spinStarted")) {
            b = Sys.isDefined(c.gameroundid) ? c.gameroundid : 0;
            a.sendEvent("spinProgress", "outcomeReceived", b)
        }
        if ((c.restore === true)) {
            a.model.storeData("isRestore", true)
        }
    }, onWinPresentationComplete: function (b) {
        var a;
        if (Sys.isDefined(b)) {
            a = (b === true) ? "initialWinPresentationAborted" : "initialWinPresentationEnded"
        }
        if (a) {
            this.sendEvent("spinProgress", a)
        }
    }, onSettingsChanged: function (a, c) {
        var b = this;
        if (a === "volume") {
            b.volumeChange(c)
        }
    }, onAutoplayStarting: function () {
        var a = this, b = Services.settingsManager.getSetting("autoPlayNrSpins");
        a.model.storeData("autoplayRoundsSelected", b);
        a.sendEvent("autoplayStarted", b)
    }, onAutoplayStartRound: function (a) {
        var c = this, b = c.model.readData("autoplayRoundsSelected");
        c.sendEvent("autoplayNextRound", b, a)
    }, volumeChange: function (d) {
        var c = this, b = Math.floor(d * 100), e = d > 0, a = c.model.readData("lastVolume") > 0;
        c.model.storeData("lastVolume", d);
        c.sendEvent("volumeChange", b);
        if (e !== a) {
            c.sendEvent("audioToggle", e)
        }
    }, onCashFieldUpdate: function (d) {
        var b = this, a = b.model, c = a.readData("balance");
        if (Sys.isDefined(c)) {
            if (d !== c) {
                b.sendEvent("balanceChanged");
                a.storeData("balance", d)
            }
        } else {
            a.storeData("balance", d)
        }
    }, onGameModeChanged: function (a) {
        this.model.storeData("gameMode", a.toLowerCase())
    }, onBonusGameStarted: function (a) {
        this.sendEvent("bonusGameStarted", a)
    }, onBonusGameEnded: function (a) {
        this.sendEvent("bonusGameEnded", a)
    }, onEnteringIdleState: function () {
        var b = this, a = b.model.readData("leftIdleState"), c = b.model.readData("isRestore");
        if (a || c) {
            b.sendEvent("gameRoundEnded");
            b.model.storeData("isRestore", false)
        }
        b.model.storeData("leftIdleState", false)
    }, onLeavingIdleState: function () {
        var a = this;
        a.sendEvent("gameRoundStarted");
        a.model.storeData("leftIdleState", true)
    }, onPluginMenuActivated: function () {
        this.sendEvent("pluginMenuActivated")
    }, onPluginMenuDeactivated: function () {
        this.sendEvent("pluginMenuDeactivated")
    }, onPortrait: function () {
        this.sendEvent("rotate", {orientation: "portrait"})
    }, onLandscape: function () {
        this.sendEvent("rotate", {orientation: "landscape"})
    }
};
Core.NetEntExtendEventsController = Sys.extend(Core.Controller, Core.NetEntExtendEventsController, "Core.NetEntExtendEventsController");
Sys.ns("Core");
Core.NetEntExtendEventsModel = {
    EVENT_MAP: {
        "notify:stateHandler.leavingBeforeLoaderCloseState": "gameReady",
        "notify:errorManager.error": "gameError",
        "notify:errorManager.errorDialogClosed": "gameErrorClose",
        "notify:paytable.pageSwitched": "paytablePageSwitch",
        "notify:autoPlayer.stopped": "autoplayStopped"
    }, constructor: function () {
        Core.NetEntExtendEventsModel.superclass.constructor.apply(this, arguments)
    }, setupData: function () {
        this.storeData("autoplay", false);
        this.storeData("gameMode", "basic")
    }, getCurrentGameMode: function () {
        var b = this, a = b.readData("gameMode");
        if (b.readData("autoplay")) {
            a += ", autoplay"
        }
        return a
    }
};
Core.NetEntExtendEventsModel = Sys.extend(Core.Model, Core.NetEntExtendEventsModel, "Core.NetEntExtendEventsModel");
Sys.ns("Core.Slots");
Core.Slots.NetEntExtendEventsModel = {
    SLOTS_EVENT_MAP: {
        "notify:stateHandler.enteringBigWinState": "bigWinStarted",
        "notify:stateHandler.leavingBigWinState": "bigWinEnded",
        "notify:freeSpinIntro.closed": "freeSpinStarted",
        "notify:freeSpinOutro.closed": "freeSpinEnded"
    }, constructor: function () {
        Core.Slots.NetEntExtendEventsModel.superclass.constructor.apply(this, arguments)
    }, setupData: function () {
        Core.Slots.NetEntExtendEventsModel.superclass.setupData.apply(this, arguments);
        Sys.apply(this.EVENT_MAP, this.SLOTS_EVENT_MAP)
    }
};
Core.Slots.NetEntExtendEventsModel = Sys.extend(Core.NetEntExtendEventsModel, Core.Slots.NetEntExtendEventsModel, "Core.Slots.NetEntExtendEventsModel");
Sys.ns("Core");
Core.Postman = {
    constructor: function () {
        Core.Postman.superclass.constructor.apply(this, arguments)
    }, getStateChanges: function () {
        return {setupGame: {waitEvents: ["notify:postman.ready"]}}
    }, getDefaultMVCClasses: function () {
        return {controller: Core.PostmanController}
    }
};
Core.Postman = Sys.extend(Core.Module, Core.Postman, "Core.Postman");
Sys.ns("Core");
Core.PostmanController = {
    IS_READY: false, PLUGIN_TIMEOUT: 30000, constructor: function () {
        Core.PostmanController.superclass.constructor.apply(this, arguments)
    }, setupPlugin: function () {
        var c = this, b = Resources.readData("pluginURL"), a;
        c.iframe = undefined;
        if (c.isStandalone) {
            c.iframe = document.createElement("iframe");
            c.iframe.setAttribute("id", "netEntExtendPlugin");
            c.iframe.setAttribute("frameborder", 0);
            c.iframe.setAttribute("width", "100%");
            c.iframe.setAttribute("height", 0);
            c.iframe.src = b;
            a = document.getElementById("viewport");
            a.insertBefore(c.iframe, a.firstChild);
            c.timeout = setTimeout(function () {
                c.fireEvent("request:loaderErrorHandler.handlePluginTimeoutError")
            }, c.PLUGIN_TIMEOUT)
        } else {
            c.fireEvent("notify:postman.ready");
            c.IS_READY = true
        }
    }, setupEvents: function () {
        var b = this, a = Resources.readData("pluginURL");
        b.isInIframe = window !== window.parent;
        b.isStandalone = Sys.isDefined(a);
        b.on({
            "request:postman.sendMessage": b.sendMessage,
            "notify:stateHandler.enteringSetupGameState": b.setupPlugin
        });
        window.addEventListener("message", function (c) {
            if (c.data.moduleId) {
                b.fireEvent("notify:" + c.data.moduleId + ".notification", c.data)
            } else {
                b.handleIncomingMessage.apply(b, c.data)
            }
        })
    }, handlePluginReadyCall: function (b) {
        var c = this, a = b[3], d = b[4];
        if (b[0] === "call" && b[2] === "pluginReady") {
            if (Sys.isDefined(c.timeout)) {
                clearTimeout(c.timeout)
            }
            c.IS_READY = true;
            c.fireEvent("notify:postman.ready");
            if (Sys.isDefined(a) && Sys.isDefined(d)) {
                c.fireEvent("request:pluginMenu.init", a, d)
            }
            c.sendMessage(["success", b[1]])
        }
    }, handleIncomingMessage: function () {
        var c = this, b = Array.prototype.slice.call(arguments), a = ["request:NetEntExtend.newMessage"].concat(b);
        if (c.isStandalone && !c.IS_READY) {
            c.handlePluginReadyCall(b)
        } else {
            c.fireEvent.apply(c, a)
        }
    }, sendMessage: function (b) {
        var a = this;
        if (a.isInIframe) {
            window.parent.postMessage(b, "*")
        }
        if (Sys.isDefined(a.iframe) && a.isStandalone) {
            a.iframe.contentWindow.postMessage(b, "*")
        }
    }
};
Core.PostmanController = Sys.extend(Core.Controller, Core.PostmanController, "Core.PostmanController");
Sys.ns("Core");
Core.CustomMessages = {
    constructor: function () {
        Core.CustomMessages.superclass.constructor.apply(this, arguments)
    }, getStateChanges: function () {
        var a = this.model;
        return {
            showingCustomMessages: {
                state: {
                    name: "ShowingCustomMessages", execute: function () {
                    }, waitEvents: {"notify:customMessages.messagesClosed": false}
                }
            }, delayBeforeShowingMessages: {
                state: {
                    name: "DelayBeforeShowingMessages", execute: function () {
                    }, waitEvents: {"notify:customMessages.delayComplete": false}
                }
            }, idle: {waitEvents: ["notify:customMessages.messagesClosed"]}, beforeStopping: {
                queue: [function (b) {
                    if (a.hasImmediate() || !a.readData("shouldShowDialogs")) {
                        b.stateHandler.pushState(b.states.showingCustomMessages)
                    }
                }]
            }, setupGame: {waitEvents: ["notify:customMessages.ready"]}, noWinPresentation: {
                queue: [function (b) {
                    if (a.hasDialogs() || !a.readData("shouldShowDialogs")) {
                        b.stateHandler.pushState(b.states.delayBeforeShowingMessages)
                    }
                }]
            }
        }
    }, getMixinDependencies: function () {
        return ["userInput"]
    }, getDefaultMVCClasses: function () {
        return {controller: Core.CustomMessagesController, model: Core.CustomMessagesModel}
    }
};
Core.CustomMessages = Sys.extend(Core.Module, Core.CustomMessages, "Core.CustomMessages");
Sys.ns("Core");
Core.CustomMessagesController = {
    DIALOG_DELAY: 3000,
    ERRORS: {
        DISPLAY_IMMEDIATELY_CLOSE: 990,
        DISPLAY_IMMEDIATELY_CONTINUE: 991,
        DISPLAY_ON_IDLE_CLOSE: 992,
        DISPLAY_ON_IDLE_CONTINUE: 993
    },
    constructor: function () {
        Core.CustomMessagesController.superclass.constructor.apply(this, arguments);
        this.model.storeData("showingLoader", true)
    },
    setupEvents: function () {
        var a = this;
        a.on({
            "request:customMessages.showDialog": a.onShowDialogRequest,
            "request:customMessages.removeDialog": a.onRemoveDialogRequest,
            "notify:serverManager.serverResponseReceived": a.onServerResponseReceived,
            "notify:serverManager.serverErrorReceived": a.onServerErrorReceived,
            "notify:stateHandler.enteringSetupGameState": a.onEnteringSetupGameState,
            "notify:stateHandler.enteringIdleState": a.onEnteringIdleState,
            "notify:stateHandler.leavingIdleState": a.onLeavingIdleState,
            "notify:stateHandler.enteringShowingCustomMessagesState": a.onEnteringShowingCustomMessagesState,
            "notify:stateHandler.leavingBeforeLoaderCloseState": a.onLoaderClose,
            "notify:stateHandler.enteringDelayBeforeShowingMessagesState": a.onEnteringDelayBeforeShowingMessagesState,
            "notify:stateHandler.leavingDelayBeforeShowingMessagesState": a.onLeavingDelayBeforeShowingMessagesState,
            "notify:dialogWindow.dialogShown": a.onDialogShown
        })
    },
    onLoaderClose: function () {
        this.model.storeData("showingLoader", false);
        this.model.storeData("shouldShowDialogs", true)
    },
    onShowDialogRequest: function (b) {
        var c = this, a;
        try {
            a = c.prepareDialogConfig(b)
        } catch (d) {
            c.showTechnicalError();
            c.model.storeData("shouldShowDialogs", false);
            return
        }
        delete a.immediate;
        if (c.model.readData("isIdle")) {
            if (c.model.hasDialogsToWaitFor()) {
                c.model.addDialogToWaitFor(a.id)
            }
            c.fireEvent("request:dialogWindow.showDialog", a)
        } else {
            c.model.addDialog(a)
        }
    },
    onRemoveDialogRequest: function (a) {
        this.model.removeDialogToWaitFor(a);
        this.model.removeDialog(a);
        this.fireEvent("request:dialogWindow.removeDialog", a)
    },
    onServerResponseReceived: function (a) {
        var b = Sys.utils.queryStringToObject(a.responseText, true), c = Object.keys(b).length;
        if (Sys.isDefined(b.messages)) {
            this.handleMessagesFromServerRequest(b.messages, c === 1)
        }
    },
    onServerErrorReceived: function (a) {
        var b = Sys.utils.qsToObj(a.responseText, true);
        if (Sys.isDefined(b.messages)) {
            this.handleMessagesFromServerRequest(b.messages, true)
        }
    },
    handleMessagesFromServerRequest: function (f, c) {
        var h = this, g, b, d, a;
        try {
            g = JSON.parse(f);
            if (Sys.isArray(g)) {
                b = g.pop();
                if (Sys.isDefined(b)) {
                    d = h.createConfigFromMessage(b);
                    a = h.prepareDialogConfig(d);
                    h.model.addDialog(a)
                }
                if (c) {
                    h.showImmediateMessages()
                }
                return
            }
        } catch (i) {
        }
        h.showTechnicalError();
        h.model.storeData("shouldShowDialogs", false)
    },
    onEnteringSetupGameState: function () {
        if (!this.model.readData("showingError")) {
            this.fireEvent("notify:customMessages.ready")
        }
    },
    onEnteringIdleState: function () {
        this.model.storeData("isIdle", true);
        if (!this.model.readData("shouldShowDialogs")) {
            return
        }
        this.showDialogs(this.model.popAll())
    },
    onLeavingIdleState: function () {
        this.model.storeData("isIdle", false)
    },
    onEnteringShowingCustomMessagesState: function () {
        this.showImmediateMessages()
    },
    onEnteringDelayBeforeShowingMessagesState: function () {
        var a = this;
        clearTimeout(a.delayTimeout);
        a.startListeningToUserInput();
        a.delayTimeout = setTimeout(a.fireEvent.bind(a, "notify:customMessages.delayComplete"), a.DIALOG_DELAY)
    },
    onLeavingDelayBeforeShowingMessagesState: function () {
        this.stopListeningToUserInput()
    },
    onUserInputEnd: function (b) {
        var a = this;
        if (Sys.UserInputUtils.isCoordinateTarget(Game.stage.getGameContainer(), b)) {
            clearTimeout(a.delayTimeout);
            a.fireEvent("notify:customMessages.delayComplete")
        }
    },
    showImmediateMessages: function () {
        if (!this.model.readData("shouldShowDialogs")) {
            return
        }
        this.showDialogs(this.model.popAllImmediate())
    },
    onDialogShown: function (b) {
        var a = this;
        if (!Sys.isDefined(b)) {
            return
        }
        a.model.removeDialogToWaitFor(b);
        if (!a.model.hasDialogsToWaitFor()) {
            a.fireEvent("notify:customMessages.messagesClosed")
        }
    },
    showDialogs: function (d) {
        var c = this, a, b;
        if (d.length > 0) {
            for (b = 0; b < d.length; b++) {
                a = d[b];
                c.model.addDialogToWaitFor(a.id);
                if (Services.settingsManager.getSetting("autoPlayNrSpins") > 0 && (a.messageCode === c.ERRORS.DISPLAY_IMMEDIATELY_CONTINUE || a.messageCode === c.ERRORS.DISPLAY_ON_IDLE_CONTINUE || a.stopAutoplay)) {
                    c.fireEvent("request:autoPlayer.stop")
                }
                c.fireEvent("request:dialogWindow.showDialog", a);
                if (a.messageCode === c.ERRORS.DISPLAY_IMMEDIATELY_CLOSE || a.messageCode === c.ERRORS.DISPLAY_ON_IDLE_CLOSE) {
                    c.fireEvent("notify:customMessages.fatalMessageShowing", a.messageCode, a.text)
                }
            }
        } else {
            c.fireEvent("notify:customMessages.messagesClosed")
        }
    },
    createConfigFromMessage: function (e) {
        var d = this, b = d.model, f = d.ERRORS, a = {
            title: Services.languageManager.getText(Language.Keys.messageCaption),
            text: e.message,
            buttons: [],
            immediate: true,
            id: e.code,
            messageCode: e.code
        }, c;
        switch (e.code) {
            case f.DISPLAY_IMMEDIATELY_CLOSE:
                c = b.getCloseButtonConfig(d);
                a.hideGame = true;
                break;
            case f.DISPLAY_IMMEDIATELY_CONTINUE:
                c = b.getContinueButtonConfig(d, true);
                break;
            case f.DISPLAY_ON_IDLE_CLOSE:
                c = b.getCloseButtonConfig(d);
                a.hideGame = true;
                a.immediate = false;
                break;
            case f.DISPLAY_ON_IDLE_CONTINUE:
                c = b.getContinueButtonConfig(d);
                a.immediate = false;
                break;
            default:
                throw new Error("Technical Error")
        }
        if (Sys.isDefined(c)) {
            a.buttons.push(c)
        }
        return a
    },
    prepareDialogConfig: function (a) {
        a.text = this.scrubMessageString(a.text);
        return a
    },
    scrubMessageString: function (c) {
        var a = (c.match(/(<|>)/g) || []).length > 0, b = document.createElement("div");
        if (a) {
            throw new Error("Technical Error")
        }
        try {
            b.innerHTML = c
        } catch (d) {
            throw new Error("Technical Error")
        }
        return c
    },
    showTechnicalError: function () {
        var a = this;
        a.model.storeData("showingError", true);
        if (a.model.readData("showingLoader")) {
            a.fireEvent("request:loaderErrorHandler.showTechnicalError")
        } else {
            a.fireEvent("request:errorManager.handleError")
        }
    },
    revertSpin: function () {
        this.fireEvent("request:moneyManager.revertBet");
        this.fireEvent("request:spin.cancelSpin")
    }
};
Core.CustomMessagesController = Sys.extend(Core.Controller, Core.CustomMessagesController, "Core.CustomMessagesController");
Sys.ns("Core");
Core.CustomMessagesModel = {
    constructor: function () {
        Core.CustomMessagesModel.superclass.constructor.apply(this, arguments)
    }, setupData: function () {
        var a = this;
        a.roundEndQueue = [];
        a.immediateQueue = [];
        a.dialogsToWaitFor = [];
        a.storeData("isIdle", false)
    }, addDialogToWaitFor: function (a) {
        this.dialogsToWaitFor.push(a)
    }, removeDialogToWaitFor: function (b) {
        var a = this.dialogsToWaitFor.indexOf(b);
        if (a !== -1) {
            this.dialogsToWaitFor.splice(a, 1)
        }
    }, hasDialogsToWaitFor: function () {
        return this.dialogsToWaitFor.length > 0
    }, addDialog: function (a) {
        if (a.immediate) {
            this.immediateQueue.push(a)
        } else {
            this.roundEndQueue.push(a)
        }
    }, removeDialog: function (b) {
        var a = this;
        a.spliceDialogFromQueue(a.roundEndQueue, b);
        a.spliceDialogFromQueue(a.immediateQueue, b)
    }, spliceDialogFromQueue: function (b, d) {
        var a = b.length, c;
        for (c = 0; c < a; c++) {
            if (b[c].id === d) {
                return b.splice(c, 1)
            }
        }
        return undefined
    }, popAllImmediate: function () {
        return this.immediateQueue.splice(0, this.immediateQueue.length)
    }, popAllRoundEnd: function () {
        return this.roundEndQueue.splice(0, this.roundEndQueue.length)
    }, popAll: function () {
        return this.popAllImmediate().concat(this.popAllRoundEnd())
    }, hasImmediate: function () {
        return this.immediateQueue.length > 0
    }, hasDialogs: function () {
        return (this.immediateQueue.length > 0 || this.roundEndQueue.length > 0)
    }, getCloseButtonConfig: function (a) {
        return {
            scope: a, text: Services.languageManager.getText(Language.Keys.btn_casino), action: function () {
                Environment.goToLobby()
            }
        }
    }, getContinueButtonConfig: function (b, a) {
        return {
            scope: b, text: Services.languageManager.getText(Language.Keys.btn_continue), action: function () {
                if (a) {
                    b.revertSpin()
                }
            }
        }
    }
};
Core.CustomMessagesModel = Sys.extend(Core.Model, Core.CustomMessagesModel, "Core.CustomMessagesModel");
Sys.ns("Core");
Core.CustomMessagesDesktopModel = {
    constructor: function () {
        Core.CustomMessagesDesktopModel.superclass.constructor.apply(this, arguments)
    }, getCloseButtonConfig: function () {
    }
};
Core.CustomMessagesDesktopModel = Sys.extend(Core.CustomMessagesModel, Core.CustomMessagesDesktopModel, "Core.CustomMessagesDesktopModel");
Sys.ns("Core");
Core.ServerManager = {
    constructor: function () {
        Core.ServerManager.superclass.constructor.apply(this, arguments)
    }, getDefaultMVCClasses: function () {
        return {model: Core.ServerManagerModel, controller: Core.ServerManagerController}
    }
};
Core.ServerManager = Sys.extend(Core.Module, Core.ServerManager, "Core.ServerManager");
Sys.ns("Core");
Core.ServerManagerController = {
    constructor: function () {
        Core.ServerManagerController.superclass.constructor.apply(this, arguments)
    }, setupEvents: function () {
        var a = this;
        a.on({
            "request:serverManager.sendAction": a.sendAction,
            "request:serverManager.storeParameter": a.storeParameter,
            "notify:moduleLoader.finishedLoadingModules": a.initResponse
        })
    }, initResponse: function () {
        this.fireEvent("notify:serverManager.serverResponseReceived", {responseText: Resources.readData("unParsedGameServerInitResponse")})
    }, sendAction: function (f, b, g) {
        var e = this, d = e.model.getRequestURL(f), c, a;
        c = Sys.utils.httpGet({url: d});
        e.fireEvent("notify:serverManager.actionRequestSent", f);
        a = setTimeout(function () {
            e.fireEvent("notify:serverManager.slowRequest", c)
        }, e.model.readData("slowServerRequestTimeLimit"));
        c.done(function (h) {
            e.fireEvent("notify:serverManager.serverResponseReceived", h, b)
        }).fail(function (h) {
            e.fireEvent("notify:serverManager.serverErrorReceived", h);
            e.fireEvent("request:errorManager.handleRequestError", h);
            e.fireEvent("notify:serverManager.actionRequestError", f);
            if (Sys.isDefined(g)) {
                e.fireEvent(g, h)
            }
        }).always(function () {
            clearTimeout(a)
        })
    }, storeParameter: function (a, b) {
        this.model.storeData("parameter:" + a, b)
    }
};
Core.ServerManagerController = Sys.extend(Core.Controller, Core.ServerManagerController, "Core.ServerManagerController");
Sys.ns("Core");
Core.ServerManagerModel = {
    constructor: function () {
        Core.ServerManagerModel.superclass.constructor.apply(this, arguments)
    }, setupData: function () {
        var b = this, a = Resources.readData("queryData");
        b.storeData("queryData", a);
        b.storeData("serverURL", a.server);
        b.storeData("parameter:sessionID", Resources.readData("sessionID"));
        b.storeData("parameter:gameID", a.gameId);
        b.storeData("slowServerRequestTimeLimit", 5000)
    }, getRequestURL: function (b) {
        // var a = this.readData("serverURL") + "servlet/CasinoGameServlet;jsession=" + this.readData("parameter:sessionID") + "?" + this.getActionParameters(b) + "&no-cache=" + Sys.utils.pseudoGUID();
        var a = this.readData("serverURL") + "?" + this.getActionParameters(b) + "&no-cache=" + Sys.utils.pseudoGUID();
        a = this.doIntegrationSpecificRequestUrlUpdates(a);
        return a
    }, doIntegrationSpecificRequestUrlUpdates: function (a) {
        return a
    }, getActionParameters: function (a) {
        if (a === "init") {
            return this.getInitParameters(a)
        }
        return ""
    }, getInitParameters: function (a) {
        return "action=" + a + "&sessid=" + this.readData("parameter:sessionID") + "&gameId=" + this.readData("parameter:gameID")
    }
};
Core.ServerManagerModel = Sys.extend(Core.Model, Core.ServerManagerModel, "Core.ServerManagerModel");
Sys.ns("Core");
Core.MoneyManager = {
    constructor: function () {
        Core.MoneyManager.superclass.constructor.apply(this, arguments)
    }, getMixinDependencies: function () {
        return ["serverResponse"]
    }, getDefaultMVCClasses: function () {
        return {model: Core.MoneyManagerModel, controller: Core.MoneyManagerController}
    }
};
Core.MoneyManager = Sys.extend(Core.Module, Core.MoneyManager, "Core.MoneyManager");
Sys.ns("Core");
Core.MoneyManagerController = {
    constructor: function () {
        Core.MoneyManagerController.superclass.constructor.apply(this, arguments)
    }, formatMoney: function (a, c, b) {
        return this.model.formatMoney(a, c, b)
    }, formatMoneyCurrencySign: function (a, c, b) {
        return this.model.formatMoneyCurrencySign(a, c, b)
    }, getBalanceCents: function () {
        return this.model.getBalanceCents()
    }, getBalanceCoins: function () {
        return this.model.getBalanceCoins()
    }, getBetCents: function () {
        return this.model.getBetCents()
    }, getBetCoins: function () {
        return this.model.getBetCoins()
    }, canPlaceAnotherBet: function () {
        return (this.getBetCents() <= this.getBalanceCents() || this.model.readData("inFreeRounds"))
    }, setupEvents: function () {
        var a = this;
        a.on({
            "notify:stateHandler.leavingBeforeLoaderCloseState": a.onBeforeLoaderClose,
            "notify:responseParser.responseParsed": a.onServerResponse,
            "notify:settingsManager.settingChanged": a.onSettingChanged,
            "request:moneyManager.revertBet": a.revertBet,
            "notify:freeRounds.reInitResponseReceived": a.onFreeRoundsReInit,
            "notify:freeRounds.ended": a.onFreeRoundsEnded
        })
    }, onBeforeLoaderClose: function () {
        this.notifyBalanceChange()
    }, onSettingChanged: function (b, d) {
        var c = this, a = c.model;
        if (b === "betLevel") {
            if (a.setBetLevel(d)) {
                c.notifyBetChange()
            }
        } else {
            if (b === "denomination") {
                if (a.setDenomination(d)) {
                    c.notifyBetChange()
                }
            }
        }
    }, placeBet: function () {
        var a = this;
        if (!a.model.readData("inFreeRounds")) {
            a.setBalance(a.getBalanceCents() - a.getBetCents())
        }
    }, revertBet: function () {
        var a = this;
        a.setBalance(a.getBalanceCents() + a.getBetCents());
        a.reloadBalance()
    }, setBalance: function (a) {
        var c = this, b = this.model;
        if (b.setBalance(a)) {
            c.notifyBetChange();
            c.notifyBalanceChange()
        }
    }, reloadBalance: function () {
        var b = this, a = new Sys.Deferred();
        b.addListener("notify:responseParser.reloadBalanceParsed", function (c) {
            b.setBalance(parseInt(c.credit, 10));
            a.resolve(c);
            b.removeListener("notify:responseParser.reloadBalanceParsed");
            b.removeListener("notify:serverManager.reloadBalanceRequestFailed");
            b.fireEvent("notify:moneyManager.balanceReloaded")
        });
        b.addListener("notify:serverManager.reloadBalanceRequestFailed", function (c) {
            a.reject(c);
            b.removeListener("notify:responseParser.reloadBalanceParsed");
            b.removeListener("notify:serverManager.reloadBalanceRequestFailed")
        });
        b.fireEvent("request:serverManager.sendAction", "reloadbalance", "notify:responseParser.reloadBalanceParsed", "notify:serverManager.reloadBalanceRequestFailed");
        return a
    }, notifyBalanceChange: function () {
        var b = this, a = this.model;
        b.fireEvent("notify:moneyManager.balanceChanged", {
            denomination: a.readData("denomination"),
            playerBetCents: a.readData("playerBetCents"),
            playerBalanceCoins: a.readData("playerBalanceCoins"),
            playerBalanceCents: a.readData("playerBalanceCents"),
            playerBalanceFormatted: b.formatMoneyCurrencySign(a.readData("playerBalanceCents"))
        })
    }, notifyBetChange: function () {
        var b = this, a = this.model;
        b.fireEvent("notify:moneyManager.betChanged", {
            playerBetCoins: a.readData("playerBetCoins"),
            playerBetCents: a.readData("playerBetCents"),
            playerBetFormatted: b.formatMoneyCurrencySign(a.readData("playerBetCents"))
        })
    }, getMinimumBetCents: function () {
        return this.model.getMinimumBetInCents()
    }, getCurrencyIsoName: function (a) {
        return this.model.getMoneyFormat(a).iso
    }, onFreeRoundsReInit: function () {
        this.model.setupData()
    }, onFreeRoundsEnded: function () {
        this.model.storeData("inFreeRounds", false)
    }
};
Core.MoneyManagerController = Sys.extend(Core.Controller, Core.MoneyManagerController, "Core.MoneyManagerController");
Sys.ns("Core");
Core.MoneyManagerModel = {
    constructor: function () {
        Core.MoneyManagerModel.superclass.constructor.apply(this, arguments)
    }, formatMoney: function (g, j, d) {
        var a = this.getMoneyFormat(j), h = "", f, b, k, c, e;
        e = Sys.isDefined(d) ? d : 2;
        f = (Math.floor(g) / 100).toFixed(e).split(".");
        b = f[0];
        for (c = 0; c < b.length; c++) {
            if (c > 0 && c % 3 === 0) {
                h = a.thousandsDivider + h
            }
            h = b[b.length - c - 1] + h
        }
        k = f[1];
        if (k) {
            h += a.decimalDivider + k
        }
        return h
    }, formatMoneyCurrencySign: function (a, f, b) {
        var c = this.getMoneyFormat(f), e, d;
        d = this.formatMoney(a, f, b);
        e = c.currencyChar;
        if (c.isCurrCharAfter) {
            return d + (e.length > 1 ? " " : "") + e
        }
        return e + (e.length > 1 ? " " : "") + d
    }, getCurrency: function (a) {
        return this.getMoneyFormat(a).currencyChar
    }, processServerResponse: function (a) {
        if (Sys.isDefined(a.credit)) {
            this.setBalance(a.credit)
        }
    }, setBalance: function (b) {
        var a = parseInt(b, 10);
        if (!isNaN(a) && a >= 0) {
            this.storeData("playerBalanceCents", a);
            this.storeData("playerBalanceCoins", Math.floor(a / this.readData("denomination")));
            return true
        }
        return false
    }, setBetLevel: function (c) {
        var b = this, a;
        if (c > 0 && Math.floor(c) === c) {
            b.storeData("betLevel", c);
            a = c * b.readData("betlineCoins");
            b.storeData("playerBetCoins", a);
            b.storeData("playerBetCents", a * b.readData("denomination"));
            return true
        }
        return false
    }, setDenomination: function (b) {
        var a = this;
        if (b > 0) {
            a.storeData("denomination", b);
            a.storeData("playerBetCents", a.readData("playerBetCoins") * b);
            a.storeData("playerBalanceCoins", Math.floor(a.readData("playerBalanceCents") / b));
            return true
        }
        return false
    }, getBalanceCents: function () {
        return this.readData("playerBalanceCents")
    }, getBalanceCoins: function () {
        return this.readData("playerBalanceCoins")
    }, getBetCents: function () {
        return this.readData("playerBetCents")
    }, getBetCoins: function () {
        return this.readData("playerBetCoins")
    }, setupData: function () {
        var b = this, a = Resources.readData("gameServerInitResponse");
        b.setupMoneyHandling();
        b.setBalance(Number(a.credit));
        b.storeData("betlineCoins", b.getBetlineCoinValue(a));
        b.storeData("inFreeRounds", parseInt(a.freeRoundsLeft, 10) > 0);
        b.calculateMinimumBetInCents()
    }, getBetlineCoinValue: function (d) {
        var b = d["bl.standard"].split(","), e = b.length, a = 0, c;
        for (c = -1; ++c < e;) {
            a += Sys.utils.toInt(d["bl.i" + c + ".coins"])
        }
        return a
    }, calculateMinimumBetInCents: function () {
        var c = this, b = Resources.readData("gameServerInitResponseObject"), d = b.betlevel.all,
            h = b.denomination.all, g = c.validateArray(d), f = c.validateArray(h), a = c.readData("betlineCoins"),
            e = g[0] * a * f[0];
        c.setMinimumBetInCents(e)
    }, validateArray: function (a) {
        if (!Sys.isArray(a)) {
            return [a]
        }
        return a.slice(0).sort(function (d, c) {
            return d - c
        })
    }, setMinimumBetInCents: function (a) {
        this.storeData("minimumBetInCents", a)
    }, getMinimumBetInCents: function () {
        return this.readData("minimumBetInCents")
    }, setupMoneyHandling: function () {
        var b = this, a = Resources.readData("gameServerInitResponse");
        b.language = a.language;
        b.availableFormats = ["player", "jackpot"];
        b.moneyFormats = {
            player: Sys.utils.XMLHelper.getMoneyFormatFromXML(Resources.readData("moneyformat_player"), a.playercurrencyiso),
            jackpot: Sys.utils.XMLHelper.getMoneyFormatFromXML(Resources.readData("moneyformat_jackpot"), a.jackpotcurrencyiso)
        };
        if (!Sys.isDefined(b.moneyFormats.player)) {
            throw new Error("The player currency format is missing!")
        }
        if (!Sys.isDefined(b.moneyFormats.jackpot)) {
            throw new Error("The jackpot currency format is missing!")
        }
    }, getMoneyFormat: function (a) {
        var b = a;
        if (!this.availableFormats.contains(b)) {
            b = "player"
        }
        return this.moneyFormats[b]
    }
};
Core.MoneyManagerModel = Sys.extend(Core.Model, Core.MoneyManagerModel, "Core.MoneyManagerModel");
Sys.ns("Core");
Core.SettingsManager = {
    constructor: function () {
        Core.SettingsManager.superclass.constructor.apply(this, arguments)
    }, getMixinDependencies: function () {
        return ["trigger"]
    }, getDefaultMVCClasses: function () {
        return {model: Core.SettingsManagerModel, controller: Core.SettingsManagerController}
    }
};
Core.SettingsManager = Sys.extend(Core.Module, Core.SettingsManager, "Core.SettingsManager");
Sys.ns("Core");
Core.SettingsManagerController = {
    constructor: function () {
        Core.SettingsManagerController.superclass.constructor.apply(this, arguments)
    }, setupEvents: function () {
        var a = this;
        a.on({
            "request:settingsManager.storeData": a.storeSetting,
            "request:settingsManager.lockSetting": a.lockSetting,
            "request:settingsManager.unlockSetting": a.unlockSetting,
            "request:settingsManager.disableSetting": a.disableSetting,
            "request:settingsManager.enableSetting": a.enableSetting
        })
    }, registerTriggers: function () {
        Services.trigger.registerTrigger("notify:settingsManager.settingChanged", this, "When the settings are changed")
    }, isSettable: function (a) {
        var b = this;
        return !b.model.isLocked(a) && !b.model.isDisabled(a)
    }, storeSetting: function (c, e, f, a) {
        var d = this, b;
        if (!d.model.isLocked(c) && !d.model.isDisabled(c)) {
            b = d.model.readData("settings");
            if (b[c] !== e) {
                b[c] = e;
                d.model.storeData("settings", b);
                if (f) {
                    Services.localStorageManager.storeData(c, Sys.isString(e) ? e : JSON.stringify(e))
                }
                if (!a) {
                    d.fireEvent("notify:settingsManager.settingChanged", c, e)
                }
            }
        }
    }, getSetting: function (a) {
        return this.model.readData("settings")[a]
    }, lockSetting: function (b, a) {
        var c = this.model.readData("lockedSettings");
        if (!Sys.isArray(c[b])) {
            c[b] = []
        }
        if (!c[b].contains(a)) {
            c[b].push(a);
            this.model.storeData("lockedSettings", c);
            if (c[b].length === 1) {
                this.fireEvent("notify:settingsManager.settingLocked", b)
            }
        }
    }, unlockSetting: function (b, a) {
        var c = this.model.readData("lockedSettings");
        if (Sys.isArray(c[b]) && c[b].contains(a)) {
            c[b].splice(c[b].indexOf(a), 1);
            this.model.storeData("lockedSettings", c);
            if (c[b].length === 0) {
                this.fireEvent("notify:settingsManager.settingUnlocked", b)
            }
        }
    }, disableSetting: function (a) {
        var b = this;
        b.model.readData("disabledSettings")[a] = true;
        b.fireEvent("notify:settingsManager.settingDisabled", a)
    }, enableSetting: function (a) {
        var b = this;
        b.model.readData("disabledSettings")[a] = false;
        b.fireEvent("notify:settingsManager.settingEnabled", a)
    }
};
Core.SettingsManagerController = Sys.extend(Core.Controller, Core.SettingsManagerController, "Core.SettingsManagerController");
Sys.ns("Core");
Core.SettingsManagerModel = {
    constructor: function () {
        Core.SettingsManagerModel.superclass.constructor.apply(this, arguments)
    }, setupData: function () {
        this.data = {settings: {}, lockedSettings: {}, disabledSettings: {}}
    }, isLocked: function (b) {
        var a = this.readData("lockedSettings")[b];
        return Sys.isArray(a) && a.length > 0
    }, isDisabled: function (a) {
        return this.readData("disabledSettings")[a]
    }
};
Core.SettingsManagerModel = Sys.extend(Core.Model, Core.SettingsManagerModel, "Core.SettingsManagerModel");
Sys.ns("Core");
Core.StopGame = {
    constructor: function () {
        Core.StopGame.superclass.constructor.apply(this, arguments)
    }, getMixinDependencies: function () {
        return ["animation"]
    }, getDefaultMVCClasses: function () {
        return {controller: Core.StopGameController, view: Core.StopGameView}
    }
};
Core.StopGame = Sys.extend(Core.Module, Core.StopGame, "Core.StopGame");
Sys.ns("Core");
Core.StopGameController = {
    constructor: function () {
        Core.StopGameController.superclass.constructor.apply(this, arguments)
    }, setupEvents: function () {
        var a = this;
        a.on({"request:stopGame.disable": a.disable, "request:stopGame.pause": a.pause})
    }, disable: function () {
        this.pause();
        this.view.displayOverlay()
    }, disableAnimations: function () {
        this.fireEvent("request:stage.pauseAnimation")
    }, disableAudio: function () {
        this.fireEvent("request:audioPlayer.stopAll");
        Services.settingsManager.storeSetting("volume", 0)
    }, disableInterface: function () {
        var a = this;
        a.fireEvent("request:disableBasicGamePanel", a.MODULE_NAME);
        a.fireEvent("request:userInputManager.activateExclusivity", a.MODULE_NAME)
    }, pause: function () {
        this.disableInterface();
        this.disableAnimations();
        this.disableAudio()
    }
};
Core.StopGameController = Sys.extend(Core.Controller, Core.StopGameController, "Core.StopGameController");
Sys.ns("Core");
Core.StopGameView = {
    constructor: function () {
        Core.StopGameView.superclass.constructor.apply(this, arguments)
    }, displayOverlay: function () {
        this.overlay.el.style.display = "block"
    }, initAnimations: function () {
        this.overlay = new Sys.Element({
            tag: "div",
            id: "stopGameOverlay",
            cls: "stopGameOverlay",
            style: "display:none",
            renderTo: "gameWrapper"
        })
    }
};
Core.StopGameView = Sys.extend(Core.View, Core.StopGameView, "Core.StopGameView");
Sys.ns("Core");
Core.RealityCheck = {
    CONTROL_STATE: "idle", constructor: function () {
        Core.RealityCheck.superclass.constructor.apply(this, arguments)
    }, getMixinDependencies: function () {
        return ["serverResponse"]
    }, getStateChanges: function () {
        var a = this.model, b = {
            realityCheck: {
                state: {
                    name: "RealityCheck", execute: function (c) {
                    }, waitEvents: {"notify:realityCheck:completed": false}
                }
            }
        };
        b[this.CONTROL_STATE] = {
            queue: [function (c) {
                if (a.isTimeToDoRealityCheck()) {
                    c.stateHandler.pushState(c.states.realityCheck)
                }
            }]
        };
        return b
    }, getDefaultMVCClasses: function () {
        return {model: Core.RealityCheckModel, view: Core.View, controller: Core.RealityCheckController}
    }
};
Core.RealityCheck = Sys.extend(Core.Module, Core.RealityCheck, "Core.RealityCheck");
Sys.ns("Core");
Core.RealityCheckController = {
    constructor: function () {
        Core.RealityCheckController.superclass.constructor.apply(this, arguments)
    }, setupEvents: function () {
        this.on({
            "notify:stateHandler.enteringRealityCheckState": this.doRealityCheck,
            "notify:responseParser.rcInfoParsed": this.handleInfoResponse,
            "notify:responseParser.rcInfoReset": this.handleResetResponse,
            "notify:responseParser.responseParsed": this.handleGenericResponse,
            "notify:responseParser.gameConfigurationParsed": this.onFreeRoundsEnded
        })
    }, sendServerAction: function (a, b) {
        this.model.setState("requestPending");
        this.fireEvent("request:serverManager.sendAction", a, b)
    }, handleResetResponse: function (a) {
        this.model.storeData("msUntilTimeout", a.rc.msuntiltimeout);
        this.model.storeData("lastCheckTime", Date.now())
    }, handleInfoResponse: function (b) {
        var d = this, a = b.rc, c, f, e;
        if (Sys.isDefined(a) && a.msuntiltimeout <= 0) {
            e = Math.round(a.duration / 60 / 60 / 10) / 100;
            if (a.totalwin >= 0) {
                f = a.totalwin;
                c = Language.Keys.rc_checkPlayingWon
            } else {
                f = Sys.utils.toInt(-a.totalwin);
                c = Language.Keys.rc_checkPlayingLost
            }
            d.requestDialog(Services.languageManager.getText(c, [e, Services.moneyManager.formatMoneyCurrencySign(f)]));
            d.model.setState("dialogOpen")
        } else {
            d.handleResetResponse(b);
            d.complete()
        }
    }, requestDialog: function (a) {
        this.fireEvent("request:dialogWindow.showDialog", this.model.getDialog(a, this))
    }, complete: function () {
        this.fireEvent("notify:realityCheck:completed")
    }, doRealityCheck: function () {
        this.sendServerAction("rcinfo", "notify:responseParser.rcInfoParsed")
    }, onFreeRoundsEnded: function () {
        this.model.processInitData(Resources.readData("gameServerInitResponse"))
    }
};
Core.RealityCheckController = Sys.extend(Core.Controller, Core.RealityCheckController, "Core.RealityCheckController");
Sys.ns("Core");
Core.RealityCheckModel = {
    constructor: function () {
        Core.RealityCheckModel.superclass.constructor.apply(this, arguments)
    }, getDialog: function (b, a) {
        return {
            title: Services.languageManager.getText(Language.Keys.rc_checkReminder),
            text: b,
            buttons: [{
                scope: a, text: Services.languageManager.getText(Language.Keys.btn_casino), action: function () {
                    Environment.goToLobby("0")
                }
            }, {
                scope: a, text: Services.languageManager.getText(Language.Keys.btn_continue), action: function () {
                    a.sendServerAction("rcreset", "notify:responseParser.rcInfoReset");
                    a.complete()
                }
            }]
        }
    }, setupData: function () {
        this.processInitData(Resources.readData("gameServerInitResponse"))
    }, processInitData: function (a) {
        var b = Sys.utils.strIsTrue(a["rc.enabled"]);
        if (Sys.utils.toInt(a.freeRoundsLeft) > 0) {
            b = false
        }
        this.storeData("rcEnabled", b);
        if (b) {
            if (Sys.isDefined(a["rc.msuntiltimeout"])) {
                this.storeData("msUntilTimeout", Sys.utils.toInt(a["rc.msuntiltimeout"]));
                this.storeData("lastCheckTime", Date.now())
            } else {
                this.storeData("rcEnabled", false)
            }
        }
    }, processServerResponse: function (a) {
        this.storeData("nextAction", a.nextaction)
    }, isTimeToDoRealityCheck: function () {
        var a;
        if (this.readData("rcEnabled")) {
            a = this.readData("lastCheckTime") + this.readData("msUntilTimeout") <= Date.now();
            if (this.readData("nextAction") === "spin" && a) {
                return true
            }
        }
        return false
    }
};
Core.RealityCheckModel = Sys.extend(Core.Model, Core.RealityCheckModel, "Core.RealityCheckModel");
Sys.ns("Core");
Core.RealityCheckDesktopModel = {
    constructor: function () {
        Core.RealityCheckDesktopModel.superclass.constructor.apply(this, arguments)
    }, getDialog: function (b, a) {
        return {
            title: Services.languageManager.getText(Language.Keys.rc_checkReminder),
            text: b,
            buttons: [{
                scope: a,
                text: Services.languageManager.getText(Language.Keys.btn_checkEnd),
                action: function () {
                    a.fireEvent("request:stopGame.disable")
                }
            }, {
                scope: a, text: Services.languageManager.getText(Language.Keys.btn_continue), action: function () {
                    a.sendServerAction("rcreset", "notify:responseParser.rcInfoReset");
                    a.complete()
                }
            }]
        }
    }
};
Core.RealityCheckDesktopModel = Sys.extend(Core.RealityCheckModel, Core.RealityCheckDesktopModel, "Core.RealityCheckDesktopModel");
Sys.ns("Core.Slots");
Core.Slots.RealityCheck = {
    CONTROL_STATE: "stopped", constructor: function () {
        Core.Slots.RealityCheck.superclass.constructor.apply(this, arguments)
    }
};
Core.Slots.RealityCheck = Sys.extend(Core.RealityCheck, Core.Slots.RealityCheck, "Core.Slots.RealityCheck");
Sys.ns("Core");
Core.KeepAlive = {
    constructor: function () {
        Core.KeepAlive.superclass.constructor.apply(this, arguments)
    }, getDefaultMVCClasses: function () {
        return {model: Core.KeepAliveModel, view: Core.View, controller: Core.KeepAliveController}
    }
};
Core.KeepAlive = Sys.extend(Core.Module, Core.KeepAlive, "Core.KeepAlive");
Sys.ns("Core");
Core.KeepAliveController = {
    constructor: function () {
        Core.KeepAliveController.superclass.constructor.apply(this, arguments)
    }, init: function () {
        var a = this;
        Core.KeepAliveController.superclass.init.apply(a, arguments);
        if (a.model.readData("url")) {
            a.keepAlive()
        }
    }, keepAlive: function () {
        var c = this, a = c.model.readData("interval"),
            b = Sys.utils.httpGet({url: c.model.readData("url"), handleError: false, showTimeoutDialog: false});
        b.always(function () {
            setTimeout(function () {
                c.keepAlive()
            }, a)
        })
    }
};
Core.KeepAliveController = Sys.extend(Core.Controller, Core.KeepAliveController, "Core.KeepAliveController");
Sys.ns("Core");
Core.KeepAliveModel = {
    constructor: function () {
        Core.KeepAliveModel.superclass.constructor.apply(this, arguments)
    }, setupData: function () {
        var d = this, b = Resources.readData("queryData"), c = b.keepAliveURL, e = Resources.readData("sessionID"),
            a = b.keepAliveInterval;
        if (Sys.isDefined(c) && Sys.isDefined(a) && Sys.isDefined(e) && Sys.utils.isUrl(c) && Sys.utils.toInt(a) >= 5) {
            d.storeData("url", Sys.utils.appendParameterToQuery(c, "sessId=" + e));
            d.storeData("interval", a * 1000)
        }
    }
};
Core.KeepAliveModel = Sys.extend(Core.Model, Core.KeepAliveModel, "Core.KeepAliveModel");
Sys.ns("Core");
Core.PlayForRealPromo = {
    constructor: function () {
        Core.PlayForRealPromo.superclass.constructor.apply(this, arguments)
    }, getStateChanges: function () {
        return {idle: {waitEvents: ["notify:playForRealPromo:completed"]}}
    }, getDefaultMVCClasses: function () {
        return {model: Core.PlayForRealPromoModel, view: Core.View, controller: Core.PlayForRealPromoController}
    }
};
Core.PlayForRealPromo = Sys.extend(Core.Module, Core.PlayForRealPromo, "Core.PlayForRealPromo");
Sys.ns("Core");
Core.PlayForRealPromoController = {
    constructor: function () {
        Core.PlayForRealPromoController.superclass.constructor.apply(this, arguments)
    }, setupEvents: function () {
        var a = this;
        a.on({
            "notify:stateHandler.enteringIdleState": a.onEnteringIdleState,
            "request:playForRealPromo:enable": a.onEnable,
            "request:playForRealPromo:disable": a.onDisable
        })
    }, onEnteringIdleState: function () {
        var b = this, a = b.model.readData("roundsLeft");
        if (a === 0 && !b.isDisabled) {
            b.requestDialog()
        } else {
            b.complete()
        }
        if (Sys.isDefined(a)) {
            b.model.handleRounds()
        }
    }, requestDialog: function () {
        this.fireEvent("request:dialogWindow.showDialog", this.model.getDialog(this))
    }, complete: function () {
        this.fireEvent("notify:playForRealPromo:completed")
    }, onEnable: function () {
        this.isDisabled = false
    }, onDisable: function () {
        this.isDisabled = true
    }
};
Core.PlayForRealPromoController = Sys.extend(Core.Controller, Core.PlayForRealPromoController, "Core.PlayForRealPromoController");
Sys.ns("Core");
Core.PlayForRealPromoModel = {
    constructor: function () {
        Core.PlayForRealPromoModel.superclass.constructor.apply(this, arguments)
    }, getDialog: function (a) {
        return {
            title: Services.languageManager.getText(Language.Keys.youPlayingForFun),
            buttons: [{
                text: Services.languageManager.getText(Language.Keys.btn_login), scope: a, action: function () {
                    Environment.goToLobby("4")
                }
            }, {
                text: Services.languageManager.getText(Language.Keys.btn_continue), scope: a, action: function () {
                    a.complete()
                }
            }]
        }
    }, setupData: function () {
        var c = this, b = Resources.readData("gameServerInitResponse"), a;
        if (b.playforfun && Sys.isDefined(b["playforrealpromo.rounds"])) {
            a = Sys.utils.toInt(b["playforrealpromo.rounds"]);
            c.storeData("roundsLeft", a);
            c.storeData("rounds", a)
        }
    }, handleRounds: function () {
        var a = this.readData("roundsLeft"), b;
        if (a === 0) {
            b = this.readData("rounds")
        } else {
            b = --a
        }
        this.storeData("roundsLeft", b)
    }
};
Core.PlayForRealPromoModel = Sys.extend(Core.Model, Core.PlayForRealPromoModel, "Core.PlayForRealPromoModel");
Sys.ns("Core");
Core.PlayForRealPromoDesktopModel = {
    constructor: function () {
        Core.PlayForRealPromoDesktopModel.superclass.constructor.apply(this, arguments)
    }, getDialog: function (a) {
        return {
            title: Services.languageManager.getText(Language.Keys.youPlayingForFun),
            buttons: [{
                text: Services.languageManager.getText(Language.Keys.btn_continue),
                scope: a,
                action: function () {
                    a.complete()
                }
            }]
        }
    }
};
Core.PlayForRealPromoDesktopModel = Sys.extend(Core.PlayForRealPromoModel, Core.PlayForRealPromoDesktopModel, "Core.PlayForRealPromoDesktopModel");
Sys.ns("Core");
Core.CountUp = {
    constructor: function () {
        Core.CountUp.superclass.constructor.apply(this, arguments)
    }, getMixinDependencies: function () {
        return ["animation"]
    }, getDefaultMVCClasses: function () {
        return {model: Core.CountUpModel, view: Core.CountUpView, controller: Core.CountUpController}
    }
};
Core.CountUp = Sys.extend(Core.Module, Core.CountUp, "Core.CountUp");
Sys.ns("Core");
Core.CountUpModel = {
    constructor: function () {
        Core.CountUpModel.superclass.constructor.apply(this, arguments);
        this.setState("stopped")
    }, setupData: function () {
        this.defineEasingMethods()
    }, defineEasingMethods: function () {
        var a = {"ease-in": 0, "ease-out": 1, linear: 0.5};
        this.storeData("easingMethods", a)
    }
};
Core.CountUpModel = Sys.extend(Core.Model, Core.CountUpModel, "Core.CountUpModel");
Sys.ns("Core");
Core.CountUpView = {
    NUMBER_IMAGE: undefined,
    NUMBER_WIDTH: 80,
    NUMBER_HEIGHT: 100,
    NUMBER_FONT: "bold 100px Verdana",
    NUMBER_OFFSET: 0,
    NUMBER_TEXT_OPERATIONS: [{fillStyle: "#FFFFFF"}, {lineWidth: 5, strokeStyle: "#00000", drawType: "stroke"}],
    COUNT_UP_LEFT: undefined,
    COUNT_UP_TOP: 250,
    COUNT_UP_DEPTH: 100,
    COUNT_UP_EASING_TYPE: "ease-out",
    SHOW_TOTAL_DURATION: 3000,
    constructor: function () {
        var a = {COUNT_UP_LEFT: this.COUNT_UP_LEFT, COUNT_UP_TOP: this.COUNT_UP_TOP};
        Core.CountUpView.superclass.constructor.apply(this, arguments);
        this.CONFIG = this.CONFIG || {};
        this.CONFIG.DEFAULT = this.CONFIG.DEFAULT || {};
        Sys.applyProperties(this.CONFIG.DEFAULT, a)
    },
    configureStartAnimation: function (a) {
    },
    configureEndAnimation: function () {
    },
    createItems: function () {
        var a = this;
        a.countUpItem = a.createCountUpItem();
        a.list.add(a.countUpItem)
    },
    initAnimations: function () {
        this.scaleFactor = this.getScaleFactor();
        this.createList();
        this.createItems();
        Game.stage.view.addToRenderLoop(this.list);
        this.list.stop()
    },
    getScaleFactor: function () {
        return Resources.readData("config").mobileResourceToVirtualScale || 1
    },
    refresh: function () {
        var b = this.scaleFactor, a = Environment.getOrientationSpecificConfig(this.CONFIG, true);
        if (Animation.utils.isAnimationItem(this.countUpItem)) {
            this.countUpItem.setLeft(Math.round(a.COUNT_UP_LEFT * b) || Environment.getStageResolution().width / 2);
            this.countUpItem.setTop(Math.round(a.COUNT_UP_TOP * b))
        }
    },
    createList: function () {
        this.list = new Animation.CanvasAnimationList({})
    },
    createCountUpItem: function () {
        var b = this, a = Environment.getOrientationSpecificConfig(this.CONFIG, true),
            c = Animation.utils.text.createNumberDrawingProperties(b);
        return new Animation.CanvasAnimationItem({
            left: Math.round(a.COUNT_UP_LEFT * b.scaleFactor) || Environment.getStageResolution().width / 2,
            top: Math.round(a.COUNT_UP_TOP * b.scaleFactor),
            width: 0,
            height: 0,
            depth: b.COUNT_UP_DEPTH,
            executeBefore: function (d) {
                var f, g, h = this.value.toString(), e;
                Animation.utils.text.drawTextFromImage(h, b.NUMBER_OFFSET, this.pivot.x, this.pivot.y, true, c.image, c.charMap, c.width, c.height, d);
                if (Sys.isDefined(this.fireOnValue)) {
                    f = this.fireOnValue.length;
                    for (e = -1; ++e < f;) {
                        g = this.fireOnValue[e];
                        if (!g.fired && this.value >= g.value) {
                            g.scope.fireEvent(g.event, g.argument);
                            g.fired = true
                        }
                    }
                }
            },
            operations: {}
        })
    },
    setCountUpValues: function (a) {
        var b = this, c = b.countUpItem.prop;
        c.fireOnValue = a.fireEventsOnValue;
        c.operations = {
            value: [{
                time: 0,
                value: a.from,
                support: b.model.readData("easingMethods")[b.COUNT_UP_EASING_TYPE] * a.to,
                numDecimals: 0
            }, {
                time: a.duration,
                value: a.to,
                fireEvent: {event: "view:countUpComplete", scope: b}
            }, {time: a.duration + 1, value: a.to}, {time: a.duration + 2, value: a.to, goTo: 2}]
        };
        b.configureStartAnimation(a.duration)
    },
    start: function (a) {
        this.list.restore();
        this.setCountUpValues(a);
        this.list.play()
    },
    stop: function () {
        this.list.stop()
    },
    pause: function () {
        this.list.pause()
    },
    resume: function () {
        this.list.play()
    },
    showTotal: function (e) {
        var c = this, b, d = [], a;
        e = e || {};
        c.list.stop();
        b = c.countUpItem.prop.operations.value[1].value;
        c.countUpItem.prop.fireOnValue.length = 0;
        c.list.restore();
        d.push({value: b, time: 0});
        if (e.showUntilStopped) {
            d.push({value: b, time: 1, goTo: 0})
        } else {
            a = Sys.isDefined(e.showDuration) ? e.showDuration : c.SHOW_TOTAL_DURATION;
            d.push({value: b, time: a, fireEvent: {event: "view:showTotalDurationPassed", scope: c}})
        }
        c.countUpItem.value(d);
        c.configureEndAnimation(a);
        c.list.play()
    }
};
Core.CountUpView = Sys.extend(Core.View, Core.CountUpView, "Core.CountUpView");
Sys.ns("Core");
Core.CountUpController = {
    constructor: function () {
        Core.CountUpController.superclass.constructor.apply(this, arguments)
    }, setupEvents: function () {
        var a = this, b = {
            "view:countUpComplete": a.onCountUpComplete,
            "view:showTotalDurationPassed": a.stop,
            "notify:scaling.gameSizeChanged": a.onGameSizeChanged
        };
        b["request:" + a.MODULE_NAME + ".start"] = a.start;
        b["request:" + a.MODULE_NAME + ".pause"] = a.pause;
        b["request:" + a.MODULE_NAME + ".resume"] = a.resume;
        b["request:" + a.MODULE_NAME + ".stop"] = a.stop;
        b["request:" + a.MODULE_NAME + ".showTotal"] = a.showTotal;
        a.on(b)
    }, start: function (a) {
        this.view.start(a);
        this.model.setState("countingUp")
    }, stop: function () {
        var a = this;
        if (!a.model.isState("stopped")) {
            a.model.setState("stopped");
            a.view.stop();
            a.fireEvent("notify:" + this.MODULE_NAME + ".hidden")
        }
    }, pause: function () {
        this.view.pause()
    }, resume: function () {
        if (!this.model.isState("stopped")) {
            this.view.resume()
        }
    }, onGameSizeChanged: function () {
        if (Sys.isFunc(this.view.refresh)) {
            this.view.refresh()
        }
    }, showTotal: function (a) {
        if (!this.model.isState("showingTotal")) {
            this.view.showTotal(a);
            this.model.setState("showingTotal")
        }
    }, onCountUpComplete: function () {
        this.fireEvent("notify:" + this.MODULE_NAME + ".countUpComplete")
    }
};
Core.CountUpController = Sys.extend(Core.Controller, Core.CountUpController, "Core.CountUpController");
Sys.ns("Game.Slots");
Game.Slots.BigWinCountUp = {
    constructor: function () {
        Game.Slots.BigWinCountUp.superclass.constructor.apply(this, arguments)
    }, getDefaultMVCClasses: function () {
        return {model: Core.CountUpModel, view: Game.Slots.BigWinCountUpView, controller: Core.CountUpController}
    }
};
Game.Slots.BigWinCountUp = Sys.extend(Core.CountUp, Game.Slots.BigWinCountUp, "Game.Slots.BigWinCountUp");
Sys.ns("Game.Slots");
Game.Slots.BigWinCountUpView = {
    constructor: function () {
        Game.Slots.BigWinCountUpView.superclass.constructor.apply(this, arguments)
    },
    IMAGE: undefined,
    CHARACTER_WIDTH: 90,
    CHARACTER_HEIGHT: 100,
    FONT: "bold 100px Verdana",
    OFFSET: 0,
    TEXT_OPERATIONS: [{fillStyle: "#FFFFFF"}, {lineWidth: 5, strokeStyle: "#00000", drawType: "stroke"}],
    LEFT: undefined,
    TOP: 188,
    DEPTH: 100,
    EASING: "ease-out",
    SHOW_TOTAL_DURATION: 1000,
    configureStartAnimation: function () {
        this.countUpItem.prop.ownOpacity = 1
    },
    configureEndAnimation: function (b) {
        var a = this;
        a.countUpItem.prop.operations.fade = [{value: 1, time: 0}, {value: 0, time: b}]
    }
};
Game.Slots.BigWinCountUpView = Sys.extend(Core.CountUpView, Game.Slots.BigWinCountUpView, "Game.Slots.BigWinCountUpView");
Sys.ns("Core");
Core.DialogWindow = {
    constructor: function () {
        Core.DialogWindow.superclass.constructor.apply(this, arguments)
    }, getDefaultMVCClasses: function () {
        return {model: Core.DialogWindowModel, view: Core.DialogWindowBaseView, controller: Core.DialogWindowController}
    }, getMixinDependencies: function () {
        return [{userInput: {inputEvents: ["start", "end", "move", "scroll"]}}, "orientation"]
    }
};
Core.DialogWindow = Sys.extend(Core.Module, Core.DialogWindow, "Core.DialogWindow");
Sys.ns("Core");
Core.DialogWindowController = {
    constructor: function () {
        Core.DialogWindowController.superclass.constructor.apply(this, arguments)
    }, setupEvents: function () {
        var a = {
            "request:dialogWindow.showDialog": this.onShowDialogRequest,
            "request:dialogWindow.removeDialog": this.onRemoveDialogRequest,
            "request:dialogWindow.closeCurrentDialog": this.onCloseDialogRequest,
            "view:dialogShown": this.onDialogShown,
            "view:showingDialog": this.onShowingDialog,
            "view:pauseGame": this.pauseGame,
            "notify:scaling.gameSizeChanged": this.onGameSizeChanged,
            "notify:viewport.scaled": this.onGameSizeChanged
        };
        a["notify:userInputManager." + this.MODULE_NAME + "ExclusiveStart"] = this.onUserInputStart;
        a["notify:userInputManager." + this.MODULE_NAME + "ExclusiveEnd"] = this.onUserInputEnd;
        a["notify:userInputManager." + this.MODULE_NAME + "ExclusiveMove"] = this.onUserInputMove;
        a["notify:userInputManager." + this.MODULE_NAME + "ExclusiveScroll"] = this.onUserInputScroll;
        this.on(a)
    }, onGameSizeChanged: function () {
        if (Sys.isFunc(this.view.refresh)) {
            this.view.refresh()
        }
    }, onShowDialogRequest: function (b) {
        var a = this.model.readData("currentDialogConfig") || {};
        if (!this.model.isState("showing")) {
            this.view.showDialog(b);
            if (Sys.isFunc(this.view.refresh)) {
                this.view.refresh()
            }
        } else {
            if (b.fatal && !a.fatal) {
                this.model.addAsFirst(b);
                this.view.closeCurrentDialog()
            } else {
                this.model.queue(b)
            }
        }
    }, onRemoveDialogRequest: function (b) {
        var a = this.model.readData("currentDialogConfig") || {};
        if (this.model.isState("showing") && a.id === b) {
            this.view.closeCurrentDialog();
            this.fireEvent("request:userInputManager.deactivateExclusivity", this.MODULE_NAME)
        } else {
            this.model.remove(b)
        }
    }, onCloseDialogRequest: function () {
        var a = this.model.readData("currentDialogConfig") || {};
        if (!a.fatal) {
            this.view.closeCurrentDialog();
            this.fireEvent("request:userInputManager.deactivateExclusivity", this.MODULE_NAME)
        }
    }, onDialogShown: function (a) {
        var b = this;
        if (b.model.hasQueuedDialog()) {
            b.view.showNextDialog()
        } else {
            b.fireEvent("request:quickSettingsMenu.externalActivate", b.MODULE_NAME);
            b.fireEvent("request:enableBasicGamePanel", b.MODULE_NAME);
            b.fireEvent("notify:dialogWindow.allDialogsClosed")
        }
        b.fireEvent("notify:dialogWindow.dialogShown", a.id)
    }, onShowingDialog: function () {
        var a = this;
        a.fireEvent("request:userInputManager.activateExclusivity", a.MODULE_NAME);
        a.fireEvent("request:quickSettingsMenu.externalDeactivate", a.MODULE_NAME);
        a.fireEvent("request:disableBasicGamePanel", a.MODULE_NAME);
        a.fireEvent("notify.dialogWindow.showingDialog")
    }, pauseGame: function () {
        this.fireEvent("request:stopGame.pause")
    }, onUserInputStart: function (c) {
        var b = this, a = b.view.getButtonFromCoordinate(c);
        b.view.handleScrolling("start", c);
        if (a) {
            b.model.storeData("activeButton", a)
        }
    }, onUserInputEnd: function (d) {
        var c = this, a = Sys.UserInputUtils.getDOMElementFromCoordinates(d), b = c.model.readData("activeButton");
        c.view.handleScrolling("end", d);
        if (Sys.isDefined(b) && Sys.UserInputUtils.isParentAndChildElements(b.element, a)) {
            if (Sys.isFunc(b.action)) {
                b.action()
            }
            c.fireEvent("request:userInputManager.deactivateExclusivity", c.MODULE_NAME)
        }
        c.model.removeData("activeButton")
    }, onUserInputMove: function (a) {
        this.view.handleScrolling("move", a)
    }, onUserInputScroll: function (b, a) {
        this.view.handleScrolling("scroll", b, a)
    }, onPortrait: function () {
        this.view.handleScrolling("orientation")
    }, onLandscape: function () {
        this.view.handleScrolling("orientation")
    }
};
Core.DialogWindowController = Sys.extend(Core.Controller, Core.DialogWindowController, "Core.DialogWindowController");
Sys.ns("Core");
Core.DialogWindowModel = {
    constructor: function () {
        Core.DialogWindowModel.superclass.constructor.apply(this, arguments)
    }, setupData: function () {
        this.requestQueue = [];
        Services.storage.storeData("dialog.showing", false)
    }, queue: function (a) {
        this.requestQueue.push(a)
    }, addAsFirst: function (a) {
        this.requestQueue.unshift(a)
    }, getNextDialogConfig: function () {
        if (this.requestQueue.length > 0) {
            return this.requestQueue.shift()
        }
        return undefined
    }, remove: function (b) {
        var a;
        for (a = 0; a < this.requestQueue.length; a++) {
            if (this.requestQueue[a].id === b) {
                this.requestQueue.splice(a, 1);
                return true
            }
        }
        return false
    }, hasQueuedDialog: function () {
        return this.requestQueue.length > 0
    }, getQueue: function () {
        return this.requestQueue
    }
};
Core.DialogWindowModel = Sys.extend(Core.Model, Core.DialogWindowModel, "Core.DialogWindowModel");
Sys.ns("Core");
Core.DialogWindowView = {
    constructor: function () {
        Core.DialogWindowView.superclass.constructor.apply(this, arguments);
        this.dialogDOMElement = new Core.DialogWindowDOMElement()
    }, button1Clicked: function () {
        var a = this.model.readData("currentDialogConfig");
        this.handleButtonClick(a.buttons[0], !a.fatal)
    }, button2Clicked: function () {
        var a = this.model.readData("currentDialogConfig");
        this.handleButtonClick(a.buttons[1], !a.fatal)
    }, handleButtonClick: function (b, a) {
        if (b && b.action) {
            b.action.call(b.scope || window)
        }
        if (a) {
            this.closeCurrentDialog()
        }
    }, hideGame: function () {
        document.getElementById("gameWrapper").classList.add("hideGame");
        this.fireEvent("view:pauseGame")
    }, showDialog: function (a) {
        var c = this, b = c.dialogDOMElement;
        b.setTitle(a.title);
        b.setMessage(a.text);
        b.setScrollable(b.text.el.textContent.length > 150);
        b.hideButtons();
        if (Sys.isArray(a.buttons)) {
            if (a.buttons.length === 2) {
                b.showDualButtons(a.buttons[0].text, a.buttons[1].text)
            } else {
                if (a.buttons.length === 1) {
                    b.showSingleButton(a.buttons[0].text)
                }
            }
        }
        c.model.storeData("currentDialogConfig", a);
        c.model.setState("showing");
        c.fireEvent("view:showingDialog");
        b.show();
        Services.storage.storeData("dialog.showing", true);
        c.dialogDOMElement.scroll.show();
        c.dialogDOMElement.scroll.scrollTo(0, 0, false);
        if (Sys.isDefined(a.hideGame) && a.hideGame) {
            c.hideGame()
        }
    }, getButtonFromCoordinate: function (h) {
        var e = this, c = Sys.UserInputUtils.getDOMElementFromCoordinates(h),
            a = e.dialogDOMElement.singleButton.getContainer().el,
            b = e.dialogDOMElement.leftDualButton.getContainer().el,
            f = e.dialogDOMElement.rightDualButton.getContainer().el, g, d;
        if (Sys.UserInputUtils.isParentAndChildElements(a, c)) {
            g = a
        }
        if (!Sys.isDefined(g) && Sys.UserInputUtils.isParentAndChildElements(b, c)) {
            g = b
        }
        if (!Sys.isDefined(g) && Sys.UserInputUtils.isParentAndChildElements(f, c)) {
            g = f
        }
        switch (g) {
            case a:
            case b:
                d = e.button1Clicked.bind(e);
                break;
            case f:
                d = e.button2Clicked.bind(e);
                break;
            default:
                return undefined
        }
        return {element: g, action: d}
    }, showNextDialog: function () {
        var a = this.model.getNextDialogConfig();
        if (a) {
            this.showDialog(a)
        }
    }, closeCurrentDialog: function () {
        this.dialogDOMElement.close();
        this.model.setState("idle");
        this.fireEvent("view:dialogShown", this.model.readData("currentDialogConfig"));
        Services.storage.storeData("dialog.showing", false)
    }, handleScrolling: function (a, d, c) {
        var b = this;
        if (b.dialogDOMElement.scroll) {
            switch (a) {
                case"start":
                    b.dialogDOMElement.scroll.onUserInputStart(d);
                    break;
                case"end":
                    b.dialogDOMElement.scroll.onUserInputEnd(d);
                    break;
                case"move":
                    b.dialogDOMElement.scroll.onUserInputMove(d);
                    break;
                case"scroll":
                    b.dialogDOMElement.scroll.onUserInputScroll(d, c);
                    break;
                case"orientation":
                    b.dialogDOMElement.scroll.show();
                    break;
                default:
            }
        }
    }
};
Core.DialogWindowView = Sys.extend(Core.View, Core.DialogWindowView, "Core.DialogWindowView");
Sys.ns("Gui");
Core.DialogWindowDOMElement = {
    constructor: function () {
        var a = this;
        a.initParentAsWrapper();
        a.initContainer();
        a.initTitle();
        a.initText();
        a.initButtonContainer();
        a.initSingleButton();
        a.initDualButtons()
    }, initParentAsWrapper: function () {
        Core.DialogWindowDOMElement.superclass.constructor.call(this, {
            tag: "div",
            id: "dialogWindowWrapper",
            cls: "dialogWindowWrapper hidden"
        });
        document.body.appendChild(this.getEl())
    }, initContainer: function () {
        this.container = new Sys.Element({tag: "div", id: "dialogWindowContainer", cls: "dialogWindowContainer"});
        this.add(this.container)
    }, initTitle: function () {
        this.title = this.container.add(new Sys.Element({
            tag: "div",
            id: "dialogWindowTitle",
            cls: "dialogWindowTitle"
        }))
    }, initText: function () {
        var a = this;
        a.text = new Sys.Element({tag: "div", id: "dialogWindowText", cls: "dialogWindowText"});
        a.scroll = new Interface.utils.DOMScrollableContent({
            content: a.text,
            id: "dialogWindowScroll",
            CSS: {base: "dialogWindowScrollWrapper"}
        });
        a.container.add(a.scroll.container);
        a.scroll.addScrollBar();
        a.scroll.enable()
    }, initButtonContainer: function () {
        this.buttonContainer = new Sys.Element({
            tag: "div",
            id: "dialogWindowButtonContainer",
            cls: "dialogWindowButtonContainer"
        });
        this.container.add(this.buttonContainer)
    }, initSingleButton: function () {
        this.singleButton = new Interface.utils.Button({
            id: "dialogWindowSingleButton",
            CSS: {base: "button dialogWindowSingleButton"},
            hidden: true
        });
        this.buttonContainer.add(this.singleButton.getContainer())
    }, initDualButtons: function () {
        var a = this;
        a.leftDualButton = new Interface.utils.Button({
            id: "dialogWindowLeftDualButton",
            CSS: {base: "button dialogWindowDualButton dialogWindowRightButton"},
            hidden: true
        });
        a.buttonContainer.add(a.leftDualButton.getContainer());
        a.rightDualButton = new Interface.utils.Button({
            id: "dialogWindowRightDualButton",
            CSS: {base: "button dialogWindowDualButton dialogWindowLeftButton"},
            hidden: true
        });
        a.buttonContainer.add(a.rightDualButton.getContainer())
    }, show: function () {
        this.removeCSSClass("hidden")
    }, close: function () {
        this.addCSSClass("hidden")
    }, setTitle: function (a) {
        this.title.el.textContent = a || ""
    }, setMessage: function (d) {
        var b = this, a, c;
        if (Sys.isDefined(d)) {
            a = b.parseHyperlink(d);
            c = new Sys.Element({tag: "p"});
            c.addChildren(a);
            b.text.removeAll();
            b.text.addChildren([c.el])
        } else {
            b.text.el.textContent = ""
        }
    }, parseHyperlink: function (d) {
        var a = /\[([^\]]+)\]\(([^)]+)\)/, c = {
            started: "notify:userInputManager.dialogWindowExclusiveStart",
            ended: "notify:userInputManager.dialogWindowExclusiveEnd",
            move: "notify:userInputManager.dialogWindowExclusiveMove",
            hover: "notify:userInputManager.dialogWindowExclusiveHover"
        }, f = 0, e, b;
        d = d || "";
        e = d.split(/(\[[^\]]+\]\([^)]+\))/);
        e.forEach(function (i, g) {
            var h;
            if (g % 2 === 1) {
                h = a.exec(i);
                b = new Interface.utils.Button({
                    id: "dialogWindow_link_" + (f++),
                    label: h[1],
                    CSS: {base: "dialogWindow_link"},
                    clickCallback: function () {
                        Sys.utils.openURL(h[2])
                    },
                    userInputEvents: c
                });
                b.enable();
                e[g] = b.getContainer().getEl()
            } else {
                e[g] = document.createTextNode(e[g])
            }
        });
        return e
    }, showSingleButton: function (b) {
        var a = this;
        a.singleButton.setText(b);
        a.singleButton.enable();
        a.singleButton.show("inline-block");
        a.leftDualButton.disable();
        a.leftDualButton.hide();
        a.rightDualButton.disable();
        a.rightDualButton.hide()
    }, showDualButtons: function (b, a) {
        var c = this;
        c.singleButton.disable();
        c.singleButton.hide();
        c.leftDualButton.setText(b);
        c.leftDualButton.enable();
        c.leftDualButton.show("inline-block");
        c.rightDualButton.setText(a);
        c.rightDualButton.enable();
        c.rightDualButton.show("inline-block")
    }, hideButtons: function () {
        var a = this;
        a.singleButton.disable();
        a.singleButton.hide();
        a.leftDualButton.disable();
        a.leftDualButton.hide();
        a.rightDualButton.disable();
        a.rightDualButton.hide()
    }, hideGame: function () {
        this.addCls("hideGame")
    }, setScrollable: function (b) {
        var a = "scrollable";
        if (b) {
            this.addCSSClass(a)
        } else {
            this.removeCSSClass(a)
        }
    }
};
Core.DialogWindowDOMElement = Sys.extend(Sys.Element, Core.DialogWindowDOMElement, "Core.DialogWindowDOMElement");
Sys.ns("Core");
Core.DialogWindowBaseView = {
    BASE_CSS: "interface-dialogWindow_base",
    PORTRAIT_CSS: "interface-dialogWindow_portrait",
    LANDSCAPE_CSS: "interface-dialogWindow_landscape",
    constructor: function () {
        var a = this;
        Core.DialogWindowBaseView.superclass.constructor.apply(a, arguments);
        a.container = a.dialogDOMElement
    },
    onPortrait: function () {
        var a = this;
        Mixins.orientation.view.methods.onPortrait.call(a)
    },
    onLandscape: function () {
        var a = this;
        Mixins.orientation.view.methods.onLandscape.call(a)
    },
    adaptToOrientation: function (a) {
        Mixins.orientation.view.methods.setStyle.call(this, a)
    }
};
Core.DialogWindowBaseView = Sys.extend(Core.DialogWindowView, Core.DialogWindowBaseView, "Core.DialogWindowBaseView");
Sys.ns("Core");
Core.DialogWindowMobileView = {
    PORTRAIT_CSS: "interface-dialogWindow-mobile_portrait",
    LANDSCAPE_CSS: "interface-dialogWindow-mobile_landscape",
    constructor: function () {
        Core.DialogWindowMobileView.superclass.constructor.apply(this, arguments);
        this.setScale()
    },
    refresh: function () {
        this.setScale()
    },
    setScale: function () {
        var d = Environment.getCurrentResolutionPixelFactor(), e = this.dialogDOMElement.el,
            a = this.dialogDOMElement.container.el, b = Sys.utils.getPrefixedCSSProperty("transform"), c;
        if (Sys.isNumber(d)) {
            a.style[b] = "";
            a.style.height = "";
            a.style.width = "";
            c = 1 / (a.offsetWidth / Environment.getInnerScreenSize().width);
            if (Environment.getOrientation() === "PORTRAIT") {
                c = (isFinite(c) ? c : 1) * 0.95;
                a.style[b] = "scale(" + c.toFixed(1) + ")"
            } else {
                a.style[b] = "none"
            }
            if (e.classList.contains("scrollable")) {
                a.style[b] = "scale(" + 1 / d + ")";
                a.style.height = "calc(100% / " + 1 / d + ")";
                a.style.width = "calc(100% / " + 1 / d + ")"
            } else {
                a.style.height = "";
                a.style.width = ""
            }
        }
    }
};
Core.DialogWindowMobileView = Sys.extend(Core.DialogWindowBaseView, Core.DialogWindowMobileView, "Core.DialogWindowMobileView");
Sys.ns("Core");
Core.ResponseParser = {
    constructor: function () {
        Core.ResponseParser.superclass.constructor.apply(this, arguments)
    }, getDefaultMVCClasses: function () {
        return {controller: Core.ResponseParserController}
    }
};
Core.ResponseParser = Sys.extend(Core.Module, Core.ResponseParser, "Core.ResponseParser");
Sys.ns("Core");
Core.ResponseParserController = {
    constructor: function () {
        Core.ResponseParserController.superclass.constructor.apply(this, arguments)
    }, init: function () {
        Core.ResponseParserController.superclass.init.apply(this, arguments);
        this.doIntegrationSpecificResponseHandling(this.parseServerResponse(Resources.readData("unParsedGameServerInitResponse")))
    }, setupEvents: function () {
        this.on({"notify:serverManager.serverResponseReceived": this.parseAndBroadcastServerResponse})
    }, parseAndBroadcastServerResponse: function (e, c) {
        var f = this, a = (Sys.isDefined(c)) ? c : "notify:responseParser.responseParsed",
            b = f.parseServerResponse(e.responseText), d = Object.keys(b).length;
        b = f.doIntegrationSpecificResponseHandling(b);
        if (e.responseText.trim().length === 0) {
            f.fireEvent("request:errorManager.handleError")
        } else {
            if (d > 1) {
                f.fireEvent(a, b, e)
            }
        }
    }, parseServerResponse: function (a) {
        return Sys.utils.parseQueryStringToNestedObject(a)
    }, doIntegrationSpecificResponseHandling: function (a) {
        return a
    }
};
Core.ResponseParserController = Sys.extend(Core.Controller, Core.ResponseParserController, "Core.ResponseParserController");
Sys.ns("Core");
Core.ErrorManager = {
    constructor: function () {
        Core.ErrorManager.superclass.constructor.apply(this, arguments)
    }, getDefaultMVCClasses: function () {
        return {controller: Core.ErrorManagerController, model: Core.ErrorManagerModel}
    }
};
Core.ErrorManager = Sys.extend(Core.Module, Core.ErrorManager, "Core.ErrorManager");
Sys.ns("Core");
Core.ErrorManagerModel = {
    constructor: function () {
        Core.ErrorManagerModel.superclass.constructor.apply(this, arguments)
    },
    setupData: function () {
        var a = Resources.readData("queryData"), b = Sys.isDefined(a.depositAvailable) && a.depositAvailable === true;
        this.storeData("depositAvailable", b);
        this.storeData("dialogConfig", this.setupDialogConfig(b))
    },
    setupDialogConfig: function (b) {
        var a = {};
        a.http = {
            title: Services.languageManager.getText(Language.Keys.connectionLost),
            text: Services.languageManager.getText(Language.Keys.reload),
            buttons: [{type: "casino", reason: "9"}, {type: "reload"}],
            fatal: true
        };
        a[11] = {
            title: Services.languageManager.getText(Language.Keys.playLimit),
            text: Services.languageManager.getText("11"),
            buttons: [{type: "casino", reason: "11"}]
        };
        a[12] = {
            title: Services.languageManager.getText(Language.Keys.freeRounds_expired),
            buttons: [{type: "casino"}],
            fatal: true
        };
        a[13] = {
            title: Services.languageManager.getText(Language.Keys.playLimit),
            text: Services.languageManager.getText("13"),
            buttons: [{type: "reduceBetAndRevertSpin"}, {type: "closeAndRevertSpin"}]
        };
        Sys.each([14, 16], function (c) {
            a[c] = {
                text: Services.languageManager.getText(Language.Keys.freeRoundsOfferUsed),
                buttons: [{type: "closeBonusProgramWidget"}]
            }
        });
        a[20] = {
            title: Services.languageManager.getText(Language.Keys.sessionTimeOut),
            text: Services.languageManager.getText(Language.Keys.returnToLobby),
            buttons: [{type: "casino", reason: "3"}],
            fatal: true
        };
        Sys.each([10, 15, 51, 100, 101, 102], function (c) {
            a[c] = {
                title: Services.languageManager.getText(Language.Keys.outOfMoney),
                text: Services.languageManager.getText(Language.Keys.deposit),
                buttons: b ? [{type: "deposit"}, {type: "reduceBetAndRevertSpin"}] : [{type: "casino"}, {type: "reduceBetAndRevertSpin"}]
            }
        });
        Sys.each([0, 53, 56, 58], function (c) {
            a[c] = {
                title: Services.languageManager.getText(Language.Keys.gameUnavailable) + " (" + c + ")",
                buttons: [{type: "casino", reason: "9"}, {type: "reload"}],
                fatal: true
            }
        });
        a[70] = {
            title: Services.languageManager.getText(Language.Keys.accountUnavailable),
            buttons: [{type: "casino"}, {type: "reload"}],
            fatal: true
        };
        a.generic = {
            title: Services.languageManager.getText(Language.Keys.error),
            text: Services.languageManager.getText(Language.Keys.returnToLobby),
            buttons: [{type: "casino", reason: "9"}],
            fatal: true,
            hideGame: true
        };
        a.gameInactive = {
            title: Services.languageManager.getText(Language.Keys.gameUnavailable),
            text: Services.languageManager.getText(Language.Keys.lostConnectInactivity),
            buttons: [{type: "casino", reason: "9"}, {type: "reload"}],
            fatal: true,
            hideGame: true
        };
        return a
    }, getDialogConfig: function (a) {
        var c = this.readData("dialogConfig"), b;
        if (Sys.isDefined(c[a])) {
            b = c[a]
        } else {
            b = c.generic
        }
        b.errorCode = a;
        return b
    }, setUpOutOfMoneyErrorConfig: function () {
        var f = Services.languageManager.getText(Language.Keys.outOfMoney), c = this.readData("depositAvailable"),
            b = Services.moneyManager.getBalanceCents(), e = Services.moneyManager.getMinimumBetCents(), d, a;
        if (b >= e) {
            if (c) {
                d = Services.languageManager.getText(Language.Keys.deposit);
                a = [{type: "deposit"}, {type: "reduceBet"}]
            } else {
                d = Services.languageManager.getText(Language.Keys.reduce);
                a = [{type: "reduceBet"}, {type: "close"}]
            }
        } else {
            d = Services.languageManager.getText(Language.Keys.depositPlay);
            if (c) {
                a = [{type: "deposit"}, {type: "close"}]
            } else {
                a = [{type: "close"}]
            }
        }
        return {title: f, text: d, buttons: a, errorCode: 100}
    }
};
Core.ErrorManagerModel = Sys.extend(Core.Model, Core.ErrorManagerModel, "Core.ErrorManagerModel");
Sys.ns("Core");
Core.ErrorManagerController = {
    constructor: function () {
        Core.ErrorManagerController.superclass.constructor.apply(this, arguments)
    }, setupEvents: function () {
        this.on({
            "request:errorManager.handleError": this.showDialogForErrorCode,
            "request:errorManager.handleRequestError": this.handleRequestError,
            "request:errorManager.handleGameInactive": this.handleGameInactive,
            "request:errorManager.handleClientOutOfMoneyError": this.handleClientOutOfMoneyError
        })
    }, showDialog: function (a) {
        var b = (a.errorCode === "http") ? 0 : a.errorCode;
        this.fireEvent("notify:errorManager.error", b, Services.languageManager.getText(b));
        this.fireEvent("request:dialogWindow.showDialog", a)
    }, showDialogForErrorCode: function (a) {
        this.showDialog(this.getDialogConfig(a))
    }, handleRequestError: function (b) {
        var c = this, a = c.handleHttpErrors(b);
        if (!a) {
            a = c.handleIntegrationSpecificErrors(b)
        }
        if (!a) {
            a = c.handleGameSpecificErrors(b)
        }
        if (!a) {
            a = c.handleServerErrors(b)
        }
        if (!a) {
            c.fireEvent("notify:errorManager.noErrorDetected")
        } else {
            if (a.fatal) {
                c.fireEvent("request:audioPlayer.stopAll")
            }
            c.showDialog(a)
        }
    }, handleHttpErrors: function (a) {
        if (Sys.utils.httpRequestIsOK(a)) {
            return undefined
        }
        return this.getDialogConfig("http")
    }, handleIntegrationSpecificErrors: function (a) {
    }, handleGameSpecificErrors: function (a) {
    }, handleServerErrors: function (a) {
        var b = Sys.utils.getErrorCode(a);
        if (!Sys.isDefined(b)) {
            return undefined
        }
        return this.getDialogConfig(b)
    }, handleGameInactive: function () {
    }, handleClientOutOfMoneyError: function () {
        var b = this, a = b.model.setUpOutOfMoneyErrorConfig();
        a.buttons = b.getButtons(a.buttons);
        b.showDialog(a)
    }, getDialogConfig: function (b) {
        var a = this.model.getDialogConfig(b);
        return {
            title: a.title,
            text: a.text,
            buttons: this.getButtons(a.buttons),
            fatal: a.fatal,
            hideGame: Boolean(Sys.isDefined(a.hideGame) && a.hideGame),
            errorCode: b
        }
    }, getButtons: function (c) {
        var b = [], a;
        for (a = 0; a < c.length; a++) {
            b.push(this.getButton(c[a]))
        }
        return b
    }, getButton: function (a) {
        var b = this;
        switch (a.type) {
            case"casino":
                return {
                    text: Services.languageManager.getText(Language.Keys.btn_casino), action: function () {
                        b.onButtonInteraction();
                        Environment.goToLobby(a.reason)
                    }
                };
            case"reload":
                return {
                    text: Services.languageManager.getText(Language.Keys.btn_reload), action: function () {
                        b.onButtonInteraction();
                        Environment.reload()
                    }
                };
            case"close":
                return {
                    text: Services.languageManager.getText(Language.Keys.btn_close), action: function () {
                        b.onButtonInteraction()
                    }
                };
            case"closeBonusProgramWidget":
                return {
                    text: Services.languageManager.getText(Language.Keys.btn_close), action: function () {
                        b.onButtonInteraction();
                        b.closeBonusProgramWidget()
                    }
                };
            case"closeAndRevertSpin":
                return {
                    text: Services.languageManager.getText(Language.Keys.btn_close), action: function () {
                        b.onButtonInteraction();
                        b.revertSpin()
                    }
                };
            case"reduceBetAndRevertSpin":
                return {
                    text: Services.languageManager.getText(Language.Keys.btn_reduceBet), action: function () {
                        b.onButtonInteraction();
                        b.revertSpin();
                        b.openBetSettings()
                    }
                };
            case"reduceBet":
                return {
                    text: Services.languageManager.getText(Language.Keys.btn_reduceBet), action: function () {
                        b.onButtonInteraction();
                        b.openBetSettings()
                    }
                };
            case"deposit":
                return {
                    text: Services.languageManager.getText(Language.Keys.btn_deposit), action: function () {
                        b.onButtonInteraction();
                        Services.moneyManager.reloadBalance();
                        Environment.goToCashier()
                    }
                };
            default:
                return {
                    text: "[ERROR]",
                    action: console.error.bind(console, "this button was not correctly configured in the error manager")
                }
        }
    }, openBetSettings: function () {
        this.fireEvent("request:betSettings.show")
    }, revertSpin: function () {
        this.fireEvent("request:moneyManager.revertBet");
        this.fireEvent("request:spin.activateDefaultOutcome", "basic")
    }, closeBonusProgramWidget: function () {
        this.fireEvent("notify:bonusProgramWidget.close")
    }, onButtonInteraction: function () {
        this.fireEvent("notify:errorManager.errorDialogClosed")
    }
};
Core.ErrorManagerController = Sys.extend(Core.Controller, Core.ErrorManagerController, "Core.ErrorManagerController");
Sys.ns("Core");
Core.ErrorManagerDesktopModel = {
    constructor: function () {
        Core.ErrorManagerDesktopModel.superclass.constructor.apply(this, arguments)
    }, setUpOutOfMoneyErrorConfig: function () {
        var e = Services.languageManager.getText(Language.Keys.outOfMoney), b = Services.moneyManager.getBalanceCents(),
            d = Services.moneyManager.getMinimumBetCents(), c, a = [{type: "close"}];
        if (b >= d) {
            c = Services.languageManager.getText(Language.Keys.reduce)
        } else {
            c = Services.languageManager.getText(Language.Keys.depositPlay)
        }
        return {title: e, text: c, buttons: a, errorCode: 100}
    }, setupDialogConfig: function (b) {
        var a = Core.ErrorManagerDesktopModel.superclass.setupDialogConfig.apply(this, arguments);
        a.http.buttons = [{type: "reload"}];
        a[11].buttons = [{type: "reload"}];
        a[12].buttons = [{type: "reload"}];
        a[13].buttons = [{type: "closeAndRevertSpin"}];
        a[20].buttons = [];
        a[20].text = Services.languageManager.getText("20");
        Sys.each([10, 15, 51, 100, 101, 102], function (c) {
            a[c].buttons = [{type: "closeAndRevertSpin"}]
        });
        Sys.each([0, 53, 56, 58], function (c) {
            a[c].buttons = [{type: "reload"}]
        });
        a[70].buttons = [{type: "reload"}];
        a.generic.buttons = [{type: "reload"}];
        a.generic.text = Services.languageManager.getText(Language.Keys.reload);
        a.gameInactive.buttons = [{type: "reload"}];
        return a
    }
};
Core.ErrorManagerDesktopModel = Sys.extend(Core.ErrorManagerModel, Core.ErrorManagerDesktopModel, "Core.ErrorManagerDesktopModel");
Sys.ns("Core");
Core.LocalStorageManager = {
    constructor: function () {
        Core.LocalStorageManager.superclass.constructor.apply(this, arguments)
    }, getDefaultMVCClasses: function () {
        return {model: Core.LocalStorageManagerModel, controller: Core.LocalStorageManagerController}
    }
};
Core.LocalStorageManager = Sys.extend(Core.Module, Core.LocalStorageManager, "Core.LocalStorageManager");
Sys.ns("Core");
Core.LocalStorageManagerController = {
    constructor: function () {
        Core.LocalStorageManagerController.superclass.constructor.apply(this, arguments)
    }, storeData: function (a, b) {
        this.model.writeToStorage(a, b)
    }, readData: function (a) {
        return this.model.readFromStorage(a)
    }, removeData: function (a) {
        this.model.removeFromStorage(a)
    }, hasData: function (a) {
        return this.model.hasData(a)
    }
};
Core.LocalStorageManagerController = Sys.extend(Core.Controller, Core.LocalStorageManagerController, "Core.LocalStorageManagerController");
Sys.ns("Core");
Core.LocalStorageManagerModel = {
    constructor: function () {
        Core.LocalStorageManagerModel.superclass.constructor.apply(this, arguments)
    }, writeToStorage: function (a, b) {
        if (this.readData("storageActive")) {
            if (Sys.isString(a) && Sys.isString(b)) {
                this._setItemInStorage(this.accessKey + a, b)
            }
        }
    }, readFromStorage: function (a) {
        var b = this;
        if (b.readData("storageActive")) {
            if (!Sys.isDefined(a)) {
                return b.getAllData()
            }
            if (Sys.isString(a)) {
                return b._getItemFromStorage(b.accessKey + a)
            }
        }
        return false
    }, removeFromStorage: function (a) {
        if (this.readData("storageActive")) {
            if (Sys.isString(a)) {
                this._removeItemFromStorage(this.accessKey + a)
            }
        }
    }, hasData: function (a) {
        if (Sys.isDefined(a)) {
            if (Sys.isString(this.readFromStorage(a))) {
                return true
            }
        }
        return false
    }, setupData: function () {
        var a = this, b = Resources.readData("queryData");
        a.accessKey = a.createAccessKey(b.operatorId, b.gameId, Resources.readData("sessionID"));
        a.storeData("storageActive", a.isLocalStorageSupported() && Sys.isDefined(a.accessKey))
    }, createAccessKey: function (a, b, c) {
        if (Sys.isDefined(a) && Sys.isDefined(b) && Sys.isDefined(c)) {
            return this.hashValue(a + "." + b + "." + c) + "."
        }
        return undefined
    }, activate: function () {
        this.storeData("storageActive", true)
    }, deactivate: function () {
        this.storeData("storageActive", false)
    }, getAllData: function () {
        var c = this, d = {}, b = 0, a = c._getKeyFromStorage(b);
        while (a) {
            if (a.indexOf(c.accessKey) === 0) {
                d[a.replace(c.accessKey, "")] = c._getItemFromStorage(a)
            }
            ++b;
            a = c._getKeyFromStorage(b)
        }
        return d
    }, hashValue: function (c) {
        var d = 2285455121, b, a;
        if (!Sys.isString(c)) {
            return null
        }
        for (a = 0, b = c.length; a < b; a++) {
            d += c.charCodeAt(a) * (a + 1)
        }
        return d
    }, isLocalStorageSupported: function () {
        if ((typeof window.localStorage === "object")) {
            try {
                this._setItemInStorage("availabilityCheck", "true");
                this._removeItemFromStorage("availabilityCheck");
                return true
            } catch (a) {
                return false
            }
        }
        return false
    }, _setItemInStorage: function (a, b) {
        localStorage.setItem(a, b)
    }, _removeItemFromStorage: function (a) {
        localStorage.removeItem(a)
    }, _getItemFromStorage: function (a) {
        return localStorage.getItem(a)
    }, _getKeyFromStorage: function (a) {
        return localStorage.key(a)
    }
};
Core.LocalStorageManagerModel = Sys.extend(Core.Model, Core.LocalStorageManagerModel, "Core.LocalStorageManagerModel");
Sys.ns("Core");
Core.AutoPlayer = {
    constructor: function () {
        Core.AutoPlayer.superclass.constructor.apply(this, arguments)
    }, getDefaultMVCClasses: function () {
        return {model: Core.AutoPlayerModel, controller: Core.AutoPlayerController}
    }, getMixinDependencies: function () {
        return ["serverResponse"]
    }
};
Core.AutoPlayer = Sys.extend(Core.Module, Core.AutoPlayer, "Core.AutoPlayer");
Sys.ns("Core");
Core.AutoPlayerController = {
    constructor: function () {
        Core.AutoPlayerController.superclass.constructor.apply(this, arguments)
    }, setupEvents: function () {
        var a = this;
        a.on({
            "request:autoPlayer.stop": a.stop,
            "request:autoPlayer.pause": a.pause,
            "request:autoPlayer.start": a.start,
            "request:autoPlayer.resume": a.resume,
            "notify:serverManager.serverErrorReceived": a.stop,
            "notify:stateHandler.leavingIdleState": a.onLeavingIdleState,
            "notify:stateHandler.enteringIdleState": a.onEnteringIdleState,
            "notify:stateHandler.enteringStandardWinPresentationState": a.onEnteringWinPresentationState,
            "notify:stateHandler.enteringBigWinState": a.onEnteringWinPresentationState,
            "notify:spinButton.clicked": a.onSpinButtonClicked,
            "notify.dialogWindow.showingDialog": a.onShowingDialog,
            "notify:dialogWindow.allDialogsClosed": a.onAllDialogsClosed,
            "notify:settingsManager.settingChanged": a.onSettingChanged,
            "notify:errorManager.error": a.stop
        })
    }, playRound: function () {
        if (this.model.readData("nrRounds") > 0) {
            this.requestRoundStart()
        }
    }, start: function () {
        this.play();
        if (!this.model.readData("spinning") && this.model.readData("isBasicState")) {
            this.requestRoundStart()
        }
    }, stop: function () {
        if (!this.model.isState("STOPPED")) {
            this.fireEvent("request:spinButton.removeProperty", "visibleDuringRound", this.MODULE_NAME);
            this.fireEvent("request:spinButton.hideCounter");
            this.fireEvent("request:spinButton.removeDisplayType", "autoPlay");
            this.fireEvent("request:spinButton.removeDisplayType", "autoPlayStop");
            this.fireEvent("request:quickStopper.enableInMode", "autoPlay");
            this.fireEvent("request:playModeManager.removeMode", "autoplay");
            this.model.setState("STOPPED");
            this.model.storeData("nrRounds", 0);
            this.fireEvent("request:settingsManager.storeData", "autoPlayNrSpins", 0);
            this.fireEvent("request:spinButton.enable", this.MODULE_NAME);
            this.fireEvent("request:settingsButton.enable", this.MODULE_NAME);
            this.fireEvent("request:pluginMenu.enable", this.MODULE_NAME);
            this.fireEvent("request:betSettings.enable", this.MODULE_NAME);
            this.fireEvent("request:maxBetButton.enable", this.MODULE_NAME);
            this.fireEvent("notify:autoPlayer.stopped")
        }
    }, pause: function () {
        if (this.model.isState("PLAYING")) {
            this.model.setState("PAUSED")
        }
    }, resume: function () {
        var a = this;
        if (this.model.isState("PAUSED")) {
            this.model.setState("PLAYING");
            if (!a.model.readData("spinning")) {
                a.playRound()
            }
        }
    }, play: function () {
        var a = this;
        if (!a.model.isState("PLAYING") && a.model.readData("nrRounds") > 0) {
            a.model.setState("PLAYING");
            a.fireEvent("request:spinButton.removeDisplayType", "autoPlay");
            a.fireEvent("request:spinButton.addDisplayType", "autoPlayStop");
            a.fireEvent("request:quickStopper.disableInMode", "autoPlay");
            a.fireEvent("request:spinButton.disable", a.MODULE_NAME);
            a.fireEvent("request:betSettings.disable", a.MODULE_NAME);
            a.fireEvent("request:maxBetButton.disable", a.MODULE_NAME);
            a.fireEvent("request:settingsButton.disable", a.MODULE_NAME);
            a.fireEvent("request:pluginMenu.disable", a.MODULE_NAME);
            a.fireEvent("notify:autoPlayer.starting");
            a.fireEvent("request:playModeManager.addMode", "autoplay")
        }
    }, onSpinButtonClicked: function (a) {
        if (Sys.isDefined(a) && a.hasOwnProperty("skip") && a.skip === true) {
            return false
        }
        if (this.model.isState("PLAYING") || this.model.isState("PAUSED") || this.model.isState("STOPPING")) {
            this.stop()
        }
        return true
    }, onEnteringIdleState: function () {
        var b = this, a = b.model;
        a.storeData("spinning", false);
        if (a.isState("PLAYING")) {
            b.playRound()
        }
        if (a.isState("STOPPING")) {
            b.stop()
        }
        if (a.isState("WAITING")) {
            b.fireEvent("request:playModeManager.addMode", "autoplay");
            b.play();
            b.requestRoundStart()
        }
    }, onLeavingIdleState: function () {
        var a = this;
        a.model.storeData("spinning", true);
        if (a.model.isState("WAITING")) {
            a.fireEvent("request:playModeManager.addMode", "autoplay");
            a.play()
        }
        if (a.model.isState("PLAYING")) {
            a.fireEvent("request:spinButton.updateCounter", a.model.readData("nrRounds"))
        }
    }, onEnteringWinPresentationState: function () {
        var b = this, a = b.model;
        if (a.isState("STOPPING") && Services.settingsManager.getSetting("autoPlayNrSpins") > 0) {
            b.fireEvent("request:settingsManager.storeData", "autoPlayNrSpins", 0)
        }
    }, onShowingDialog: function () {
        if (this.model.readData("nrRounds") > 0) {
            this.pause()
        }
    }, onAllDialogsClosed: function () {
        if (this.model.readData("nrRounds") > 0) {
            this.resume()
        }
    }, reduceNumberOfRounds: function () {
        this.model.playRound();
        this.fireEvent("request:spinButton.updateCounter", this.model.readData("nrRounds"));
        this.fireEvent("notify:autoPlayer.reduceCounter", this.model.readData("nrRounds"))
    }, onSettingChanged: function (a, c) {
        var b = this;
        if (a === "autoPlayNrSpins" && c !== b.model.readData("nrRounds")) {
            b.model.storeData("nrRounds", c);
            if (c === 0) {
                b.stop()
            } else {
                b.fireEvent("notify:autoPlayer.enabled", c);
                b.fireEvent("request:spinButton.showCounter", c);
                b.fireEvent("request:spinButton.addDisplayType", "autoPlay");
                b.fireEvent("request:spinButton.addProperty", "visibleDuringRound", b.MODULE_NAME);
                b.model.setState("WAITING");
                b.model.storeData("startingBalance", Services.moneyManager.getBalanceCents())
            }
        } else {
            if (["stopAutoplayIfBalanceIncreasedBy", "stopAutoplayIfBalanceDecreasedBy", "stopAutoplayOnAnyWin", "stopAutoplayIfWinExceeds"].contains(a)) {
                b.model.storeData(a, c)
            }
        }
    }, requestRoundStart: function () {
        this.reduceNumberOfRounds();
        this.fireEvent("notify:autoPlayer.startRound", this.model.readData("nrRounds"));
        this.fireEvent("request:spinButton.startRound")
    }
};
Core.AutoPlayerController = Sys.extend(Core.Controller, Core.AutoPlayerController, "Core.AutoPlayerController");
Sys.ns("Core");
Core.AutoPlayerModel = {
    constructor: function () {
        Core.AutoPlayerModel.superclass.constructor.apply(this, arguments)
    }, playRound: function () {
        var a = this.readData("nrRounds") - 1;
        if (a <= 0) {
            a = 0;
            this.setState("STOPPING")
        }
        this.storeData("nrRounds", a)
    }, storeData: function (a, b) {
        Core.AutoPlayerModel.superclass.storeData.apply(this, arguments);
        if (a === "nrRounds") {
            Services.storage.storeData("autoPlayer.roundsLeft", b)
        }
    }, shouldPlayAnotherRound: function () {
        return this.isState("PLAYING")
    }, shouldStopAutoplay: function (e) {
        var d = this.readData("startingBalance"), i = this.readData("stopAutoplayIfBalanceIncreasedBy"),
            a = this.readData("stopAutoplayIfBalanceDecreasedBy"), c = this.readData("stopAutoplayOnAnyWin"),
            g = this.readData("stopAutoplayIfWinExceeds"),
            b = e.nextaction === "spin" ? Services.moneyManager.getBetCents() : 0, f, h;
        if (Sys.isObj(e.wins)) {
            f = e.wins.cents;
            h = e.wins.centsTotal
        }
        if ((i !== false && i !== 0) && (e.credit >= d + i)) {
            return true
        }
        if ((a !== false && a !== 0) && (e.credit - b < d - a)) {
            return true
        }
        if (c === true && (f > 0 || h > 0)) {
            return true
        }
        return g !== false && g !== 0 && (f >= g || h >= g)
    }, processServerResponse: function (b) {
        var a = b.gamestate || {};
        if (!this.isState("STOPPED") && this.shouldStopAutoplay(b)) {
            this.setState("STOPPING")
        }
        this.storeData("isBasicState", a.current === "basic")
    }, setupData: function () {
        var a = this, b = a.storeData.bind(a);
        b("nrRounds", 0);
        a.setState("STOPPED");
        b("spinning", true);
        b("startingBalance", 0);
        b("stopAutoplayIfBalanceIncreasedBy", false);
        b("stopAutoplayIfBalanceDecreasedBy", false);
        b("stopAutoplayOnAnyWin", false);
        b("stopAutoplayIfWinExceeds", false)
    }
};
Core.AutoPlayerModel = Sys.extend(Core.Model, Core.AutoPlayerModel, "Core.AutoPlayerModel");
Sys.ns("Core");
Core.G4 = {
    constructor: function () {
        Core.G4.superclass.constructor.apply(this, arguments)
    }, getDefaultMVCClasses: function () {
        return {model: Core.G4Model, view: Core.View, controller: Core.G4Controller}
    }, getStateChanges: function () {
        var a = this.model;
        return {
            minimumRoundTimeEnforcement: {
                state: {
                    name: "MinimumRoundTimeEnforcement", execute: function (b) {
                    }, waitEvents: {"notify:g4.minimumRoundTimePassed": false}
                }
            }, stopped: {
                queue: [function (b) {
                    if (a.isG4() && a.isNewRound()) {
                        b.stateHandler.pushState(b.states.minimumRoundTimeEnforcement)
                    }
                }]
            }
        }
    }
};
Core.G4 = Sys.extend(Core.Module, Core.G4, "Core.G4");
Sys.ns("Core");
Core.G4Model = {
    constructor: function () {
        Core.G4Model.superclass.constructor.apply(this, arguments)
    }, setupData: function () {
        var b = this, a = Resources.readData("gameServerInitResponse");
        b.storeData("isG4", a.g4mode);
        b.storeData("G4Config", b.setupG4Config());
        b.storeData("isNewRound", false);
        b.storeData("roundTimeLimit", 3000);
        b.storeData("disabledDuringRound", false)
    }, isG4: function () {
        return this.readData("isG4")
    }, setupG4Config: function () {
        return {
            settings: [{name: "quickSpin", enabled: false, offValue: false}],
            modules: [{name: "systemClock", enabled: true}, {name: "quickStopper", enabled: false}]
        }
    }, getMinimumTimeLeft: function () {
        var b = this, a = b.getRoundStartTime() + b.readData("roundTimeLimit"), c = a - Date.now();
        return c > 0 ? c : 0
    }, isNewRound: function () {
        return this.readData("isNewRound")
    }, setRoundStartTime: function () {
        var a = Date.now();
        this.storeData("roundStartTime", a)
    }, getRoundStartTime: function () {
        return this.readData("roundStartTime")
    }, getG4Config: function (b) {
        var a = this.readData("G4Config");
        if (a.hasOwnProperty(b)) {
            return a[b]
        }
        return undefined
    }
};
Core.G4Model = Sys.extend(Core.Model, Core.G4Model, "Core.G4Model");
Sys.ns("Core");
Core.G4DesktopModel = {
    constructor: function () {
        Core.G4DesktopModel.superclass.constructor.apply(this, arguments)
    }, setupData: function () {
        Core.G4DesktopModel.superclass.setupData.apply(this, arguments);
        this.storeData("disabledDuringRound", true)
    }
};
Core.G4DesktopModel = Sys.extend(Core.G4Model, Core.G4DesktopModel, "Core.G4DesktopModel");
Sys.ns("Core");
Core.G4Controller = {
    constructor: function () {
        Core.G4Controller.superclass.constructor.apply(this, arguments)
    }, setupEvents: function () {
        var a = this;
        a.on({
            "notify:stateHandler.enteringBeforeLoaderCloseState": a.initG4IfActive,
            "notify:stateHandler.enteringMinimumRoundTimeEnforcementState": a.minimumRoundTimeEnforcement,
            "notify:stateHandler.enteringSpinningState": a.onStartSpin
        })
    }, initG4IfActive: function () {
        var b = this, a;
        if (b.model.readData("isG4")) {
            a = b.model.readData("G4Config");
            b.requestModuleChanges(a.modules);
            b.requestSettingChanges(a.settings);
            if (b.model.readData("disabledDuringRound")) {
                b.fireEvent("request:spinButton.addProperty", "disabledDuringRound", b.MODULE_NAME)
            }
        }
    }, minimumRoundTimeEnforcement: function () {
        var c = this, d, a, b;
        if (c.model.isNewRound()) {
            b = c.model.getMinimumTimeLeft();
            a = c.model.readData("roundExtensionTimer");
            if (b > 0) {
                if (Sys.isDefined(a)) {
                    clearTimeout(a)
                }
                d = setTimeout(function () {
                    c.fireEvent("notify:g4.minimumRoundTimePassed")
                }, b);
                c.model.storeData("roundExtensionTimer", d)
            } else {
                c.fireEvent("notify:g4.minimumRoundTimePassed")
            }
        }
    }, onStartSpin: function () {
        this.model.storeData("isNewRound", true);
        this.model.setRoundStartTime()
    }, requestSettingChanges: function (a) {
        var b = this;
        Sys.each(a, function (c) {
            if (c.enabled) {
                b.dispatchRequestEnableSettingEvent(c.name)
            } else {
                if (!c.enabled) {
                    b.dispatchRequestDisableSettingEvent(c.name, c.offValue)
                }
            }
        })
    }, requestModuleChanges: function (a) {
        var b = this;
        Sys.each(a, function (c) {
            if (c.enabled) {
                b.dispatchRequestEnableModuleEvent(c.name)
            } else {
                if (!c.enabled) {
                    b.dispatchRequestDisableModuleEvent(c.name)
                }
            }
        })
    }, dispatchRequestDisableSettingEvent: function (a, b) {
        var c = this;
        if (Sys.isDefined(b)) {
            c.fireEvent("request:settingsManager.storeValue", a, b)
        }
        c.fireEvent("request:settingsManager.disableSetting", a);
        c.fireEvent("request:settingsManager.lockSetting", a, c.MODULE_NAME)
    }, dispatchRequestEnableSettingEvent: function (a) {
        this.fireEvent("request:settingsManager.enableSetting", a)
    }, dispatchRequestDisableModuleEvent: function (a) {
        this.fireEvent("request:" + a + ".disableInMode", "g4")
    }, dispatchRequestEnableModuleEvent: function (a) {
        this.fireEvent("request:" + a + ".enableInMode", "g4")
    }
};
Core.G4Controller = Sys.extend(Core.Controller, Core.G4Controller, "Core.G4Controller");
Sys.ns("Core");
Core.PlayModeManager = {
    constructor: function () {
        Core.PlayModeManager.superclass.constructor.apply(this, arguments)
    }, getDefaultMVCClasses: function () {
        return {model: Core.PlayModeManagerModel, controller: Core.PlayModeManagerController}
    }
};
Core.PlayModeManager = Sys.extend(Core.Module, Core.PlayModeManager, "Core.PlayModeManager");
Sys.ns("Core");
Core.PlayModeManagerController = {
    USE_LOGGING: false, constructor: function () {
        Core.PlayModeManagerController.superclass.constructor.apply(this, arguments)
    }, setupEvents: function () {
        var a = this;
        a.on({"request:playModeManager.addMode": a.addMode, "request:playModeManager.removeMode": a.removeMode})
    }, addMode: function (a) {
        this.model.addMode(a)
    }, removeMode: function (a) {
        this.model.removeMode(a)
    }
};
Core.PlayModeManagerController = Sys.extend(Core.Controller, Core.PlayModeManagerController, "Core.PlayModeManagerController");
Sys.ns("Core");
Core.PlayModeManagerModel = {
    constructor: function () {
        Core.PlayModeManagerModel.superclass.constructor.apply(this, arguments)
    }, addMode: function (b) {
        var a = this.readData("modes");
        if (a.indexOf(b) === -1) {
            a.push(b);
            this.storeModeString()
        }
    }, removeMode: function (c) {
        var b = this.readData("modes"), a = b.indexOf(c);
        if (a >= 0) {
            b.splice(a, 1);
            this.storeModeString()
        }
    }, getModeString: function () {
        var b = this.readData("modes"), d = b.length, c = "", a;
        for (a = -1; ++a < d;) {
            c += ((a > 0) ? "," : "") + b[a]
        }
        return c
    }, setupData: function () {
        this.storeData("modes", []);
        this.storeModeString()
    }, storeModeString: function () {
        Services.storage.storeData(this.MODULE_NAME + ".modes", this.getModeString())
    }
};
Core.PlayModeManagerModel = Sys.extend(Core.Model, Core.PlayModeManagerModel, "Core.PlayModeManagerModel");
Sys.ns("Core.Slots");
Core.Slots.FreeRounds = {
    constructor: function () {
        Core.Slots.FreeRounds.superclass.constructor.apply(this, arguments)
    }, getStateChanges: function () {
        var a = this.model;
        return {
            beforeLoaderClose: {
                queue: [function (b) {
                    if (a.hasFreeRounds() && !a.readData("hasShownSplash")) {
                        b.stateHandler.pushState(b.states.freeRoundsDialog)
                    }
                }]
            }, stopped: {
                queue: [function (b) {
                    if (a.readData("freeRoundsLeft") === 0) {
                        b.stateHandler.pushState(b.states.checkForAdditionalFreeRounds)
                    }
                }]
            }, checkForAdditionalFreeRounds: {
                state: {
                    name: "CheckForAdditionalFreeRounds", execute: function () {
                    }, waitEvents: {"notify:responseParser.gameConfigurationParsed": false}
                }
            }, freeRoundsDialog: {
                state: {
                    name: "FreeRoundsDialog", execute: function () {
                    }, waitEvents: {}
                }
            }
        }
    }, getDefaultMVCClasses: function () {
        return {model: Core.Slots.FreeRoundsModel, controller: Core.Slots.FreeRoundsController}
    }
};
Core.Slots.FreeRounds = Sys.extend(Core.Module, Core.Slots.FreeRounds, "Core.Slots.FreeRounds");
Sys.ns("Core.Slots");
Core.Slots.FreeRoundsController = {
    constructor: function () {
        Core.Slots.FreeRoundsController.superclass.constructor.apply(this, arguments)
    }, init: function () {
        Core.Slots.FreeRoundsController.superclass.init.apply(this, arguments)
    }, setupEvents: function () {
        var a = this;
        a.on({
            "notify:stateHandler.enteringFreeRoundsDialogState": a.onEnteringFreeRoundsDialogState,
            "notify:stateHandler.enteringCheckForAdditionalFreeRoundsState": a.onEnteringCheckForAdditionalFreeRoundsState,
            "notify:responseParser.responseParsed": a.model.handleFreeRounds.bind(a.model),
            "notify:responseParser.gameConfigurationParsed": a.onGameConfigurationParsed,
            "request:freeRounds.requestGameConfiguration": a.requestGameConfiguration
        })
    }, onEnteringFreeRoundsDialogState: function () {
        this.showEnforcedContinueDialog()
    }, onEnteringCheckForAdditionalFreeRoundsState: function () {
        this.requestGameConfiguration()
    }, startFreeRounds: function () {
        var a = this;
        a.freeRoundsStarted = true;
        a.addListener("notify:stateHandler.enteringIdleState", a.onEnteringIdleState);
        a.addListener("notify:stateHandler.leavingIdleState", a.onLeavingIdleState);
        a.fireEvent("request:maxBetButton.disable", a.MODULE_NAME);
        a.fireEvent("request:betSettings.disable", a.MODULE_NAME);
        a.fireEvent("notify:freeRounds.started", a.model.readData("freeRoundsLeft"));
        a.setFreeroundModeParameter(true);
        a.model.storeData("hasShownSplash", true);
        a.model.storeData("totalFreeRounds", a.model.readData("freeRoundsLeft"))
    }, endFreeRounds: function () {
        this.freeRoundsStarted = false;
        this.showFreeRoundsEndDialog();
        this.model.removeData("freeRoundsLeft");
        this.removeListener("notify:stateHandler.enteringIdleState");
        this.removeListener("notify:stateHandler.leavingIdleState");
        this.fireEvent("request:maxBetButton.enable", this.MODULE_NAME);
        this.fireEvent("notify:freeRounds.ended")
    }, setFreeroundModeParameter: function (a) {
        this.setExtraParameter("freeroundmode", Boolean(a))
    }, setWantsFreeRoundsParameter: function (a) {
        this.setExtraParameter("wantsfreerounds", Boolean(a))
    }, setExtraParameter: function (c, a) {
        var b = Resources.readData("extraParams");
        if (Sys.isObj(b)) {
            b[c] = a;
            Resources.storeData("extraParams", b)
        }
    }, onEnteringIdleState: function () {
        this.requestCounterUpdate()
    }, onLeavingIdleState: function () {
        this.notifyFreeRoundsLeft()
    }, notifyFreeRoundsLeft: function () {
        var c = this, b = c.model.readData("totalFreeRounds"), a = c.model.readData("freeRoundsLeft");
        c.fireEvent("notify:freeRounds.nextRound", b, a)
    }, requestGameConfiguration: function () {
        var a = this;
        a.fireEvent("request:autoPlayer.stop");
        a.setFreeroundModeParameter(false);
        a.fireEvent("request:serverManager.sendAction", "init", "notify:responseParser.gameConfigurationParsed", "notify:serverManager.reInitRequestFailed")
    }, onGameConfigurationParsed: function (d, a) {
        var c = this, b = (d.nextaction === "spin");
        Resources.storeData("gameServerInitResponse", Sys.utils.qsToObj(a.responseText));
        Resources.storeData("gameServerInitResponseObject", Sys.utils.parseQueryStringToNestedObject(a.responseText));
        Resources.storeData("unParsedGameServerInitResponse", a.responseText);
        this.bonusProgramWidgetQueued = Boolean(d.freeRoundWidgetEnabled);
        this.bonusProgramWidgetActive = Boolean(Resources.readData("bonusProgramWidgetActive"));
        this.model.setupData();
        if (this.model.readData("freeRoundsLeft") > 0) {
            if (this.model.readData("isLowWinFreeRound")) {
                this.showExtraFreeRoundsDialog()
            } else {
                if (this.bonusProgramWidgetActive) {
                    this.fireEvent("notify:freeRounds.reInitResponseReceived", d);
                    this.startFreeRounds();
                    Resources.removeData("bonusProgramWidgetActive")
                } else {
                    this.showFreeRoundsEndDialog();
                    this.fireEvent("request:cashField.showBasicCashValues");
                    this.showEnforcedContinueDialog(function () {
                        c.fireEvent("notify:freeRounds.reInitResponseReceived", d);
                        c.startFreeRounds()
                    })
                }
            }
            this.requestCounterUpdate();
            this.notifyFreeRoundsLeft();
            this.setFreeroundModeParameter(true)
        } else {
            if (!b) {
                this.showFreeRoundsReloadDialog()
            } else {
                if (this.freeRoundsStarted) {
                    this.endFreeRounds()
                }
            }
        }
    }, requestCounterUpdate: function () {
        Services.storage.storeData("freeRounds.roundsLeft", this.model.readData("freeRoundsLeft"))
    }, closeFreeRoundsDialog: function () {
        this.fireEvent("notify:freeRounds.dialogClosed");
        if (this.bonusProgramWidgetQueued) {
            this.fireEvent("notify:bonusProgramWidget.reInit", Resources.readData("gameServerInitResponse"));
            this.bonusProgramWidgetQueued = false
        }
    }, showExtraFreeRoundsDialog: function () {
        var a = this;
        this.requestDialog({
            title: Services.languageManager.getText(Language.Keys.freeRoundsExtraTitle),
            text: Services.languageManager.getText(Language.Keys.freeRoundsExtraWon, [this.model.readData("freeRoundsLeft")]),
            buttons: [{
                scope: this,
                text: Services.languageManager.getText(Language.Keys["continue"]),
                action: function () {
                    a.closeFreeRoundsDialog()
                }
            }]
        })
    }, showFreeRoundsReloadDialog: function () {
        this.requestDialog({
            title: Services.languageManager.getText(Language.Keys.freeRoundsFinished),
            text: Services.languageManager.getText(Language.Keys.roundsUseAcctMoney) + " " + Services.languageManager.getText(Language.Keys.reload),
            buttons: [{
                scope: this,
                text: Services.languageManager.getText(Language.Keys.btn_reload),
                action: function () {
                    Environment.reload()
                }
            }]
        })
    }, showFreeRoundsEndDialog: function () {
        var a = this;
        this.requestDialog({
            title: Services.languageManager.getText(Language.Keys.freeRoundsFinished),
            text: Services.languageManager.getText(Language.Keys.roundsUseAcctMoney),
            buttons: [{
                scope: this,
                text: Services.languageManager.getText(Language.Keys["continue"]),
                action: function () {
                    a.closeFreeRoundsDialog()
                }
            }]
        })
    }, showEnforcedContinueDialog: function (b) {
        var a = this;
        this.requestDialog({
            title: Services.languageManager.getText(Language.Keys.roundsLeft),
            text: Services.languageManager.getText(Language.Keys.haveFreeRounds, [this.model.readData("freeRoundsLeft")]),
            buttons: [{
                scope: this,
                text: Services.languageManager.getText(Language.Keys["continue"]),
                action: b || function () {
                    a.startFreeRounds()
                }
            }]
        })
    }, requestDialog: function (a) {
        this.fireEvent("request:dialogWindow.showDialog", a)
    }
};
Core.Slots.FreeRoundsController = Sys.extend(Core.Controller, Core.Slots.FreeRoundsController, "Core.Slots.FreeRoundsController");
Sys.ns("Core.Slots");
Core.Slots.FreeRoundsModel = {
    constructor: function () {
        Core.Slots.FreeRoundsModel.superclass.constructor.apply(this, arguments)
    }, setupData: function () {
        var b = this, a = Resources.readData("gameServerInitResponseObject");
        b.storeData("hasShownSplash", false);
        b.handleFreeRounds(a)
    }, hasFreeRounds: function () {
        return this.readData("freeRoundsLeft") > 0
    }, handleFreeRounds: function (a) {
        if (Sys.isNumber(a.freeRoundsLeft)) {
            this.storeData("freeRoundsLeft", a.freeRoundsLeft);
            this.storeData("isLowWinFreeRound", a.isLowWinFreeRound)
        } else {
            this.removeData("freeRoundsLeft");
            this.removeData("isLowWinFreeRound")
        }
    }
};
Core.Slots.FreeRoundsModel = Sys.extend(Core.Model, Core.Slots.FreeRoundsModel, "Core.Slots.FreeRoundsModel");
Sys.ns("Core.Slots");
Core.Slots.ServerManager = {
    constructor: function () {
        Core.Slots.ServerManager.superclass.constructor.apply(this, arguments)
    }, getStateChanges: function () {
        return {
            spinning: {
                queue: [function (a) {
                    a.stateHandler.pushState(a.states.processServerResponse)
                }]
            }, processServerResponse: {
                state: {
                    name: "ProcessServerResponse", execute: function (a) {
                    }, waitEvents: {}
                }
            }
        }
    }, getDefaultMVCClasses: function () {
        return {model: Core.Slots.ServerManagerModel, view: Core.View, controller: Core.Slots.ServerManagerController}
    }
};
Core.Slots.ServerManager = Sys.extend(Core.Module, Core.Slots.ServerManager, "Core.Slots.ServerManager");
Sys.ns("Core.Slots");
Core.Slots.ServerManagerController = {
    constructor: function () {
        Core.Slots.ServerManagerController.superclass.constructor.apply(this, arguments)
    }, setupEvents: function () {
        var a = this;
        Core.Slots.ServerManagerController.superclass.setupEvents.apply(this, arguments);
        a.on({
            "notify:responseParser.responseParsed": a.storeNextAction,
            "notify:settingsManager.settingChanged": a.onSettingsChanged
        })
    }, onSettingsChanged: function (a, b) {
        if (a === "betLevel" || a === "denomination" || a === "betLines") {
            this.model.storeData("parameters:" + a, b)
        }
    }, sendAction: function (b, a) {
        b = (b === "nextAction") ? this.model.readData("nextAction") : b;
        Core.Slots.ServerManagerController.superclass.sendAction.call(this, b, a)
    }, storeNextAction: function (a) {
        this.model.storeData("nextAction", a.nextaction)
    }
};
Core.Slots.ServerManagerController = Sys.extend(Core.ServerManagerController, Core.Slots.ServerManagerController, "Core.Slots.ServerManagerController");
Sys.ns("Core.Slots");
Core.Slots.ServerManagerModel = {
    constructor: function () {
        Core.Slots.ServerManagerModel.superclass.constructor.apply(this, arguments)
    }, setupData: function () {
        var d = this, c, a, b;
        Core.Slots.ServerManagerModel.superclass.setupData.apply(d, arguments);
        c = Resources.readData("gameServerInitResponse");
        a = c["bl.standard"].split(",").length;
        b = "0-" + (a - 1).toString();
        d.storeData("parameters:betLines", b);
        d.storeData("nextAction", c.nextaction)
    }, getActionParameters: function (a) {
        var b = this.getBaseParameters(a);
        b = b + this.getFreeroundsParameters();
        switch (a) {
            case"init":
                return b + this.getInitParameters();
            case"jmxinit":
                return b + this.getJMXInitParameters();
            case"paytable":
                return b + this.getPaytableParameters();
            case"spin":
                return b + this.getSpinParameters();
            case"initfreespin":
                return b + this.getInitFreespinParameters();
            case"respin":
            case"freespin":
                return b + this.getFreespinParameters();
            case"widgetspin":
                return b + this.getWidgetspinParameters();
            default:
                return b
        }
    }, getBaseParameters: function (a) {
        return "action=" + a + "&sessid=" + this.readData("parameter:sessionID") + "&gameId=" + this.readData("parameter:gameID") + "&wantsreels=true"
    }, getFreeroundsParameters: function () {
        var a = Resources.readData("extraParams");
        return "&wantsfreerounds=" + a.wantsfreerounds + "&freeroundmode=" + a.freeroundmode
    }, getInitParameters: function () {
        return ""
    }, getJMXInitParameters: function () {
        return this.getInitParameters()
    }, getPaytableParameters: function () {
        return ""
    }, getSpinParameters: function () {
        var c = this,
            b = "&bet.betlevel=" + c.readData("parameters:betLevel") + "&bet.denomination=" + c.readData("parameters:denomination") + "&bet.betlines=" + c.readData("parameters:betLines"),
            a = c.readData("parameter:jmx");
        if (a) {
            b += "&" + a
        }
        return b
    }, getInitFreespinParameters: function () {
        return this.getInitParameters()
    }, getFreespinParameters: function () {
        var b = this.getInitParameters(), a = this.readData("parameter:jmx");
        if (a) {
            b += "&" + a
        }
        return b
    }, getWidgetspinParameters: function () {
        return "&bonusProgramId=" + Resources.readData("gameServerInitResponse").bonusProgramId
    }
};
Core.Slots.ServerManagerModel = Sys.extend(Core.ServerManagerModel, Core.Slots.ServerManagerModel, "Core.Slots.ServerManagerModel");
Sys.ns("Core.Slots");
Core.Slots.ResponseParser = {
    constructor: function () {
        Core.Slots.ResponseParser.superclass.constructor.apply(this, arguments)
    }, getDefaultMVCClasses: function () {
        return {model: Core.Model, view: Core.View, controller: Core.Slots.ResponseParserController}
    }
};
Core.Slots.ResponseParser = Sys.extend(Core.ResponseParser, Core.Slots.ResponseParser, "Core.Slots.ResponseParser");
Sys.ns("Core.Slots");
Core.Slots.ResponseParserController = {
    constructor: function () {
        Core.Slots.ResponseParserController.superclass.constructor.apply(this, arguments)
    }, parseServerResponse: function (d) {
        var b = this, c = Core.Slots.ResponseParserController.superclass.parseServerResponse.call(b, d), a;
        if (c.gamestate) {
            c.currentGameState = b.getCurrentGameState(c)
        }
        if (c.rs) {
            a = this.parseReelInfo(c);
            c.reelInfo = a;
            c.nearWinList = this.parseNearWin(c);
            if (c.ws) {
                c.wins = b.parseWinSituations(c, a);
                c.wins.winType = b.setWinType(c.wins.coins, Services.moneyManager.getBetCoins());
                c.wins.centsTotal = c.totalwin.cents;
                c.wins.coinsTotal = c.totalwin.coins
            } else {
                if (Sys.isDefined(c.totalwin)) {
                    c.wins = {centsTotal: c.totalwin.cents, coinsTotal: c.totalwin.coins}
                }
            }
        } else {
            if (Sys.isDefined(c.totalwin)) {
                c.wins = {centsTotal: c.totalwin.cents, coinsTotal: c.totalwin.coins}
            }
        }
        return c
    }, getCurrentGameState: function (c) {
        var b = this, a = b.model.readData("currentServerGameState");
        if (c.gamestate.current) {
            b.model.storeData("currentServerGameState", c.gamestate.current)
        } else {
            b.model.storeData("currentServerGameState", c.gamestate)
        }
        if (!a) {
            a = b.model.readData("currentServerGameState");
            if (a === "basic") {
                b.fireEvent("request:playModeManager.addMode", "basic")
            }
        }
        return a
    }, parseNearWin: function (b) {
        var a;
        if (Sys.isDefined(b.rs.i0)) {
            a = b.rs.i0.nearwin;
            if (Sys.isArray(a)) {
                return a
            } else {
                if (Sys.isNumber(a)) {
                    return [a]
                }
            }
        }
        return undefined
    }, setWinType: function (e, a) {
        var b = Resources.readData("config"), d = b.winTypes, c = "";
        if (e > 0) {
            if ((e >= a * d.smallWin.from) && (e < a * d.smallWin.to)) {
                c = "smallWin"
            } else {
                if ((e >= a * d.mediumWin.from) && (e < a * d.mediumWin.to)) {
                    c = "mediumWin"
                } else {
                    if ((e >= a * d.largeWin.from) && (e < a * d.largeWin.to)) {
                        c = "largeWin"
                    } else {
                        if (e >= a * d.bigWin.from) {
                            c = "bigWin"
                        }
                    }
                }
            }
        }
        return c
    }, parseReelInfo: function (a) {
        return Sys.utils.parseReelInfo(a)
    }, parseWinSituations: function (b, c) {
        var d = 0, a = [], e;
        if (b.ws) {
            while (b.ws["i" + d]) {
                a.push(b.ws["i" + d]);
                d++
            }
        }
        e = this.parseWinLayouts(a, c);
        this.doGameSpecificWinSituationParsing(e, a);
        return e
    }, parseWinLayouts: function (a, f) {
        var b, g, c, d = [], i, j = 0, h = 0, e = 0;
        for (b = 0; b < a.length; b++) {
            d.push({
                betline: Sys.isNumber(a[b].betline) ? a[b].betline + 1 : undefined,
                positions: [],
                reelset: a[b].reelset,
                wins: {}
            });
            if (Sys.isDefined(a[b].pos)) {
                for (g = 0; Sys.isDefined(a[b].pos["i" + g]); g++) {
                    i = {};
                    i.reelIndex = a[b].pos["i" + g][0];
                    i.symbolIndex = a[b].pos["i" + g][1];
                    i = Sys.apply(i, f[i.reelIndex].symbols[i.symbolIndex]);
                    d[b].positions.push(i)
                }
                d[b].positions.sort(this.sortSymbols)
            }
            for (c = 0; Sys.isDefined(a[b].types["i" + c]) && Sys.isDefined(a[b].types["i" + c].wintype); c++) {
                d[b].wins.type = a[b].types["i" + c].wintype;
                if (a[b].types["i" + c].wintype === "coins") {
                    d[b].wins.coins = a[b].types["i" + c].coins;
                    d[b].wins.cents = a[b].types["i" + c].cents;
                    j += a[b].types["i" + c].coins;
                    h += a[b].types["i" + c].cents
                } else {
                    if (a[b].types["i" + c].wintype === "freespins") {
                        d[b].wins.freespins = a[b].types["i" + c].freespins;
                        e += a[b].types["i" + c].freespins
                    } else {
                    }
                }
            }
        }
        d.sort(this.sortWinSituations);
        return {winSituations: d, coins: j, cents: h, freespins: e}
    }, sortSymbols: function (b, a) {
        return b.reelIndex - a.reelIndex
    }, sortWinSituations: function (b, a) {
        if (b.wins.coins) {
            if (a.wins.coins) {
                return a.wins.coins - b.wins.coins
            }
            return -1
        } else {
            if (a.wins.coins) {
                return 1
            }
        }
        return a.wins.freespins - b.wins.freespins
    }, doGameSpecificWinSituationParsing: function (b, a) {
    }
};
Core.Slots.ResponseParserController = Sys.extend(Core.ResponseParserController, Core.Slots.ResponseParserController, "Core.Slots.ResponseParserController");
Sys.ns("Core.Audio");
Core.Audio.AudioPlayer = {
    ENGINE: false, constructor: function () {
        var a = Resources.readData("config") || {};
        this.ENGINE = a.enableWADE || this.ENGINE;
        Core.Audio.AudioPlayer.superclass.constructor.apply(this, arguments)
    }, getStateChanges: function () {
        return {setupGame: {waitEvents: ["notify:audioPlayer.ready"]}}
    }, getMixinDependencies: function () {
        return ["trigger"]
    }, getDefaultMVCClasses: function () {
        if (Platform.hasWebAudioContext) {
            return {
                model: Core.Audio.AudioPlayerModel,
                view: this.ENGINE ? Core.Audio.AudioPlayerEngineView : Core.Audio.AudioPlayerView,
                controller: Core.Audio.AudioPlayerController
            }
        }
        return {
            model: Core.Audio.AudioPlayerModel,
            view: Core.Audio.Legacy.LegacyAudioPlayerView,
            controller: Core.Audio.AudioPlayerController
        }
    }
};
Core.Audio.AudioPlayer = Sys.extend(Core.Module, Core.Audio.AudioPlayer, "Core.Audio.AudioPlayer");
Sys.ns("Core.Audio");
Core.Audio.AudioPlayerController = {
    constructor: function () {
        Core.Audio.AudioPlayerController.superclass.constructor.apply(this, arguments)
    }, init: function () {
        var a = this;
        Core.Audio.AudioPlayerController.superclass.init.apply(a, arguments);
        a.soundsToLoadOnEnable = ["main"];
        if (Sys.isDefined(Resources.readData("preloadedAudio"))) {
            a.model.storeData("hasPreloadedAudio", true);
            a.view.decodePreloadedAudio()
        } else {
            setTimeout(function () {
                a.fireEvent("notify:audioPlayer.ready")
            }, 0);
            a.model.storeData("hasPreloadedAudio", false)
        }
    }, setupEvents: function () {
        var a = this;
        a.on({
            pageVisibilityChanged_event: a.onPageVisibilityChanged,
            "request:audioPlayer.play": a.play,
            "request:audioPlayer.stop": a.stop,
            "request:audioPlayer.stopAll": a.stopAll,
            "request:audioPlayer.stopNonLooping": a.stopNonLooping,
            "request:audioPlayer.loadSounds": a.loadSounds,
            "request:audioPlayer.disableEventInteractions": a.onDisableEventInteractions,
            "notify:stateHandler.leavingBeforeLoaderCloseState": a.onBeforeLoaderClose,
            "notify:resourceLoader.soundLoaded": a.view.onSoundResourceLoaded.bind(a.view),
            "notify:resourceLoader.soundLoadingFailed": a.handleLoadError,
            "notify:settingsManager.settingChanged": a.onSettingsChanged,
            "view:loadResource": a.fireEvent.bind(a, "request:resourceLoader.loadResource"),
            "view:soundLoaded": a.onSoundLoaded,
            "view:audioLoadError": a.handleLoadError
        })
    }, registerTriggers: function () {
        Services.trigger.registerTrigger("notify:audioPlayer.soundLoaded", this, "When the sound is loaded")
    }, onDisableEventInteractions: function () {
        var a = this;
        a.removeListener("request:audioPlayer.play");
        a.removeListener("request:audioPlayer.stop");
        a.removeListener("request:audioPlayer.stopAll");
        a.removeListener("request:audioPlayer.stopNonLooping")
    }, onSoundLoaded: function () {
        this.fireEvent("notify:audioPlayer.soundPlayable");
        this.fireEvent("notify:audioPlayer.soundLoaded");
        this.fireEvent("notify:audioPlayer.ready")
    }, onBeforeLoaderClose: function () {
        this.setAudioState(this.model.readData("hasPreloadedAudio"))
    }, onSettingsChanged: function (a, b) {
        if (a === "volume") {
            this.adjustVolume(b)
        }
    }, loadSounds: function (a) {
        var b = this;
        a = a || ["main"];
        if (!Sys.isArray(a)) {
            a = [a]
        }
        if (b.model.isState("audioEnabled")) {
            b.fireEvent("notify:audioPlayer.loadingSound");
            Sys.each(a, function (c) {
                b.view.loadSounds(c)
            })
        } else {
            Sys.each(a, function (c) {
                if (!b.soundsToLoadOnEnable.contains(c)) {
                    b.soundsToLoadOnEnable.push(c)
                }
            })
        }
    }, adjustVolume: function (a) {
        if (Sys.isNumber(a) && a >= 0 && a <= 1) {
            this.view.setVolume(a);
            if (a > 0) {
                this.setAudioState(true)
            }
        }
    }, setAudioState: function (b) {
        var c = this, d = b ? "audioEnabled" : "audioDisabled", a = c.soundsToLoadOnEnable.slice(0);
        if (c.model.isState(d)) {
            return
        }
        c.model.setState(d);
        c.fireEvent("notify:audioPlayer.audioStateSet", d);
        if (b && a.length > 0 && !c.model.readData("hasPreloadedAudio")) {
            c.loadSounds(a);
            c.soundsToLoadOnEnable.length = 0
        }
    }, onPageVisibilityChanged: function (b) {
        var a;
        if (b && this.model.isState("audioEnabled")) {
            this.model.setState("audioDisabled:hidden");
            this.adjustVolume(0);
            if (Audio.Engine) {
                Audio.Engine.setVolume(0)
            }
        } else {
            if (!b && this.model.isState("audioDisabled:hidden")) {
                this.model.setState("audioEnabled");
                a = Services.settingsManager.getSetting("volume");
                this.adjustVolume(a);
                if (Audio.Engine) {
                    Audio.Engine.setVolume(a)
                }
            }
        }
    }, play: function (b) {
        var a = this;
        if (!a.model.isState("audioEnabled") && Sys.isDefined(b) && Sys.isDefined(b.callback)) {
            b.callback();
            delete b.callback
        }
        a.view.play(b);
        a.fireEvent("notify:audioPlayer.playing", b)
    }, stop: function (b, a) {
        this.view.stop(b, a);
        this.fireEvent("notify:audioPlayer.stop", b)
    }, stopAll: function () {
        this.view.abort();
        this.fireEvent("notify:audioPlayer.stopAll")
    }, stopNonLooping: function () {
        this.view.stopNonLooping();
        this.fireEvent("notify:audioPlayer.stopNonLooping")
    }, handleLoadError: function (a) {
        throw new Error("Could not load audio.", a)
    }
};
Core.Audio.AudioPlayerController = Sys.extend(Core.Controller, Core.Audio.AudioPlayerController, "Core.Audio.AudioPlayerController");
Sys.ns("Core.Audio");
Core.Audio.AudioPlayerModel = {
    constructor: function () {
        Core.Audio.AudioPlayerModel.superclass.constructor.apply(this, arguments)
    }, setupData: function () {
        var a = Resources.readData("audioConfig");
        this.storeData("clips", a.clips);
        this.storeData("files", a.files)
    }
};
Core.Audio.AudioPlayerModel = Sys.extend(Core.Model, Core.Audio.AudioPlayerModel, "Core.Audio.AudioPlayerModel");
Sys.ns("Core.Audio");
Core.Audio.AudioPlayerView = {
    constructor: function () {
        Core.Audio.AudioPlayerView.superclass.constructor.apply(this, arguments)
    }, init: function (a) {
        var b = this, c = window.AudioContext;
        b.model = a.model;
        b.MODULE_NAME = a.name;
        b.audioPlaying = {};
        b.audioResources = {};
        b.audioBuffers = {};
        b.soundsToLoad = [];
        b.initializedAudio = false;
        b.context = new c();
        b.callbacks = {};
        b.duckingSounds = {};
        b.duckingRestore = {}
    }, setVolume: function (b) {
        var a = this;
        if (a.initializedAudio && Sys.isNumber(b)) {
            a.nodes.mainVolume.gain.value = b
        }
    }, play: function (e) {
        var d = this, c, g, b, f, a;
        if (!Sys.isDefined(e.source)) {
            c = d.setUpSource(e)
        } else {
            c = e
        }
        if (!Sys.isDefined(c)) {
            return
        }
        c.source.playbackRate.value = 1;
        b = d.audioPlaying[e.syncWithId];
        if (!Sys.isEmpty(b)) {
            f = d.context.currentTime - b[0].initTime;
            a = (f % c.duration);
            c.duration -= a;
            c.start = a + c.clipOffsetFromFileStart
        }
        g = d.getId(e);
        d.addToPlayingList(g, c);
        d.setupCallback(e.callback, c, g);
        if (!e.loop) {
            d.setupCallback(d.clipFinished.bind(d, c, g), c, g)
        }
        if (Sys.isDefined(c.ducking)) {
            d.duckSounds(c.ducking, c, g, e)
        }
        c.initTime = d.context.currentTime + c.delay - c.start + c.clipOffsetFromFileStart;
        if (e.loop === true && d.canPlayWithoutDuration) {
            if (c.start > 0) {
                c.source.start(d.context.currentTime + c.delay, c.start);
                c.source.onended = function () {
                    if (!c.stopped) {
                        d.play(e)
                    }
                };
                c.stopped = false
            } else {
                c.source.start(d.context.currentTime + c.delay)
            }
        } else {
            c.source.start(d.context.currentTime + c.delay, c.start, c.duration)
        }
    }, duckSounds: function (f, k, d, e) {
        var m = this, p = Object.keys(f), a = p.length, l, g, o, c, j, b, n, h;
        for (h = -1; ++h < a;) {
            b = p[h];
            n = f[b];
            g = m.duckingSounds[b];
            o = Sys.isDefined(n.duration) ? n.duration : k.duration;
            l = m.context.currentTime + k.delay + Math.min(k.duration, o);
            if (Sys.isObj(g)) {
                if (g.finishedAt > l) {
                    continue
                }
                c = m.callbacks[g.duckedBy].funcs.indexOf(g.restoreUsing);
                if (c > -1) {
                    m.callbacks[g.duckedBy].funcs.splice(c, 1)
                }
            }
            m.changePlayingSoundVolume(b, n, k, e);
            j = m.restoreDuckedSound.bind(m, b, n);
            m.setupCallback(j, k, d, e.loop);
            m.duckingSounds[b] = {duckedBy: d, restoreUsing: j, finishedAt: l}
        }
    }, changePlayingSoundVolume: function (c, d, f, b) {
        var g = this, a = g.audioPlaying[c], i = g.context.currentTime + (f.delay || 0),
            h = i + (d.duration || f.duration || 0), j, e;
        Sys.each(a, function (k) {
            j = k.gainNode.gain;
            j.setTargetAtTime(d.value, i, d.attack);
            e = Math.max(j.value, g.duckingRestore[c] || 0);
            if (!b.loop) {
                j.setTargetAtTime(e, h, d.release)
            }
            g.duckingRestore[c] = e
        }, g)
    }, restoreDuckedSound: function (b, a) {
        this.restoreGainValue(b, a);
        this.duckingSounds[b] = undefined
    }, restoreGainValue: function (c, b) {
        var d = this, a = d.audioPlaying[c], e;
        if (!Sys.isDefined(d.duckingRestore[c])) {
            return
        }
        Sys.each(a, function (f) {
            e = f.gainNode.gain;
            e.cancelScheduledValues(d.context.currentTime);
            e.setTargetAtTime(d.duckingRestore[c], d.context.currentTime, b.release)
        }, d)
    }, clipFinished: function (b, c) {
        var a = this.audioPlaying[c].indexOf(b);
        while (a >= 0) {
            this.audioPlaying[c].splice(a, 1);
            a = this.audioPlaying[c].indexOf(b)
        }
    }, stop: function (e, b) {
        var d = this, c, a;
        if (!Sys.isDefined(d.audioPlaying[e])) {
            return
        }
        for (a = 0; a < d.audioPlaying[e].length; a++) {
            c = d.audioPlaying[e][a];
            if (Sys.isDefined(c)) {
                d.stopClip(c, b)
            }
        }
        d.removeFromPlayingList(e);
        if (Sys.isDefined(d.callbacks[e])) {
            clearTimeout(d.callbacks[e].timeout);
            d.callArrayOfCallbacks(e)
        }
    }, stopClip: function (e, c) {
        var d = this, b = Sys.isDefined(c) ? c : e.fadeOut, f = d.context.currentTime, a = f;
        if (b) {
            e.gainNode.gain.exponentialRampToValueAtTime(b.from, f);
            e.gainNode.gain.exponentialRampToValueAtTime(b.to, f + b.time);
            a += b.time
        }
        e.stopped = true;
        e.source.stop(a)
    }, stopNonLooping: function () {
        var b = this, a;
        Sys.iterate(b.audioPlaying, function (d, c) {
            a = [];
            Sys.each(c, function (e) {
                if (e.source.loop) {
                    a.push(e)
                } else {
                    b.stopClip(e)
                }
            });
            b.audioPlaying[d].length = 0;
            b.audioPlaying[d] = a
        })
    }, abort: function () {
        var a = this;
        Sys.iterate(a.audioPlaying, function (b) {
            a.stop(b)
        })
    }, getId: function (a) {
        return a.id || "audioPlayer.noID"
    }, addToPlayingList: function (b, a) {
        if (!Sys.isDefined(this.audioPlaying[b])) {
            this.audioPlaying[b] = []
        }
        this.audioPlaying[b].push(a)
    }, removeFromPlayingList: function (a) {
        this.audioPlaying[a].length = 0
    }, setUpSource: function (g) {
        var i = this, d = i.setUpSourceParams(g), h, c = this.context.currentTime, a, e, b, f;
        if (!Sys.isDefined(d)) {
            return undefined
        }
        a = i.context.createBufferSource();
        a.buffer = d.sourceBuffer;
        e = i.context.createGain();
        a.connect(e);
        e.gain.value = d.gain;
        if (d.fadeIn) {
            h = d.fadeIn;
            e.gain.exponentialRampToValueAtTime(h.from, c);
            e.gain.exponentialRampToValueAtTime(h.to, c + h.time)
        }
        if (d.fadeOut && !d.loop) {
            h = d.fadeOut;
            f = c + d.start + (d.duration - h.time);
            e.gain.exponentialRampToValueAtTime(h.from, f);
            e.gain.exponentialRampToValueAtTime(h.to, f + h.time)
        }
        a.loop = d.loop;
        if (a.loop && Sys.isDefined(d.start)) {
            a.loopStart = d.start;
            a.loopEnd = d.start + d.duration
        }
        if (Sys.isDefined(d.filter)) {
            b = this.filter(d.filter);
            e.connect(b);
            b.connect(i.nodes.mainVolume)
        } else {
            e.connect(i.nodes.mainVolume)
        }
        d = Sys.apply(d, {source: a, gainNode: e, filterNode: b});
        return d
    }, setUpSourceParams: function (f) {
        var i = this, a, e, h, j = 1, g, b, c, d;
        if (!Sys.isDefined(f.name)) {
            return undefined
        }
        a = Sys.isDefined(f.buffer) ? f.buffer : "main";
        e = i.model.readData("clips")[a][f.name];
        h = i.audioBuffers[a];
        if (!Sys.isDefined(e)) {
            return undefined
        }
        if (!Sys.isDefined(h)) {
            return undefined
        }
        if (!Sys.isAudioBuffer(h)) {
            if (Sys.isAudioBuffer(h[f.name])) {
                h = h[f.name]
            } else {
                return undefined
            }
        }
        if (Sys.isDefined(f.volume)) {
            j = f.volume
        } else {
            if (Sys.isDefined(e.volume)) {
                j = e.volume
            }
        }
        g = Sys.isDefined(e.start) ? e.start : 0;
        b = g;
        if (Sys.isDefined(f.offset)) {
            b += f.offset
        }
        c = h.duration - b;
        if (Sys.isDefined(f.duration)) {
            c = Math.min(c, f.duration)
        } else {
            if (Sys.isDefined(e.duration)) {
                c = Math.min(c, e.duration)
            }
        }
        d = {
            sourceBuffer: h,
            delay: Sys.isDefined(f.delay) ? f.delay : 0,
            start: b,
            duration: c,
            clipOffsetFromFileStart: g,
            gain: j,
            loop: f.loop === true,
            fadeIn: Sys.isDefined(f.fadeIn) ? f.fadeIn : false,
            fadeOut: Sys.isDefined(f.fadeOut) ? f.fadeOut : false,
            filter: f.filter,
            ducking: e.duck
        };
        return d
    }, setupCallback: function (h, e, g, a) {
        var d = this, f = (e.delay + e.duration) * 1000, b, c;
        if (!Sys.isDefined(h)) {
            return
        }
        b = function () {
            d.callArrayOfCallbacks(g)
        };
        if (Sys.isObj(d.callbacks[g])) {
            if (Sys.isEmpty(d.callbacks[g].funcs) && !a) {
                d.callbacks[g].timeout = setTimeout(b, f)
            }
            d.callbacks[g].funcs.push(h)
        } else {
            if (!a) {
                c = setTimeout(b, f)
            }
            d.callbacks[g] = {timeout: c, funcs: [h]}
        }
    }, filter: function (a) {
        var b = this.context.createBiquadFilter();
        a.type = a.type || "allpass";
        b.type = Sys.isString(b.type) ? a.type : b[a.type.toUpperCase()];
        if (Sys.isDefined(a.frequency)) {
            b.frequency.value = a.frequency
        }
        if (Sys.isDefined(a.q)) {
            b.Q.value = a.q
        }
        if (Sys.isDefined(a.gain)) {
            b.gain.value = a.q
        }
        return b
    }, createMainNodes: function () {
        var c = this, a = c.context, b;
        b = a.createGain();
        b.gain.value = Services.settingsManager.getSetting("volume");
        c.nodes = {mainVolume: b}
    }, connectMainNodes: function () {
        var b = this, a = b.nodes;
        a.mainVolume.connect(b.context.destination)
    }, loadSounds: function (f) {
        var e = this, c, d, a, g, b;
        f = f || "main";
        c = e.model.readData("files")[f];
        if (Sys.isObj(c)) {
            a = Object.keys(c);
            g = a.length;
            for (b = -1; ++b < g;) {
                d = e.loadSoundResource(f + "/" + a[b], c[a[b]])
            }
        } else {
            d = e.loadSoundResource(f, c)
        }
        if (d && f === "main") {
            e.fakeSound()
        }
    }, loadSoundResource: function (b, a) {
        var c = this;
        if (!c.soundsToLoad.contains(b) && Sys.isDefined(a)) {
            c.soundsToLoad.push(b);
            c.fireEvent("view:loadResource", {
                name: b,
                type: "audioFile",
                url: a,
                successEvent: "notify:resourceLoader.soundLoaded",
                failEvent: "notify:resourceLoader.soundLoadingFailed"
            });
            return true
        }
        c.fireEvent("view:audioLoadError", "No config entry for sound resource", b);
        return false
    }, fakeSound: function () {
        var a = this.context.createOscillator(), b = this.context.createGain();
        a.frequency.value = 440;
        b.gain.value = 0;
        a.connect(b);
        b.connect(this.context.destination);
        a.start(0);
        a.stop(0);
        a.disconnect(0);
        b.disconnect(0)
    }, checkAPICompability: function (c) {
        var g = this, b = g.model.readData("clips"), a = c, f, i = true, d;
        if (Sys.isDefined(b[c])) {
            d = Object.keys(b[c]);
            a = d[d.length - 1]
        }
        f = g.setUpSource({name: a, volume: 0});
        try {
            f.source.start(0, 0);
            f.source.stop(g.context.currentTime)
        } catch (h) {
            i = false
        }
        g.canPlayWithoutDuration = i
    }, onSoundResourceLoaded: function (b, e) {
        var d = this, h = b.split("/"), c, a = b, g = d.audioResources, f = d.audioBuffers;
        if (h.length > 1) {
            c = h[0];
            a = h[1];
            g = g[c];
            f = f[c];
            if (!Sys.isDefined(g)) {
                g = {};
                d.audioResources[c] = g;
                f = {};
                d.audioBuffers[c] = f
            }
        }
        g[a] = e;
        d.context.decodeAudioData(e, function (i) {
            var j = d.soundsToLoad.indexOf(b);
            f[a] = i;
            if (!d.initializedAudio) {
                d.setupEvents();
                d.createMainNodes();
                d.connectMainNodes();
                d.checkAPICompability(a);
                d.initializedAudio = true
            }
            if (j >= 0) {
                d.soundsToLoad.splice(j, 1);
                if (d.soundsToLoad.length === 0) {
                    d.fireEvent("view:soundLoaded")
                }
            }
        }, d.fireEvent.bind(d, "view:audioLoadError", "Failed to decode audio file", b))
    }, decodePreloadedAudio: function () {
        var b = this, a = Resources.readData("preloadedAudio");
        Sys.iterate(a, function (c) {
            b.soundsToLoad.push(c)
        });
        Sys.iterate(a, function (c, d) {
            b.onSoundResourceLoaded(c, d)
        })
    }, callArrayOfCallbacks: function (b) {
        var a = this;
        Sys.each(a.callbacks[b].funcs, function (c) {
            c.call(a)
        });
        a.callbacks[b].funcs = []
    }
};
Core.Audio.AudioPlayerView = Sys.extend(Core.View, Core.Audio.AudioPlayerView, "Core.Audio.AudioPlayerView");
Sys.ns("Core.Audio");
Core.Audio.AudioPlayerEngineView = {
    constructor: function () {
        Core.Audio.AudioPlayerEngineView.superclass.constructor.apply(this, arguments)
    }, init: function (a) {
        var b = this;
        b.model = a.model;
        b.MODULE_NAME = a.name;
        b.initializedAudio = false;
        b.soundsToLoad = []
    }, setVolume: function () {
    }, play: function () {
    }, stop: function () {
    }, duckSounds: function () {
    }, stopNonLooping: function () {
    }, abort: function () {
    }, loadSounds: function (f) {
        var e = this, c, d, a, g, b;
        f = f || "main";
        c = e.model.readData("files")[f];
        if (Sys.isObj(c)) {
            a = Object.keys(c);
            g = a.length;
            for (b = -1; ++b < g;) {
                d = e.loadSoundResource(f + "/" + a[b], c[a[b]])
            }
        } else {
            d = e.loadSoundResource(f, c)
        }
        if (d && f === "main") {
            e.fakeSound()
        }
    }, loadSoundResource: function (b, a) {
        var c = this;
        if (!c.soundsToLoad.contains(b) && Sys.isDefined(a)) {
            c.soundsToLoad.push(b);
            c.fireEvent("view:loadResource", {
                name: b,
                type: "audioFile",
                url: a,
                successEvent: "notify:resourceLoader.soundLoaded",
                failEvent: "notify:resourceLoader.soundLoadingFailed"
            });
            return true
        }
        c.fireEvent("view:audioLoadError", "No config entry for sound resource", b);
        return false
    }, onSoundResourceLoaded: function (h, e) {
        var j = this, d = j.model.readData("clips"), g = h.split("/"), c, k = h, l, a, b, f;
        if (g.length > 1) {
            c = g[0];
            k = g[1]
        }
        Audio.Engine.add(k, e, function () {
            var i = j.soundsToLoad.indexOf(h);
            if (!j.initializedAudio) {
                j.setupEvents();
                j.initializedAudio = true
            }
            if (i >= 0) {
                j.soundsToLoad.splice(i, 1);
                if (j.soundsToLoad.length === 0) {
                    j.fireEvent("view:soundLoaded")
                }
            }
        }, j.fireEvent.bind(j, "view:audioLoadError", "Failed to decode audio file", h));
        if (!Sys.isDefined(c)) {
            c = k;
            l = d[c];
            a = Object.keys(l);
            b = a.length;
            for (f = -1; ++f < b;) {
                k = a[f];
                l[k].source = c;
                Audio.Engine.addClipConfig(k, l[k])
            }
        }
    }, decodePreloadedAudio: function () {
        var b = this, a = Resources.readData("preloadedAudio");
        Sys.iterate(a, function (c) {
            b.soundsToLoad.push(c)
        });
        Sys.iterate(a, function (c, d) {
            b.onSoundResourceLoaded(c, d)
        })
    }, fakeSound: function () {
        Audio.Engine.playSound("nosound", {volume: 0}).stop(0)
    }
};
Core.Audio.AudioPlayerEngineView = Sys.extend(Core.View, Core.Audio.AudioPlayerEngineView, "Core.Audio.AudioPlayerEngineView");
Sys.ns("Core.Audio.Legacy");
Core.Audio.Legacy.LegacyAudioPlayerView = {
    constructor: function () {
        Core.Audio.Legacy.LegacyAudioPlayerView.superclass.constructor.apply(this, arguments);
        this.audioElements = {};
        this.clipsToLoad = [];
        this.callbacks = {}
    }, setupEvents: function () {
        var a = this;
        a.on({"model:audioDisabled": a.abort, "model:audioDisabled:hidden": a.abort})
    }, play: function (e) {
        var d = this, b, a = e.name, g, f;
        e.buffer = e.buffer || "main";
        b = d.audioElements[e.buffer];
        g = d.model.readData("clips")[e.buffer][a];
        if (Sys.isDefined(b) && d.model.isState("audioEnabled")) {
            f = b[e.name];
            if (Sys.isDefined(f)) {
                if (d.currentClip) {
                    d.stopCurrentClip()
                }
                if (!Sys.isDefined(e.volume)) {
                    e.volume = Sys.isDefined(g.volume) ? g.volume : 1
                }
                if (e.loop) {
                    e.loopHandler = function () {
                        f.play()
                    };
                    f.addEventListener("ended", e.loopHandler, false)
                }
                d.currentClip = e;
                f.volume = Services.settingsManager.getSetting("volume") * e.volume;
                d.setupCallback(e.callback, f.duration, e.id, e.loop);
                try {
                    f.play()
                } catch (c) {
                }
            }
        }
    }, stopCurrentClip: function () {
        var c = this.currentClip, b = this.audioElements[c.buffer][c.name];
        try {
            b.currentTime = 0
        } catch (a) {
        }
        b.pause();
        if (c.loop) {
            b.removeEventListener("ended", c.loopHandler, false)
        }
        this.currentClip = undefined;
        if (Sys.isDefined(this.callbacks[c.id])) {
            clearTimeout(this.callbacks[c.id].timeout);
            this.callArrayOfCallbacks(c.id)
        }
    }, stop: function (a) {
        if (Sys.isDefined(this.currentClip) && this.currentClip.id === a) {
            this.stopCurrentClip()
        }
    }, stopNonLooping: function () {
        if (Sys.isDefined(this.currentClip) && !this.currentClip.loop) {
            this.stopCurrentClip()
        }
    }, abort: function () {
        if (Sys.isDefined(this.currentClip)) {
            this.stopCurrentClip()
        }
    }, setVolume: function (a) {
        var b = this.currentClip;
        if (Sys.isDefined(b)) {
            this.audioElements[b.buffer][b.name].volume = a * b.volume
        }
    }, loadSounds: function (c) {
        var b = this, a, d;
        c = c || "main";
        if (!Sys.isObj(b.audioElements[c])) {
            a = b.model.readData("files")[c];
            if (Sys.isDefined(a)) {
                b.audioElements[c] = {};
                Sys.iterate(a, function (e, f) {
                    d = c + ":" + e;
                    b.clipsToLoad.push(d);
                    b.fireEvent("view:loadResource", {
                        name: d,
                        type: "audioElementSource",
                        url: f,
                        successEvent: "notify:resourceLoader.soundLoaded",
                        failEvent: "notify:resourceLoader.soundLoadingFailed"
                    })
                })
            } else {
                b.fireEvent("view:audioLoadError", "No config entry for sound resource", c)
            }
        } else {
            if (b.clipsToLoad.length === 0) {
                b.fireEvent("view:soundLoaded")
            }
        }
    }, onSoundResourceLoaded: function (a, c) {
        var b = this, d = b.clipsToLoad.indexOf(a), e = a.split(":");
        b.audioElements[e[0]][e[1]] = c;
        if (d >= 0) {
            b.clipsToLoad.splice(d, 1);
            if (b.clipsToLoad.length === 0) {
                b.fireEvent("view:soundLoaded")
            }
        }
    }, callArrayOfCallbacks: function (b) {
        var a = this;
        Sys.each(a.callbacks[b].funcs, function (c) {
            c.call(a)
        });
        a.callbacks[b].funcs = []
    }, setupCallback: function (h, f, g, a) {
        var d = this, e = f * 1000, b, c;
        if (!Sys.isDefined(h)) {
            return
        }
        b = function () {
            d.callArrayOfCallbacks(g)
        };
        if (Sys.isObj(d.callbacks[g])) {
            if (Sys.isEmpty(d.callbacks[g].funcs) && !a) {
                d.callbacks[g].timeout = setTimeout(b, e)
            }
            d.callbacks[g].funcs.push(h)
        } else {
            if (!a) {
                c = setTimeout(b, e)
            }
            d.callbacks[g] = {timeout: c, funcs: [h]}
        }
    }
};
Core.Audio.Legacy.LegacyAudioPlayerView = Sys.extend(Core.View, Core.Audio.Legacy.LegacyAudioPlayerView, "Core.Audio.Legacy.LegacyAudioPlayerView");
Sys.ns("Core");
Core.ResourceLoader = {
    constructor: function () {
        Core.ResourceLoader.superclass.constructor.apply(this, arguments)
    }, getDefaultMVCClasses: function () {
        return {
            model: Core.ResourceLoaderModel,
            view: Core.ResourceLoaderView,
            controller: Core.ResourceLoaderController
        }
    }
};
Core.ResourceLoader = Sys.extend(Core.Module, Core.ResourceLoader, "Core.ResourceLoader");
Sys.ns("Core");
Core.ResourceLoaderController = {
    constructor: function () {
        Core.ResourceLoaderController.superclass.constructor.apply(this, arguments);
        this.requestedResources = {}
    }, setupEvents: function () {
        var a = this;
        Core.ResourceLoaderController.superclass.setupEvents.call(a);
        a.on({
            "request:resourceLoader.loadResource": a.loadResource,
            "request:resourceLoader.removeLoadAnimation": a.removeLoadAnimation
        })
    }, removeLoadAnimation: function () {
        this.model.setState("clearAnimations")
    }, loadResource: function (c) {
        var b = this, a = b.requestedResources[c.url];
        if (Sys.isObj(a)) {
            if (a.status === "fetched" && c.successEvent) {
                b.fireEvent(c.successEvent, c.name, a.data)
            } else {
                if (a.status === "fetching") {
                    a.requesters.push(c)
                }
            }
        } else {
            if (c.showLoadAnimation) {
                b.model.setState("showLoadAnimation")
            }
            b.requestedResources[c.url] = {status: "fetching", requesters: [c]};
            switch (c.type) {
                case"audioFile":
                    b.fetchAudioFile(c);
                    break;
                case"audioElementSource":
                    b.fetchAudioElementSource(c);
                    break;
                case"JSON":
                    b.fetchJSON(c);
                    break;
                default:
                    b.fetchGenericResource(c)
            }
        }
    }, fetchAudioFile: function (c) {
        var b = this, a = Sys.utils.httpGet({url: c.url, responseType: "arraybuffer"});
        a.fail(b.failedToLoadResource.bind(b, c)).then(function (d) {
            b.fetchedResource(c, d.response)
        })
    }, fetchAudioElementSource: function (c) {
        var b = this, d = document.createElement("audio"), a = Sys.utils.httpGet({url: c.url});
        a.fail(b.failedToLoadResource.bind(b, c)).then(function () {
            d.src = c.url;
            d.load();
            b.fetchedResource(c, d)
        })
    }, fetchJSON: function (c) {
        var b = this, a = Sys.utils.httpGet({url: c.url});
        a.fail(b.failedToLoadResource.bind(b, c)).then(function (d) {
            b.fetchedResource(c, d.responseText)
        })
    }, fetchGenericResource: function (c) {
        var b = this, a = Sys.utils.httpGet({url: c.url});
        a.fail(b.failedToLoadResource.bind(b, c)).then(function (d) {
            b.fetchedResource(c, d)
        })
    }, failedToLoadResource: function (c) {
        var b = this, a = this.requestedResources[c.url].requesters;
        delete this.requestedResources[c.url];
        Sys.each(a, function (d) {
            if (Sys.isDefined(d.failEvent)) {
                b.fireEvent(d.failEvent, c.name)
            }
        })
    }, fetchedResource: function (d, c) {
        var a = this, b = a.requestedResources[d.url];
        b.status = "fetched";
        b.data = c;
        Sys.each(b.requesters, function (e) {
            if (Sys.isDefined(e.successEvent)) {
                a.fireEvent(e.successEvent, d.name, c)
            }
        });
        b.requesters = []
    }
};
Core.ResourceLoaderController = Sys.extend(Core.Controller, Core.ResourceLoaderController, "Core.ResourceLoaderController");
Sys.ns("Core");
Core.ResourceLoaderModel = {
    constructor: function () {
        Core.ResourceLoaderModel.superclass.constructor.apply(this, arguments)
    }, init: function (a) {
        var b = Resources.readData("gameServerInitResponse");
        Core.ResourceLoaderModel.superclass.init.call(this, a);
        this.storeData("isRestore", b.restore)
    }
};
Core.ResourceLoaderModel = Sys.extend(Core.Model, Core.ResourceLoaderModel, "Core.ResourceLoaderModel");
Sys.ns("Core");
Core.ResourceLoaderView = {
    SPINNER: {
        width: 132,
        height: 130,
        sprite: "loadingAnimation",
        frameWidth: 132,
        frameHeight: 130,
        totalSpriteWidth: 1188,
        duration: 1000,
        endFrame: 8
    },
    FADE: {
        RESTORE: {startOpacity: 1, endOpacity: 1, duration: 100},
        STANDARD: {startOpacity: 0, endOpacity: 0.2, duration: 100}
    },
    constructor: function () {
        Core.ResourceLoaderView.superclass.constructor.apply(this, arguments)
    },
    init: function (a) {
        var b = this;
        Core.ResourceLoaderView.superclass.init.call(b, a);
        b.loaderList = new Animation.CanvasAnimationList({});
        b.fadeList = new Animation.CanvasAnimationList({});
        b.bonusGameName = "";
        b.loading = Services.languageManager.getText(Language.Keys.loading);
        b.loaderItem = b.createLoadItem();
        b.fadeItem = b.createFadeItem();
        b.loaderList.add(b.loaderItem)
    },
    setupEvents: function () {
        var a = this;
        a.on({
            "model:showLoadAnimation": a.showLoadAnimation,
            "model:hideLoadAnimation": a.hideLoadAnimation,
            "model:clearAnimations": a.removeAnimations
        })
    },
    createFadeItem: function () {
        var b = this.getLayeringValues(), a = this.FADE.STANDARD;
        return new Animation.CanvasAnimationItem({
            fullScreen: true,
            depth: b.fade,
            opacity: 0,
            executeBefore: function (c) {
                var d = this;
                c.fillStyle = "rgb(0,0,0)";
                c.fillRect(d.pivot.x, d.pivot.y, d.width, d.height)
            },
            operations: {
                fade: [{time: 0, value: a.startOpacity}, {
                    time: a.duration,
                    value: a.endOpacity
                }, {time: a.duration + 1, value: a.endOpacity, goTo: 1}]
            }
        })
    },
    createLoadItem: function () {
        var a = this.SPINNER, c = this.getLayeringValues(), b = Environment.getStageResolution();
        return new Animation.CanvasAnimationItem({
            left: Math.round((b.width - a.width) / 2),
            top: Math.round((b.height - a.height) / 2),
            width: a.width,
            height: a.height,
            frameWidth: a.frameWidth,
            frameHeight: a.frameHeight,
            totalSpriteWidth: a.totalSpriteWidth,
            image: a.sprite,
            spriteArray: Game.stage.view.animationManager.getSpriteSequence(a.sprite),
            depth: c.spinner,
            operations: {sprite: [{time: 0, value: 0}, {time: a.duration, value: a.endFrame, goTo: 0}]}
        })
    },
    showLoadAnimation: function () {
        var c = this, d = c.model.readData("isRestore"), a = c.fadeItem.prop.operations.fade,
            b = (d) ? c.FADE.RESTORE : c.FADE.STANDARD;
        c.loaderItem.restore();
        c.fadeItem.restore();
        a[0].value = b.startOpacity;
        a[1].value = b.duration;
        a[1].value = b.endOpacity;
        a[2].value = b.duration + 1;
        a[2].value = b.endOpacity;
        c.bonusGameName = "";
        c.fadeList.add(c.fadeItem);
        Game.stage.view.addToRenderLoop(c.loaderList);
        Game.stage.view.addToRenderLoop(c.fadeList);
        c.isRestore = d
    },
    hideLoadAnimation: function () {
        Game.stage.view.removeFromRenderLoop(this.loaderList, "base");
        if (this.isRestore) {
            this.clearFade()
        }
    },
    clearFade: function () {
        this.fadeList.items = [];
        Game.stage.view.removeFromRenderLoop(this.fadeList, "base")
    },
    removeAnimations: function () {
        Game.stage.view.removeFromRenderLoop(this.loaderList, "base");
        this.clearFade()
    },
    getLayeringValues: function () {
        return Layering.Game.ResourceLoader
    }
};
Core.ResourceLoaderView = Sys.extend(Core.View, Core.ResourceLoaderView, "Core.ResourceLoaderView");
Sys.ns("Core");
Core.KeyboardManager = {
    constructor: function () {
        Core.KeyboardManager.superclass.constructor.apply(this, arguments)
    }, getMixinDependencies: function () {
        return [{userInput: {inputEvents: ["keyUp", "keyDown"], listenToUserInput: true}}, "properties"]
    }, getDefaultMVCClasses: function () {
        return {model: Core.KeyboardManagerModel, controller: Core.KeyboardManagerController}
    }
};
Core.KeyboardManager = Sys.extend(Core.Module, Core.KeyboardManager, "Core.KeyboardManager");
Sys.ns("Core");
Core.KeyboardManagerController = {
    constructor: function () {
        Core.KeyboardManagerController.superclass.constructor.apply(this, arguments)
    }, setupEvents: function () {
        var a = this;
        a.on({
            "notify:stateHandler.enteringStoppedState": a.model.storeData.bind(a.model, "quickStopAvailable", false),
            "notify:stateHandler.enteringSpinningState": a.model.storeData.bind(a.model, "quickStopAvailable", true)
        })
    }, onUserInputKeyDown: function (b, a) {
        this.handleUserInput(a.keyCode, "down");
        this.model.storeData("currentState", "down")
    }, onUserInputKeyUp: function (b, a) {
        this.handleUserInput(a.keyCode, "up");
        this.model.storeData("currentKey", "");
        this.model.storeData("currentState", "up")
    }, handleUserInput: function (f, e) {
        var d = this, b = d.model, c = b.getKey(f),
            a = (b.readData("currentKey") !== f || b.readData("currentState") !== e);
        if (!b.hasProperty("disabled") && a && Sys.isDefined(c) && c.triggerOnState.contains(e)) {
            b.storeData("currentKey", f);
            d[c.action](e)
        }
    }, onSpaceBarPressed: function (b) {
        var a = this;
        if (Services.settingsManager.getSetting("spacebarToSpin")) {
            if (b === "down") {
                window.onkeydown = function (c) {
                    return c.keyCode !== 32
                };
                this.fireEvent("request:spinButton.pressed")
            } else {
                if (b === "up") {
                    a.fireEvent("request:spinButton.released");
                    a.fireEvent("request:abortPresentation");
                    if (a.model.readData("quickStopAvailable")) {
                        a.fireEvent("request:quickStopper.quickStop")
                    }
                }
            }
        }
    }
};
Core.KeyboardManagerController = Sys.extend(Core.Controller, Core.KeyboardManagerController, "Core.KeyboardManagerController");
Sys.ns("Core");
Core.KeyboardManagerModel = {
    KEY_MAP: {32: {action: "onSpaceBarPressed", triggerOnState: ["down", "up"]}},
    constructor: function () {
        Core.KeyboardManagerModel.superclass.constructor.apply(this, arguments)
    },
    getKey: function (a) {
        return this.KEY_MAP[a]
    }
};
Core.KeyboardManagerModel = Sys.extend(Core.Model, Core.KeyboardManagerModel, "Core.KeyboardManagerModel");
Sys.ns("Interface");
Interface.Keyboard = {
    constructor: function () {
        Interface.Keyboard.superclass.constructor.apply(this, arguments)
    }, getMixinDependencies: function () {
        return ["orientation", {userInput: {listenToUserInput: true}}]
    }, getDefaultMVCClasses: function () {
        return {model: Core.Model, controller: Interface.KeyboardController, view: Interface.KeyboardView}
    }
};
Interface.Keyboard = Sys.extend(Core.Module, Interface.Keyboard, "Interface.Keyboard");
Sys.ns("Interface");
Interface.KeyboardController = {
    MAX_LENGTH: 8, constructor: function () {
        Interface.KeyboardController.superclass.constructor.apply(this, arguments)
    }, setupEvents: function () {
        var a = this;
        a.on({
            "request:keyboard.open": a.open,
            "request:keyboard.close": a.close,
            "request:keyboard.cancel": a.cancel,
            "view:ok": a.onOkClicked,
            "view:cancel": a.onCancelClicked,
            "view:back": a.onBackKeyClicked,
            "view:keyClicked": a.onKeyClicked
        })
    }, open: function (a) {
        var b = this;
        if (b.model.readData("isOpen") === true) {
            return
        }
        b.fireEvent("request:userInputManager.activateExclusivity", b.MODULE_NAME);
        a = a || {};
        if (a.formatFunction && Sys.isFunc(a.formatFunction)) {
            b.formatFunc = a.formatFunction
        }
        b.model.storeData("info", Sys.isDefined(a.info) ? a.info : "");
        b.model.storeData("label", Sys.isDefined(a.label) ? a.label : "");
        b.model.storeData("isOpen", true);
        b.model.storeData("minValue", a.minValue);
        b.updateModel("0");
        b.okCallback = a.okCallback;
        b.cancelCallback = a.cancelCallback;
        b.view.show()
    }, close: function () {
        var a = this;
        a.fireEvent("request:userInputManager.deactivateExclusivity", a.MODULE_NAME);
        a.view.hide();
        a.model.storeData("isOpen", false)
    }, cancel: function () {
        if (this.model.readData("isOpen")) {
            this.onCancelClicked()
        }
    }, onOkClicked: function () {
        var a = this;
        if (Sys.isFunc(a.okCallback)) {
            a.okCallback({
                formattedInput: a.model.readData("formattedInputField"),
                input: a.model.readData("inputField"),
                value: parseInt(a.model.readData("inputField"), 10),
                cents: parseInt(a.model.readData("inputField"), 10) * 100
            })
        }
        a.close()
    }, onCancelClicked: function () {
        var a = this;
        a.updateModel("0");
        if (Sys.isFunc(a.cancelCallback)) {
            a.cancelCallback({
                formattedInput: a.model.readData("formattedInputField"),
                input: a.model.readData("inputField"),
                value: parseInt(a.model.readData("inputField"), 10),
                cents: parseInt(a.model.readData("inputField"), 10) * 100
            })
        }
        a.close()
    }, onKeyClicked: function (b) {
        var c = this, a = c.model.readData("inputField");
        if (a.length < c.MAX_LENGTH) {
            a = Sys.utils.toInt(a) + b
        }
        c.updateModel(a);
        c.view.update()
    }, onBackKeyClicked: function () {
        var b = this, a = b.model.readData("inputField");
        a = a.substring(0, a.length - 1);
        a = a.length === 0 ? "0" : a;
        b.updateModel(a);
        b.view.update()
    }, updateModel: function (a) {
        var c = this, b = c.model;
        b.storeData("formattedInputField", c.formatFunc(a));
        b.storeData("inputField", a);
        b.storeData("value", parseInt(a, 10));
        b.storeData("cents", parseInt(a, 10) * 100);
        b.storeData("isOkButtonEnabled", c.isInputValid())
    }, formatFunc: function (a) {
        return Services.moneyManager.formatMoneyCurrencySign(Sys.utils.toInt(a) * 100, undefined, 0)
    }, isInputValid: function () {
        var b = this, c = b.model.readData("minValue"), a = b.model.readData("cents");
        return !Sys.isDefined(c) || (c > 0 && c <= a)
    }
};
Interface.KeyboardController = Sys.extend(Core.Controller, Interface.KeyboardController, "Interface.KeyboardController");
Sys.ns("Interface");
Interface.KeyboardView = {
    RENDER_TARGET: "gameWrapper", KEYPAD: "keyboardKeypad", constructor: function () {
        Interface.KeyboardView.superclass.constructor.apply(this, arguments)
    }, init: function () {
        var a = this;
        Interface.KeyboardView.superclass.init.apply(this, arguments);
        a.container = new Sys.Element({
            id: "keyboard",
            tag: "div",
            cls: "interface-keyboard_container",
            renderTo: a.RENDER_TARGET,
            style: "display:none;"
        });
        a.info = new Sys.Element({
            id: "keyboardInfo",
            tag: "div",
            cls: "info",
            renderTo: "keyboard",
            innerHTML: a.model.readData("info")
        });
        a.label = new Sys.Element({
            id: "keyboardFieldContainerLabel",
            tag: "div",
            cls: "label",
            renderTo: "keyboard",
            innerHTML: a.model.readData("label")
        });
        a.fieldContainer = new Sys.Element({
            id: "keyboardFieldContainer",
            tag: "div",
            cls: "fieldContainer",
            renderTo: "keyboard"
        });
        a.value = new Sys.Element({
            id: "",
            tag: "div",
            cls: "value",
            renderTo: "keyboardFieldContainer",
            innerHTML: a.model.readData("formattedInputField")
        });
        a.keypad = new Sys.Element({id: a.KEYPAD, tag: "div", cls: "keypad digits", renderTo: "keyboard"});
        a.initKeyboard()
    }, initKeyboard: function () {
        var d = this, c, a = ["1", "2", "3", "4", "5", "6", "7", "8", "9", "0"], b;
        d.keys = [];
        for (c = 0; c < a.length; c++) {
            b = new Interface.utils.DOMButton({
                id: "keypad_num_" + a[c],
                textContent: a[c],
                clickCallback: d.fireEvent.bind(d, "view:keyClicked", a[c]),
                renderTo: d.KEYPAD,
                baseCSS: "button num_" + a[c],
                exclusiveUserInput: d.MODULE_NAME
            });
            d.keys.push(b)
        }
        d.cancelButton = new Interface.utils.DOMButton({
            id: "keypad_cancel",
            textContent: "",
            clickCallback: d.fireEvent.bind(d, "view:cancel"),
            renderTo: d.KEYPAD,
            baseCSS: "button cancelButton ",
            exclusiveUserInput: d.MODULE_NAME
        });
        d.okButton = new Interface.utils.DOMButton({
            id: "keypad_ok",
            textContent: "",
            clickCallback: d.fireEvent.bind(d, "view:ok"),
            renderTo: d.KEYPAD,
            baseCSS: "button okButton",
            exclusiveUserInput: d.MODULE_NAME
        });
        d.backButton = new Interface.utils.DOMButton({
            textContent: "",
            clickCallback: d.fireEvent.bind(d, "view:back"),
            renderTo: "keyboardFieldContainer",
            baseCSS: "button removeDigit",
            exclusiveUserInput: d.MODULE_NAME
        })
    }, show: function () {
        this.update();
        this.container.el.style.display = "block"
    }, hide: function () {
        this.container.el.style.display = "none"
    }, adaptToOrientation: function () {
        this.setHeight()
    }, setHeight: function () {
        if (Services.orientation.isPortrait()) {
            this.container.el.style.height = (Environment.getGameHeight() + Environment.getSpaceBelowGame()) + "px"
        } else {
            this.container.el.style.height = Environment.getGameHeight() + "px"
        }
    }, update: function () {
        var c = this, b = c.model, a = b.readData("isOkButtonEnabled");
        c.label.getEl().innerHTML = b.readData("label");
        c.info.getEl().innerHTML = b.readData("info");
        c.value.getEl().innerHTML = b.readData("formattedInputField");
        if (a) {
            c.okButton.enable()
        } else {
            c.okButton.disable()
        }
    }
};
Interface.KeyboardView = Sys.extend(Core.View, Interface.KeyboardView, "Interface.KeyboardView");
Sys.ns("Game");
Game.Stage = {
    constructor: function () {
        Game.Stage.superclass.constructor.apply(this, arguments)
    }, getStateChanges: function () {
        return {setupGame: {waitEvents: ["notify:animationManager.allImagesLoaded"]}}
    }, getDefaultMVCClasses: function () {
        return {model: Game.StageModel, view: Game.StageView, controller: Game.StageController}
    }
};
Game.Stage = Sys.extend(Core.Module, Game.Stage, "Game.Stage");
Sys.ns("Game");
Game.StageController = {
    constructor: function () {
        Game.StageController.superclass.constructor.apply(this, arguments)
    }, setupEvents: function () {
        var a = this;
        a.on({
            "notify:stateHandler.enteringBeforeLoaderCloseState": a.startRenderLoop,
            "request:stage.setupImages": a.onSetupImages,
            "request:stage.elevate": a.view.elevate.bind(a.view),
            "request:stage.lower": a.view.lower.bind(a.view),
            "request:stage.pauseAnimation": a.view.pauseAnimation.bind(a.view),
            "notify:scaling.gameSizeChanged": a.onGameSizeChanged
        })
    }, startRenderLoop: function () {
        this.model.setState("playRenderLoop")
    }, switchScenes: function (a) {
        this.model.switchScenes(a)
    }, getGameContainer: function () {
        return this.view.getGameContainer()
    }, onSetupImages: function (a) {
        this.view.setupImages(a)
    }, onGameSizeChanged: function () {
        if (Environment.allowsCustomCanvasSize()) {
            this.view.updateActiveRenderContextSize()
        }
    }, getOrientationSpecificImage: function (a) {
        return this.view.getOrientationSpecificImage(a)
    }
};
Game.StageController = Sys.extend(Core.Controller, Game.StageController, "Game.StageController");
Sys.ns("Game");
Game.StageModel = {
    constructor: function () {
        Game.StageModel.superclass.constructor.apply(this, arguments)
    }, setupData: function () {
        var b = this, a = Resources.readData("config");
        b.storeData("images", Resources.readData("images"));
        b.storeData("sprites", a.sprites);
        b.storeData("reelConfig", a.reel);
        b.storeData("reelGroups", a.reelGroups);
        b.storeData("scenes", a.scenes);
        b.switchScenes("base")
    }, getSymbolConfiguration: function (c, a) {
        var b = this;
        if (Sys.isDefined(b.readData("reelGroups"))) {
            return b.getNewSymbolConfiguration(c, a)
        } else {
            if (Sys.isDefined(b.readData("reelConfig"))) {
                return b.getLegacySymbolConfiguration(c, a)
            }
        }
        return undefined
    }, getCurrentReelGroupConfiguration: function () {
        var a = this;
        if (Sys.isDefined(a.readData("reelGroups"))) {
            return a.getCompatibleReelGroupConfiguration()
        } else {
            if (Sys.isDefined(a.readData("reelConfig"))) {
                return a.readData("reelConfig")
            }
        }
        return undefined
    }, getCompatibleReelGroupConfiguration: function () {
        var b = this.readData("reelGroups")["default"], m = this.readData("reelConfig") || {}, h = m.reelFrame || {},
            n = this.getReelLayout(b.reelLayouts) || b.reelLayout, l = n.config || n.standard, c = {}, d = l.left || 0,
            o = l.top || 0, a = 0, f = l.numberOfOutcomeSymbols || 0, e = b.numberOfReels, g = l.symbolWidths.standard,
            p = l.symbolHeights.standard, j, k;
        c = Sys.applyProperties(c, l);
        c.symbolWidth = Sys.isNumber(m.symbolWidth) ? m.symbolWidth : g;
        c.symbolHeight = Sys.isNumber(m.symbolHeight) ? m.symbolHeight : p;
        c.symbolCols = Sys.isNumber(m.symbolCols) ? m.symbolCols : b.numberOfReels;
        for (k = -1; ++k < e;) {
            j = n[k];
            if (k > 0) {
                d = Math.min(d, Sys.isNumber(j.left) ? j.left : d);
                o = Math.min(o, Sys.isNumber(j.top) ? j.top : o);
                a = Math.max(a, Sys.isNumber(j.left) ? j.left : d)
            } else {
                d = Sys.isNumber(j.left) ? j.left : d;
                o = Sys.isNumber(j.top) ? j.top : o;
                a = d
            }
            f = Math.max(f, (j.numberOfOutcomeSymbols || 0))
        }
        a = a + g - d;
        c.symbolRows = Sys.isNumber(m.symbolRows) ? m.symbolRows : f;
        c.reelFrame = {
            left: Sys.isNumber(h.left) ? h.left : d,
            top: Sys.isNumber(h.top) ? h.top : o,
            width: Sys.isNumber(h.width) ? h.width : a,
            height: Sys.isNumber(h.height) ? h.height : f * p
        };
        c.reelAreaTop = Sys.isNumber(m.reelAreaTop) ? m.reelAreaTop : o;
        c.reelAreaLeft = Sys.isNumber(m.reelAreaLeft) ? m.reelAreaLeft : d;
        c.reelSpacing = Sys.isNumber(m.reelSpacing) ? m.reelSpacing : Math.round((a - (g * e)) / (e - 1));
        c.symbolSpacing = Sys.isNumber(m.symbolSpacing) ? m.symbolSpacing : Math.round(l.symbolCenterToCenter - p);
        return c
    }, getReelLayout: function (a) {
        var b;
        if (!Sys.isDefined(a)) {
            return null
        }
        b = Environment.getConfigForCurrentDeviceState(a);
        if (b === null) {
        }
        return b
    }, getLegacySymbolConfiguration: function (e, b) {
        var d = this.readData("reelConfig"), c = d.symbolWidth, a = d.symbolHeight;
        return {
            width: c,
            height: a,
            top: d.reelAreaTop + (b * (a + d.symbolSpacing)),
            left: d.reelAreaLeft + (e * (c + d.reelSpacing))
        }
    }, getNewSymbolConfiguration: function (f, c) {
        var g = this.readData("reelGroups")["default"], d = this.getReelLayout(g.reelLayouts) || g.reelLayout,
            e = d[f.toString()], h = d.config || d.standard, b = e.top || h.top, a = h.outcomeOffset || 0;
        return {
            width: h.symbolWidths.standard,
            height: h.symbolHeights.standard,
            top: b + a + (c * h.symbolCenterToCenter),
            left: e.left
        }
    }, switchScenes: function (a) {
        this.storeData("currentScene", a);
        this.setState("switchScene", a)
    }
};
Game.StageModel = Sys.extend(Core.Model, Game.StageModel, "Game.StageModel");
Sys.ns("Game");
Game.StageView = {
    constructor: function () {
        Game.StageView.superclass.constructor.apply(this, arguments)
    }, init: function (a) {
        this.model = a.model;
        this.setupAnimationManager();
        this.setupEvents()
    }, setupAnimationManager: function () {
        var b = this, a = Environment.getResolution();
        b.animationManager = new Animation.CanvasAnimationManager({
            parent: document.getElementById("gameElements"),
            images: b.model.readData("images"),
            sprites: b.model.readData("sprites"),
            top: "0px",
            left: "0px",
            height: a.height,
            width: a.width,
            scenes: b.model.readData("scenes")
        })
    }, setupEvents: function () {
        var a = this;
        a.on({"model:switchScene": a.switchScenes, "model:playRenderLoop": a.playRenderLoop})
    }, updateActiveRenderContextSize: function () {
        var b = Environment.getResolution(), a = {width: b.width, height: b.height};
        this.animationManager.updateActiveRenderContextSize(a)
    }, getOrientationSpecificImage: function (c) {
        var b = Environment.getViewportOrientation(), a = c + "_" + b.toLowerCase(),
            d = this.animationManager.images[a];
        if (Environment.allowsCustomCanvasSize() && Sys.isDefined(d)) {
            return a
        }
        return c
    }, pauseAnimation: function () {
        this.animationManager.pauseAnimation()
    }, switchScenes: function (a) {
        this.animationManager.switchScenes(a)
    }, clearScene: function (a) {
        this.animationManager.clearScene(a)
    }, playRenderLoop: function () {
        var a = this.model.readData("currentScene");
        this.animationManager.start(a)
    }, addToRenderLoop: function (a, b) {
        this.animationManager.addToRenderLoop(a, b)
    }, removeFromRenderLoop: function (a, b) {
        this.animationManager.removeList(a, b)
    }, addImages: function (a) {
        this.animationManager.addImages(a)
    }, setupImages: function (a) {
        this.animationManager.setupImages(a[0], a[1])
    }, getGameContainer: function () {
        return document.getElementById("gameElements")
    }, elevate: function () {
        this.getGameContainer().classList.add("elevated")
    }, lower: function () {
        this.getGameContainer().className = this.getGameContainer().className.replace(/\belevated\b/, "")
    }
};
Game.StageView = Sys.extend(Core.View, Game.StageView, "Game.StageView");
Sys.ns("Game.Slots");
Game.Slots.QuickStopper = {
    constructor: function () {
        Game.Slots.QuickStopper.superclass.constructor.apply(this, arguments)
    }, getMixinDependencies: function () {
        return ["userInput", "animation", "trigger"]
    }, getDefaultMVCClasses: function () {
        return {
            model: Game.Slots.QuickStopperModel,
            view: Game.Slots.QuickStopperView,
            controller: Game.Slots.QuickStopperController
        }
    }
};
Game.Slots.QuickStopper = Sys.extend(Core.Module, Game.Slots.QuickStopper, "Game.Slots.QuickStopper");
Sys.ns("Game.Slots.Slots");
Game.Slots.QuickStopperController = {
    constructor: function () {
        Game.Slots.QuickStopperController.superclass.constructor.apply(this, arguments)
    }, setupEvents: function () {
        var a = this;
        a.on({
            "request:quickStopper.disableInMode": a.disableInMode,
            "request:quickStopper.enableInMode": a.enableInMode,
            "request:quickStopper.quickStop": a.performQuickStop,
            "notify:spin.spinAnimationStarted": a.spinStarted,
            "notify:spin.spinAnimationComplete": a.spinStopped,
            "notify:spinButton.clicked": a.performQuickStop,
            "notify:spinButton.clickedWhileHidden": a.performQuickStop,
            "notify:scaling.gameSizeChanged": a.onGameSizeChanged
        })
    }, onGameSizeChanged: function () {
        if (Sys.isFunc(this.view.refresh)) {
            this.view.refresh()
        }
    }, registerTriggers: function () {
        Services.trigger.registerTrigger("notify:quickStopper.quickStop", this, "When a quick stop is performed.")
    }, onUserInputStart: function (a) {
        if (Sys.UserInputUtils.isCoordinateTarget(Game.stage.getGameContainer(), a)) {
            this.performQuickStop()
        }
    }, spinStarted: function () {
        this.startListeningToUserInput();
        this.model.setState("spinning")
    }, spinStopped: function () {
        var a = this;
        a.stopListeningToUserInput();
        a.model.setState("stopped");
        a.fireEvent("request:spinButton.enable", a.MODULE_NAME)
    }, disableInMode: function (a) {
        this.model.setDisabledMode(a)
    }, enableInMode: function (a) {
        this.model.removeDisabledMode(a)
    }, performQuickStop: function () {
        var a = this;
        if (a.model.canQuickStop()) {
            a.model.setState("quickStop");
            a.fireEvent("notify:quickStopper.quickStop");
            a.fireEvent("request:audioPlayer.play", {name: "quickStop"});
            a.fireEvent("request:spinButton.disable", a.MODULE_NAME)
        }
    }
};
Game.Slots.QuickStopperController = Sys.extend(Core.Controller, Game.Slots.QuickStopperController, "Game.Slots.QuickStopperController");
Sys.ns("Game.Slots.Slots");
Game.Slots.QuickStopperModel = {
    constructor: function () {
        Game.Slots.QuickStopperModel.superclass.constructor.apply(this, arguments)
    }, setupData: function () {
        this.storeLayout();
        this.storeData("disabledInModes", [])
    }, canQuickStop: function () {
        return this.isState("spinning") && !this.isInDisabledMode()
    }, storeLayout: function () {
        var b = Game.stage.model.getCurrentReelGroupConfiguration(),
            a = b.symbolWidth * b.symbolCols + b.reelSpacing * (b.symbolCols - 1);
        return this.storeData("layout", {
            width: a,
            height: b.visibleLength,
            top: b.reelAreaTop,
            left: b.reelAreaLeft,
            depth: Layering.Game.Slots.QuickStop.flash
        })
    }, isInDisabledMode: function () {
        return this.readData("disabledInModes").length > 0
    }, setDisabledMode: function (c) {
        var b = this, a = b.readData("disabledInModes");
        if (a.indexOf(c) === -1) {
            a.push(c);
            b.storeData("disabledInModes", a)
        } else {
        }
    }, removeDisabledMode: function (d) {
        var c = this, b = c.readData("disabledInModes"), a = b.indexOf(d);
        if (a > -1) {
            b.splice(a, 1);
            c.storeData("disabledInModes", b)
        } else {
        }
    }
};
Game.Slots.QuickStopperModel = Sys.extend(Core.Model, Game.Slots.QuickStopperModel, "Game.Slots.QuickStopperModel");
Sys.ns("Game.Slots");
Game.Slots.QuickStopperView = {
    constructor: function () {
        Game.Slots.QuickStopperView.superclass.constructor.apply(this, arguments)
    }, setupEvents: function () {
        this.on({"model:quickStop": this.quickStop})
    }, initAnimations: function () {
        var b = this, a = b.model.readData("layout");
        b.animationList = new Animation.CanvasAnimationList();
        b.item = new Animation.CanvasAnimationItem({
            top: a.top,
            left: a.left,
            width: a.width,
            height: a.height,
            depth: a.depth,
            executeBefore: function (c) {
                c.fillStyle = "#FFFFFF";
                c.fillRect(this.pivot.x, this.pivot.y, this.width, this.height)
            },
            operations: {fade: [{time: 0, value: 0}, {time: 100, value: 0.2}, {time: 200, value: 0}]}
        });
        b.animationList.add(b.item);
        Game.stage.view.addToRenderLoop(b.animationList);
        b.animationList.stop()
    }, refresh: function () {
        var b, a = this.item;
        if (Animation.utils.isAnimationItem(a)) {
            b = this.model.storeLayout();
            a.setLeft(b.left);
            a.setTop(b.top);
            a.setWidth(b.width);
            a.setHeight(b.height)
        }
    }, quickStop: function () {
        this.animationList.restore();
        this.animationList.play()
    }
};
Game.Slots.QuickStopperView = Sys.extend(Core.View, Game.Slots.QuickStopperView, "Game.Slots.QuickStopperView");
Sys.ns("Game");
Game.BackgroundController = {
    constructor: function () {
        Game.BackgroundController.superclass.constructor.apply(this, arguments)
    }, setupEvents: function () {
        var a = this;
        a.on({
            "request:background.changeImage": a.changeImage,
            "request:background.restoreImage": a.restoreImage,
            "notify:scaling.gameSizeChanged": a.onGameSizeChanged
        })
    }, changeImage: function (a) {
        this.view.changeImage(a)
    }, restoreImage: function () {
        this.view.restoreImage()
    }, onGameSizeChanged: function () {
        if (Sys.isFunc(this.view.refresh)) {
            this.view.refresh()
        }
    }
};
Game.BackgroundController = Sys.extend(Core.Controller, Game.BackgroundController, "Game.BackgroundController");
Sys.ns("Game");
Game.BackgroundView = {
    BACKGROUND_IMAGE: "background", constructor: function () {
        Game.BackgroundView.superclass.constructor.apply(this, arguments)
    }, changeImage: function (b) {
        var a = Resources.readData("animationImages");
        if ((Sys.isString(b) && Sys.isDefined(a[b])) || Sys.isObj(b)) {
            this.currentImage = b;
            this.item.setImage(Game.stage.getOrientationSpecificImage(b))
        }
    }, restoreImage: function () {
        this.currentImage = this.BACKGROUND_IMAGE;
        this.item.setImage(Game.stage.getOrientationSpecificImage(this.currentImage))
    }, refresh: function () {
        var a = Environment.getStageResolution();
        if (Animation.utils.isAnimationItem(this.item)) {
            this.item.setImage(Game.stage.getOrientationSpecificImage(this.currentImage));
            this.item.setWidth(a.width);
            this.item.setHeight(a.height)
        }
    }, initAnimations: function () {
        var b = this, c = new Animation.CanvasAnimationList({}), a = new Animation.CanvasAnimationItem({
            fullScreen: true,
            depth: Layering.Game.Background.image,
            image: Game.stage.getOrientationSpecificImage(b.BACKGROUND_IMAGE)
        });
        c.add(a);
        b.list = c;
        b.item = a;
        b.currentImage = b.BACKGROUND_IMAGE;
        Game.stage.view.addToRenderLoop(c)
    }
};
Game.BackgroundView = Sys.extend(Core.View, Game.BackgroundView, "Game.BackgroundView");
Sys.ns("Core");
Core.Slots.BufferedSpin = {
    constructor: function () {
        Core.Slots.BufferedSpin.superclass.constructor.apply(this, arguments)
    }, getStateChanges: function () {
        var a = this.model;
        return {
            idle: {
                queue: [function (b) {
                    b.stateHandler.pushState(b.states.validateSpin);
                    b.stateHandler.pushState(b.states.spinning)
                }], waitEvents: ["notify:spin.roundStart"]
            }, validateSpin: {
                state: {
                    name: "ValidateSpin", execute: function (b) {
                        if (a.readData("isValidServerResponse")) {
                            b.stateHandler.pushState(b.states.stopped);
                            b.stateHandler.pushState(b.states.stopping);
                            b.stateHandler.pushState(b.states.beforeStopping)
                        } else {
                            b.stateHandler.pushState(b.states.idle)
                        }
                    }, waitEvents: {"notify:spin:serverResponseReceived": false}
                }
            }, spinning: {
                state: {
                    name: "Spinning", execute: function (b) {
                    }, waitEvents: {"notify:spin:serverResponseReceived": false}
                }
            }, beforeStopping: {
                state: {
                    name: "BeforeStopping", execute: function () {
                    }, waitEvents: {}
                }
            }, stopping: {
                state: {
                    name: "Stopping", execute: function (b) {
                    }, waitEvents: {"notify:spin.AllIsStopped": false}
                }
            }, stopped: {
                state: {
                    name: "Stopped", execute: function (b) {
                    }, waitEvents: {}
                }
            }
        }
    }, getMixinDependencies: function () {
        return ["animation", "trigger"]
    }, getDefaultMVCClasses: function () {
        return {
            model: Core.Slots.BufferedSpinModel,
            view: Core.Slots.BufferedSpinView,
            controller: Core.Slots.BufferedSpinController
        }
    }
};
Core.Slots.BufferedSpin = Sys.extend(Core.Module, Core.Slots.BufferedSpin, "Core.Slots.BufferedSpin");
Sys.ns("Core.Slots");
Core.Slots.BufferedSpinModel = {
    constructor: function () {
        Core.Slots.BufferedSpinModel.superclass.constructor.apply(this, arguments)
    }, setupData: function () {
        var b = this, a = Resources.readData("gameServerInitResponse");
        b.storeData("nearWinEnabled", a.nearwinallowed);
        b.storeData("isValidServerResponse", false);
        b.storeData("initialOutcomes", b.parseInitialOutcomes());
        Resources.storeData("symbolLayout", [])
    }, parseInitialOutcomes: function () {
        var b = Resources.readData("gameServerInitResponseObject"), c = b.rs, a = {};
        Sys.iterate(c, function (e, d) {
            a[d.id] = Sys.utils.parseReelInfo(b, d.id)
        });
        return a
    }, setInitialOutcomeInfo: function (b, a) {
        var c = this.readData("initialOutcomes");
        c[b] = a;
        this.storeData("initialOutcomes", c)
    }, setDefaultOutcome: function (b) {
        var c = this, a = c.getDefaultOutcome(b);
        c.setInitialOutcomeInfo(b, a)
    }
};
Core.Slots.BufferedSpinModel = Sys.extend(Core.Model, Core.Slots.BufferedSpinModel, "Core.Slots.BufferedSpinModel");
Sys.ns("Core.Slots");
Core.Slots.BufferedSpinView = {
    SPIN_SOUNDS: {
        basic: {
            spinStart: {id: "spinStart", name: "spinStart"},
            reelSpin: {id: "reelSpin", name: "reelSpin", loop: true},
            reelBounce: {id: "reelBounce", name: "reelBounce"},
            reelStop: {id: "reelStop", name: "reelStop"}
        }
    }, constructor: function () {
        Core.Slots.BufferedSpinView.superclass.constructor.apply(this, arguments)
    }, pauseStopSequenceConfig: {}, initAnimations: function () {
        var d = this, b = Resources.readData("config").reelGroups, e = d.model.readData("currentReelSet"), a, c = [],
            g = {}, h = {}, f = this.model.readData("spinType");
        Sys.iterate(b, function (j, i) {
            a = new Core.Slots.ReelGroup(j, i, {
                reelStartCallback: d.onReelStart.bind(d, j),
                reelStartCompleteCallback: d.onReelStartComplete.bind(d, j),
                reelStartedStoppingCallback: d.onReelStartedStopping.bind(d, j),
                reelBounceStartCallback: d.onReelStartedBouncing.bind(d, j),
                reelStoppedCallback: d.onReelStopped.bind(d, j),
                fillerEventCallback: d.onFillerEvent.bind(d)
            }, {nearWinEnabled: d.model.readData("nearWinEnabled")});
            if (Sys.isDefined(f)) {
                a.setSpinType(f)
            }
            c.push(a);
            Sys.each(i.reelSets, function (k) {
                g[k] = a
            });
            h[j] = a
        });
        d.reelGroups = c;
        d.reelSetToGroupMapping = g;
        d.groupNameToGroupMapping = h;
        if (Sys.isDefined(e)) {
            d.activateReelSet(e, d.model.readData("startScene"))
        }
    }, onReelStart: function (a, b) {
        this.fireEvent("view:reelStart", b)
    }, onReelStartComplete: function (a, c) {
        var b = this;
        b.fireEvent("view:startSpinComplete", c);
        if (!b.spinSoundStarted) {
            b.fireEvent("view:playAudio", b.getSoundConfig("reelSpin"));
            b.spinSoundStarted = true
        }
    }, onReelStartedStopping: function (a, b) {
        this.fireEvent("view:reelStopStarted", b)
    }, onReelStartedBouncing: function (a, b) {
        this.playReelSpecificSound("reelBounce", b);
        this.fireEvent("view:reelStopBouncingStarted", b)
    }, onReelStopped: function (b, e) {
        var d = this, c = d.groupNameToGroupMapping[b].reelLists[e], a = d.currentReelGroup();
        d.playReelSpecificSound("reelStop", e);
        d.updateSymbolLayout(c, e);
        d.fireEvent("view:reelStoppedSpinning", e);
        if (e === d.lastReelToStop) {
            d.fireEvent("view:stopAudio", d.getSoundConfig("reelSpin").id);
            d.fireEvent("view:allReelsStoppedSpinning")
        }
        if (a.nearWinEnabled === true && Sys.isDefined(a.nearWinList) && a.nearWinList.length > 0) {
            if (a.nearWinList.indexOf(e + 1) === 0) {
                d.fireEvent("view:nearWinStarted", e + 1)
            }
        }
        c.correctMisalignedOutcomeOnDeviceRotate()
    }, refresh: function () {
        var a = this.reelGroups, b = Resources.readData("config").reelGroups;
        a.forEach(function (c) {
            c.refresh(b)
        })
    }, updateSymbolLayout: function (a, b) {
        Resources.readData("symbolLayout")[b] = a.getSymbolLayout()
    }, changeCurrentReelStopDelays: function (a) {
        this.currentReelGroup().changeCurrentReelStopDelays(a)
    }, resetCurrentReelStopDelays: function () {
        this.currentReelGroup().resetCurrentReelStopDelays()
    }, getSoundConfig: function (a) {
        var c = this, b = c.model.readData("currentReelSet"), d = c.SPIN_SOUNDS, e = d.basic[a];
        if (Sys.isDefined(d[b]) && Sys.isDefined(d[b][a])) {
            e = d[b][a]
        }
        return e
    }, playReelSpecificSound: function (a, c) {
        var b = this.getSoundConfig(a), d = Sys.applyProperties({}, b);
        d.id += c;
        this.fireEvent("view:playAudio", d)
    }, startSpin: function (c) {
        var d = this, a = d.currentReelGroup(), b = a.getReelCount() - 1;
        d.fireEvent("view:playAudio", d.getSoundConfig("spinStart"));
        if (Sys.isDefined(c)) {
            for (; b >= 0; --b) {
                if (!c.contains(b)) {
                    break
                }
            }
        }
        d.lastReelToStop = b;
        d.isStopSequenceResuming = false;
        d.spinSoundStarted = false;
        a.lastReelToStop = d.lastReelToStop;
        a.startSpin(c)
    }, stopSpin: function (b, a, c) {
        this.currentReelGroup().stopSpin(b, a, c)
    }, cancelSpin: function () {
        this.currentReelGroup().cancelSpin()
    }, pauseStopSequence: function (a, b) {
        this.currentReelGroup().pauseStopSequence(a, b)
    }, resumeStopSequence: function (a, b) {
        this.currentReelGroup().resumeStopSequence(a, b)
    }, activateReelSet: function (b, e) {
        var c = this, a, d;
        if (Sys.isDefined(c.reelSetToGroupMapping)) {
            a = c.reelSetToGroupMapping[b];
            if (Sys.isDefined(a)) {
                a.activate(b, e);
                c.model.storeData("currentReelSet", b);
                d = c.model.readData("initialOutcomes")[b];
                if (Sys.isDefined(d)) {
                    a.presentOutcome(d, c.model.readData("serverResponse"))
                }
                a.reelLists.forEach(function (g, f) {
                    c.updateSymbolLayout(g, f)
                })
            }
        } else {
            c.model.storeData("currentReelSet", b);
            c.model.storeData("startScene", e)
        }
    }, deactivateReelSet: function (b) {
        var c = this, a;
        if (!Sys.isDefined(b)) {
            b = c.model.readData("currentReelSet")
        }
        if (Sys.isDefined(c.reelSetToGroupMapping)) {
            a = c.reelSetToGroupMapping[b];
            if (Sys.isDefined(a)) {
                a.deactivate(b)
            }
        } else {
            if (b === c.model.readData("currentReelSet")) {
                c.model.removeData("currentReelSet");
                c.model.removeData("startScene")
            }
        }
    }, setSymbols: function (a) {
        this.currentReelGroup().setSymbols(a)
    }, hide: function () {
        this.currentReelGroup().hide()
    }, show: function () {
        this.currentReelGroup().show()
    }, currentReelGroup: function () {
        return this.reelSetToGroupMapping[this.model.readData("currentReelSet")]
    }, setReelVisibility: function (a) {
    }, handleSymbols: function (a, b) {
    }, setSpinType: function (c) {
        var b = -1, a = this.reelGroups;
        if (Sys.isDefined(a)) {
            for (; ++b < a.length;) {
                a[b].setSpinType(c)
            }
        }
        this.model.storeData("spinType", c)
    }, quickStop: function () {
        var c = this, b = c.model.readData("currentReelSet"), a;
        if (Sys.isDefined(c.reelSetToGroupMapping)) {
            a = c.reelSetToGroupMapping[b];
            if (Sys.isDefined(a)) {
                a.quickStop()
            }
        }
    }, hideSymbols: function (b) {
        var c = this, a = c.currentReelGroup();
        a.hideSymbols(b)
    }, showSymbols: function (b) {
        var c = this, a = c.currentReelGroup();
        a.showSymbols(b)
    }, setTimeToMoveOneSlot: function (b) {
        var a = this.currentReelGroup();
        a.setTimeToMoveOneSlot(b)
    }, onFillerEvent: function () {
        var a = ["view:fillerEvent"];
        a.push.apply(a, Array.prototype.slice.call(arguments, 0));
        this.fireEvent.apply(this, a)
    }
};
Core.Slots.BufferedSpinView = Sys.extend(Core.View, Core.Slots.BufferedSpinView, "Core.Slots.BufferedSpinView");
Sys.ns("Core.Slots");
Core.Slots.BufferedSpinController = {
    constructor: function () {
        Core.Slots.BufferedSpinController.superclass.constructor.apply(this, arguments)
    }, setupEvents: function () {
        var a = this;
        a.on({
            "notify:responseParser.responseParsed": a.serverResponse,
            "notify:stateHandler.enteringSpinningState": a.wantStartSpin,
            "notify:stateHandler.enteringStoppingState": a.wantStopSpin,
            "notify:stateHandler.leavingIdleState": a.onLeavingIdleState,
            "notify:stateHandler.leavingBeforeLoaderCloseState": a.updateSpinType,
            "notify:quickStopper.quickStop": a.quickStop,
            "notify:settingsManager.settingChanged": a.onSettingsChanged,
            "notify:scaling.gameSizeChanged": a.onGameSizeChanged,
            "request:spin.startNewRound": a.startNewRound,
            "request:spin.activateReelset": a.activateReelSet,
            "request:spin.activateInitReelset": a.activateReelSet,
            "request:spin.deactivateReelset": a.deactivateReelSet,
            "request:spin.startSpin": a.startSpin,
            "request:spin.stopSpin": a.stopSpin,
            "request:spin.cancelSpin": a.cancelSpin,
            "request:spin.activateDefaultOutcome": a.cancelSpin,
            "request:spin.setSymbols": a.setSymbols,
            "request:spin.pauseStopSequence": a.pauseStopSequence,
            "request:spin.resumeStopSequence": a.resumeStopSequence,
            "request:spin.updateInitReelInfo": a.setInitialOutcomeInfo,
            "request:spin.hideSymbols": a.hideSymbols,
            "request:spin.showSymbols": a.showSymbols,
            "request:spin.setTimeToMoveOneSlot": a.setTimeToMoveOneSlot,
            "request:spin.changeCurrentReelStopDelays": a.changeCurrentReelStopDelays,
            "request:spin.resetCurrentReelStopDelays": a.resetCurrentReelStopDelays,
            "view:reelStart": a.announceReelSpinStart,
            "view:startSpinComplete": a.onStartSpinComplete,
            "view:reelStoppedSpinning": a.announceReelStopped,
            "view:reelStopBouncingStarted": a.announceReelStopBouncingStarted,
            "view:allReelsStoppedSpinning": a.announceSpinComplete,
            "view:stopSequencePaused": a.announceSpinStopSequencePaused,
            "view:stopSequenceResumed": a.announceSpinStopSequenceResumed,
            "view:resumeStopSequence": a.resumeStopSequence,
            "view:reelStopStarted": a.announceStopSpinStarted,
            "view:fillerEvent": a.announceFillerEvent,
            "view:nearWinStarted": a.announceNearWinStarted,
            "view:playAudio": a.fireEvent.bind(a, "request:audioPlayer.play"),
            "view:stopAudio": a.fireEvent.bind(a, "request:audioPlayer.stop")
        })
    }, registerTriggers: function (a) {
        a.registerTrigger("notify:spin.reelStopStarted", this, "The stop spin has started on the given reel.");
        a.registerTrigger("notify:spin.reelStopBouncingStarted", this, "Reel stop bounce started.");
        a.registerTrigger("notify:spin.spinAnimationStarted", this, "When reel starts spinning.");
        a.registerTrigger("notify:quickStopper.quickStop", this, "When spin is quick stopped.");
        a.registerTrigger("notify:spin.nearWinStarted", this, "Near win started.");
        a.registerTrigger("notify:spin.spinAnimationComplete", this, "When spin animation complete.")
    }, serverResponse: function (a) {
        this.fireEvent("request:spin.child.storeServerResponse", a);
        if (!a.clientaction.contains("init") && a.clientaction !== "endbonus") {
            this.model.storeData("isValidServerResponse", true);
            this.fireEvent("notify:spin:serverResponseReceived")
        }
        this.model.storeData("serverResponse", a)
    }, wantStartSpin: function () {
        this.fireEvent("request:spin.child.wantStartSpin");
        this.fireEvent("request:serverManager.sendAction", "nextAction")
    }, wantStopSpin: function () {
        this.fireEvent("request:spin.child.wantStopSpin")
    }, quickStop: function () {
        this.view.quickStop()
    }, onLeavingIdleState: function () {
        this.waitingToStart = false
    }, onSettingsChanged: function (a, c) {
        var b = this;
        if (a === "quickSpin") {
            b.updateSpinType();
            if (c) {
                b.fireEvent("request:spinButton.addDisplayType", "quickSpin")
            } else {
                b.fireEvent("request:spinButton.removeDisplayType", "quickSpin")
            }
        }
    }, onGameSizeChanged: function () {
        if (Sys.isFunc(this.view.refresh)) {
            this.view.refresh()
        }
    }, changeCurrentReelStopDelays: function (a) {
        this.view.changeCurrentReelStopDelays(a)
    }, resetCurrentReelStopDelays: function () {
        this.view.resetCurrentReelStopDelays()
    }, updateSpinType: function () {
        var a = this;
        if (Services.settingsManager.getSetting("quickSpin")) {
            a.view.setSpinType("quickSpin")
        } else {
            a.view.setSpinType("standard")
        }
    }, setInitialOutcomeInfo: function (b, a) {
        this.model.setInitialOutcomeInfo(b, a)
    }, startNewRound: function () {
        var a = this;
        if (a.waitingToStart) {
            return
        }
        a.waitingToStart = true;
        if (Services.moneyManager.canPlaceAnotherBet()) {
            a.performSpin()
        } else {
            Services.moneyManager.reloadBalance().done(function () {
                if (Services.moneyManager.canPlaceAnotherBet()) {
                    a.performSpin()
                } else {
                    a.fireEvent("request:errorManager.handleClientOutOfMoneyError")
                }
            }).fail(function () {
                a.fireEvent("request:errorManager.handleClientOutOfMoneyError")
            }).always(function () {
                a.waitingToStart = false
            })
        }
    }, performSpin: function () {
        this.updateSpinType();
        this.fireEvent("notify:spin.roundStart");
        Services.moneyManager.placeBet()
    }, activateReelSet: function (a, b) {
        this.view.activateReelSet(a, b);
        this.fireEvent("notify:spin.reelSetActivated", a)
    }, deactivateReelSet: function () {
        this.view.deactivateReelSet()
    }, startSpin: function (b, d) {
        var c = this, a = c.getHeldReels();
        c.aborted = false;
        c.dialogClosed = false;
        c.allReelsHaveStopped = false;
        c.model.storeData("isValidServerResponse", false);
        c.announceSpinStarted(b);
        if (b !== "respin" && c.model.readData("currentReelSet") !== b) {
            c.activateReelSet(b, d)
        }
        c.view.startSpin(a)
    }, stopSpin: function (b, a, c) {
        this.view.stopSpin(b, a, c);
        this.setInitialOutcomeInfo(this.model.readData("currentReelSet"), b)
    }, setSymbols: function (a) {
        this.view.setSymbols(a)
    }, pauseStopSequence: function (a, b) {
        this.view.pauseStopSequence(a, b)
    }, resumeStopSequence: function (a, b) {
        this.view.resumeStopSequence(a, b)
    }, cancelSpin: function () {
        var a = this;
        a.view.cancelSpin();
        a.fireEvent("notify:spin:serverResponseReceived");
        a.fireEvent("notify:spin.spinCanceled");
        a.fireEvent("notify:spin.spinAnimationComplete");
        a.fireEvent("request:spin.child.revertSpin")
    }, hideSymbols: function (a) {
        this.view.hideSymbols(a)
    }, showSymbols: function (a) {
        this.view.showSymbols(a)
    }, setTimeToMoveOneSlot: function (a) {
        this.view.setTimeToMoveOneSlot(a)
    }, announceSpinStarted: function (a) {
        this.fireEvent("notify:spin.spinAnimationStarted", a)
    }, announceReelSpinStart: function (a) {
        this.fireEvent("notify:spin.startReelSpin", a)
    }, onStartSpinComplete: function (a) {
        this.fireEvent("notify:spin.startSpinComplete", a)
    }, announceReelStopped: function (a) {
        this.fireEvent("notify:spin.reelStoppedSpinning", a)
    }, announceReelStopBouncingStarted: function (a) {
        this.fireEvent("notify:spin.reelStopBouncingStarted", a)
    }, announceSpinComplete: function () {
        var a = this;
        if (a.aborted) {
            if (a.dialogClosed) {
                a.view.show()
            }
        }
        a.allReelsHaveStopped = true;
        this.fireEvent("notify:spin.spinAnimationComplete");
        this.fireEvent("notify:spin.AllIsStopped")
    }, announceSpinStopSequencePaused: function () {
        this.fireEvent("notify:spin.stopSequencePaused")
    }, announceSpinStopSequenceResumed: function () {
        this.fireEvent("notify:spin.stopSequenceResumed")
    }, announceStopSpinStarted: function (a) {
        this.fireEvent("notify:spin.reelStopStarted", a)
    }, announceFillerEvent: function (b) {
        var a = [];
        a.push("notify:spin." + b);
        a.push.apply(a, Array.prototype.slice.call(arguments, 1));
        this.fireEvent.apply(this, a)
    }, announceNearWinStarted: function (a) {
        this.fireEvent("notify:spin.nearWinStarted", a)
    }, getHeldReels: function () {
        var a = [];
        this.model.readData("serverResponse").reelInfo.forEach(function (c, b) {
            if (c.hold) {
                a.push(b)
            }
        });
        return a
    }
};
Core.Slots.BufferedSpinController = Sys.extend(Core.Controller, Core.Slots.BufferedSpinController, "Core.Slots.BufferedSpinController");
Sys.ns("Core.Slots");
Core.Slots.ReelGroup = function (d, a, c, b) {
    this.constructor(d, a, c, b)
};
Core.Slots.ReelGroup.prototype = {
    constructor: function (f, a, d, b) {
        var c = this, e = this.getReelLayout(a.reelLayouts) || a.reelLayout;
        c.createSymbolBuffer(a.numberOfReels, a.fillers, d);
        c.createReelLists(f, a.numberOfReels, e, d);
        c.groupName = f;
        c.spinType = "standard";
        c.spinTimes = a.spinTimes;
        c.gameModeSpinTimes = a.spinTimes.gameModes || {};
        c.nearWinEnabled = b.nearWinEnabled;
        c.lastReelToStop = c.getReelCount() - 1
    }, createSymbolBuffer: function (c, b, a) {
        this.symbolBuffer = new Core.Slots.SymbolBuffer(c, b, a)
    }, createReelLists: function (m, c, g, j) {
        var l = this, f = 0, e, k = Layering.Game.Slots.Spin[m].symbols, d = l.symbolBuffer, h, a, b = [];
        l.reelLists = [];
        l.slotLengthGroups = {};
        for (; f < c; f++) {
            e = Sys.applyProperties({}, g.standard || g.config);
            if (Sys.isDefined(g[f])) {
                Sys.applyProperties(e, g[f])
            }
            e.id = m + "_" + f;
            e.baseDepth += k;
            e.symbolRetrievalFunction = d.getSymbols.bind(d, f);
            Sys.applyProperties(e, l.getReelSpecificCallbacks(f, j));
            h = new Animation.BufferedReelList(e);
            a = h.getSlotLength();
            if (!Sys.isDefined(l.slotLengthGroups[a])) {
                l.slotLengthGroups[a] = []
            }
            l.slotLengthGroups[a].push(h);
            b.push(h.getVisibleSymbolsCount());
            l.reelLists.push(h)
        }
        l.symbolBuffer.setVisibleSymbolsCounts(b)
    }, getReelLayout: function (a) {
        var b;
        if (!Sys.isDefined(a)) {
            return null
        }
        b = Environment.getConfigForCurrentDeviceState(a);
        if (b === null) {
        }
        return b
    }, refresh: function (a) {
        var c = this.getReelLayout(a["default"].reelLayouts) || a["default"].reelLayout,
            d = Sys.applyProperties({}, c.config || c.standard), b = this.reelLists;
        d.baseDepth = Layering.Game.Slots.Spin[this.groupName].symbols;
        Sys.each(b, function (f, e) {
            if (Sys.isDefined(c[e])) {
                Sys.applyProperties(d, c[e])
            }
            f.refresh(d)
        })
    }, getReelSpecificCallbacks: function (d, c) {
        var b = this, a = {};
        a.reelStartCallback = function () {
            c.reelStartCallback(d)
        };
        a.reelStartCompleteCallback = function () {
            if (d === b.lastReelToStop) {
                b.startSpinCompleteTime = Date.now();
                b.tryToStartStopSequence()
            }
            b.symbolBuffer.updateReelStartedMap(d);
            c.reelStartCompleteCallback(d)
        };
        a.reelStartedStoppingCallback = function () {
            c.reelStartedStoppingCallback(d)
        };
        a.reelBounceStartCallback = function () {
            c.reelBounceStartCallback(d)
        };
        a.reelStoppedCallback = function () {
            c.reelStoppedCallback(d)
        };
        return a
    }, startSpin: function (b) {
        var c = this, e = c.spinTimes[c.spinType], g = e.reelStartDelays, a = c.reelLists,
            d = c.gameModeSpinTimes[c.activeReelSet] || {}, f = d[c.spinType] || {};
        c.symbolBuffer.cleanUp();
        if (Sys.isArray(f.reelStartDelays)) {
            g = f.reelStartDelays
        }
        g = Sys.isArray(g) ? g : [];
        if (!Sys.isEmpty(g)) {
            c.symbolBuffer.setReelStartMap(false)
        }
        b = Sys.isDefined(b) ? b : [];
        c.symbolBuffer.setHeldReels(b);
        c.syncReels();
        c.hasBeenToldToStop = false;
        c.isQuickStopped = false;
        c.startSpinCompleteTime = undefined;
        c.hasPassedMinimumSpinTime = false;
        c.stopStartTime = undefined;
        c.stopSequencePausers = Sys.utils.init2dMatrix(c.getReelCount(), 0);
        Sys.each(a, function (h, i) {
            if (!b.contains(i)) {
                h.startSpin(g[i])
            }
        })
    }, syncReels: function () {
        var d = this, b, e, a, c = d.symbolBuffer.workspace.heldReels;
        Sys.iterate(this.slotLengthGroups, function (g, f) {
            b = 0;
            Sys.each(f, function (h) {
                b = Math.max(b, h.getBufferOffset())
            });
            Sys.each(f, function (h) {
                e = h.getBufferOffset();
                a = d.reelLists.indexOf(h);
                if (a > -1 && !c.contains(a) && e < b) {
                    h.setBufferOffset(b)
                }
            })
        })
    }, setSpinType: function (a) {
        this.spinType = a;
        this.updateSpinTimings()
    }, stopSpin: function (b, a, d) {
        var c = this;
        c.symbolBuffer.setOutcome(b, d);
        c.nearWinList = a;
        c.hasBeenToldToStop = true;
        c.tryToStartStopSequence()
    }, cancelSpin: function () {
        this.presentOutcome(Resources.readData("config").reelSets[this.activeReelSet].noWinOutcome)
    }, presentOutcome: function (d, e) {
        var c = this, b = c.symbolBuffer, a = c.reelLists;
        c.hasBeenToldToStop = false;
        c.stopSequencePausers = Sys.utils.init2dMatrix(c.getReelCount(), 0);
        b.cleanUp();
        b.clearBuffer();
        a.forEach(function (f) {
            f.reset()
        });
        b.setOutcome(d, e);
        c.stopNow();
        a.forEach(function (f) {
            f.presentOutcome()
        })
    }, setTimeToMoveOneSlot: function (b) {
        var a = this.reelLists;
        a.forEach(function (c) {
            c.setTimeToMoveOneSlot(b)
        })
    }, setReelStartSpinParameters: function (a) {
        this.reelLists.forEach(function (b) {
            b.setReelStartSpinParameters(a)
        })
    }, setBlurOffsetFromStart: function (a) {
        this.reelLists.forEach(function (b) {
            b.setBlurOffsetFromStart(a)
        })
    }, setEndBounceSupportPointOffsets: function (a) {
        this.reelLists.forEach(function (b) {
            b.setEndBounceSupportPointOffsets(a)
        })
    }, setEndBounceDurations: function (a) {
        this.reelLists.forEach(function (b) {
            b.setEndBounceDurations(a)
        })
    }, stopNow: function () {
        var d = this, a = d.getReelCount(), c = [], b;
        for (b = -1; ++b < a;) {
            if (d.stopSequencePausers[b].length === 0) {
                c[b] = 0
            } else {
                c[b] = Infinity;
                break
            }
        }
        for (; ++b < a;) {
            c[b] = Infinity
        }
        d.symbolBuffer.setStopDistance(c)
    }, calculateSymbolsBeforeOutcome: function () {
        var o = this, n = o.getReelCount(), h = o.spinTimes[o.spinType], q = o.gameModeSpinTimes[o.activeReelSet] || {},
            k = q[o.spinType] || {}, b = h.minimumSpinTime, g = Sys.isNumber(h.nearWinDelay) ? h.nearWinDelay : 0,
            l = [], a, d = h.reelStopDelays, j, p = o.symbolBuffer.getIndexOfLastStoppingReel(), r = o.nearWinList, e,
            c, m = 0, f = o.getRuntimeReelStopDelayOverride();
        if (Sys.isNumber(k.minimumSpinTime)) {
            b = k.minimumSpinTime
        }
        if (Sys.isNumber(k.nearWinDelay)) {
            g = k.nearWinDelay
        }
        if (Sys.isArray(k.reelStopDelays)) {
            d = k.reelStopDelays
        }
        if (Sys.isArray(f)) {
            d = f
        }
        a = (b - (Date.now() - o.startSpinCompleteTime));
        for (j = -1; ++j <= p;) {
            l[j] = 0
        }
        for (j = p; ++j < n;) {
            if (o.stopSequencePausers[j].length === 0) {
                e = a + d[j];
                if (o.nearWinEnabled && Sys.isArray(r)) {
                    e += g * (r.indexOf(j) + 1)
                }
                c = Math.round(e / o.reelLists[j].getTimeToMoveOneSlot()) + m;
                if (c < 0) {
                    m = -c;
                    c = 0
                }
                l[j] = c
            } else {
                l[j] = Infinity;
                break
            }
        }
        for (; ++j < n;) {
            l[j] = Infinity
        }
        return l
    }, tryToStartStopSequence: function () {
        var a = this;
        if (a.canStop()) {
            if (a.isQuickStopped) {
                a.stopNow()
            } else {
                a.symbolBuffer.setStopDistance(a.calculateSymbolsBeforeOutcome())
            }
        }
    }, canStop: function () {
        return this.hasBeenToldToStop && Sys.isDefined(this.startSpinCompleteTime)
    }, pauseStopSequence: function (a, e) {
        var d = this, c, b = d.getReelCount();
        if (!Sys.isDefined(a) || !Sys.isDefined(e)) {
            return
        }
        d.stopSequencePausers[e].push(a);
        c = d.symbolBuffer.getStopDistance();
        for (; e < b; ++e) {
            c[e] = Infinity
        }
        d.symbolBuffer.setStopDistance(c)
    }, resumeStopSequence: function (a, d) {
        var c = this, b;
        if (!Sys.isDefined(a) || !Sys.isDefined(d)) {
            return
        }
        b = c.stopSequencePausers[d].indexOf(a);
        if (b >= 0) {
            c.stopSequencePausers[d].splice(b, 1);
            if (c.stopSequencePausers[d].length === 0) {
                c.tryToStartStopSequence()
            }
        }
    }, getReelCount: function () {
        return this.reelLists.length
    }, setSymbols: function (b) {
        var c = -1, a = this.reelLists;
        for (; ++c < a.length;) {
            if (Sys.isDefined(b[c])) {
                a[c].setSymbols(b[c])
            }
        }
    }, hide: function () {
        Sys.each(this.reelLists, function (a) {
            a.stop()
        })
    }, show: function () {
        Sys.each(this.reelLists, function (a) {
            a.show()
        })
    }, hideReel: function (b) {
        var a = this.reelLists[b];
        if (Sys.isDefined(a)) {
            a.stop()
        }
    }, showReel: function (b) {
        var a = this.reelLists[b];
        if (Sys.isDefined(a)) {
            a.play()
        }
    }, hideSymbolsOnReel: function (c, b) {
        var a = this.reelLists[c];
        if (Sys.isDefined(a)) {
            a.hideSymbols(b)
        }
    }, hideSymbols: function (a) {
        var b = this;
        Sys.iterate(a, function (d, c) {
            b.hideSymbolsOnReel(d, c)
        })
    }, showSymbolsOnReel: function (c, b) {
        var a = this.reelLists[c];
        if (Sys.isDefined(a)) {
            a.showSymbols(b)
        }
    }, showSymbols: function (a) {
        var b = this;
        Sys.iterate(a, function (d, c) {
            b.showSymbolsOnReel(d, c)
        })
    }, activate: function (a, c) {
        var b = this;
        if (Sys.isDefined(b.activeReelSet)) {
            b.deactivate(b.activeReelSet)
        }
        Sys.each(b.reelLists, function (d) {
            Game.stage.view.addToRenderLoop(d, c)
        });
        b.symbolBuffer.activateReelSet(a);
        b.activeReelSet = a;
        b.scene = c;
        b.updateSpinTimings(a)
    }, deactivate: function (a) {
        var b = this;
        if (a === b.activeReelSet) {
            Sys.each(b.reelLists, function (c) {
                Game.stage.view.removeFromRenderLoop(c, b.scene)
            });
            b.activeReelSet = undefined
        }
    }, quickStop: function () {
        var a = this;
        a.isQuickStopped = true;
        if (a.canStop()) {
            a.stopNow()
        }
    }, updateSpinTimings: function (a) {
        var b = Sys.isString(a) ? a : this.activeReelSet;
        this.updateTimeToMoveOneSlot(b);
        this.updateReelStartSpinParameters(b);
        this.updateBlurOffsetFromStart(b);
        this.updateEndBounceSupportPointOffsets(b);
        this.updateEndBounceDurations(b)
    }, getGameModeSpinConfiguration: function (d, b) {
        var e = this.spinTimes[this.spinType], a = this.gameModeSpinTimes[d], c;
        if (Sys.isObj(e) && Sys.isDefined(e[b])) {
            c = e[b]
        }
        if (Sys.isObj(a)) {
            if (a[this.spinType] && Sys.isDefined(a[this.spinType][b])) {
                c = a[this.spinType][b]
            } else {
                if (Sys.isDefined(a[b])) {
                    c = a[b]
                }
            }
        }
        return c
    }, updateTimeToMoveOneSlot: function (b) {
        var a = this.getGameModeSpinConfiguration(b, "timeToMoveOneSlot");
        if (Sys.isNumber(a)) {
            this.setTimeToMoveOneSlot(a)
        }
    }, updateReelStartSpinParameters: function (b) {
        var a = this.getGameModeSpinConfiguration(b, "reelStartSpinParameters");
        if (Sys.isObj(a)) {
            this.setReelStartSpinParameters(a)
        }
    }, updateBlurOffsetFromStart: function (b) {
        var a = this.getGameModeSpinConfiguration(b, "blurOffsetFromStart");
        if (Sys.isNumber(a)) {
            this.setBlurOffsetFromStart(a)
        }
    }, updateEndBounceSupportPointOffsets: function (b) {
        var a = this.getGameModeSpinConfiguration(b, "endBounceSupportPointOffsets");
        if (Sys.isArray(a)) {
            this.setEndBounceSupportPointOffsets(a)
        }
    }, updateEndBounceDurations: function (b) {
        var a = this.getGameModeSpinConfiguration(b, "endBounceDurations");
        if (Sys.isArray(a)) {
            this.setEndBounceDurations(a)
        }
    }, getRuntimeReelStopDelayOverride: function () {
        var a = this;
        if (Sys.isDefined(a.runtimeReelStopDelaysOverride) && Sys.isDefined(a.runtimeReelStopDelaysOverride[a.activeReelSet]) && Sys.isDefined(a.runtimeReelStopDelaysOverride[a.activeReelSet][a.spinType])) {
            return a.runtimeReelStopDelaysOverride[a.activeReelSet][a.spinType]
        }
        return null
    }, changeCurrentReelStopDelays: function (a) {
        var b = this;
        if (b.isValidReelStopDelays(a)) {
            b.runtimeReelStopDelaysOverride = b.runtimeReelStopDelaysOverride || [];
            b.runtimeReelStopDelaysOverride[b.activeReelSet] = b.runtimeReelStopDelaysOverride[b.activeReelSet] || [];
            b.runtimeReelStopDelaysOverride[b.activeReelSet][b.spinType] = a
        }
    }, resetCurrentReelStopDelays: function () {
        var a = this;
        if (Sys.isDefined(a.runtimeReelStopDelaysOverride) && Sys.isDefined(a.runtimeReelStopDelaysOverride[a.activeReelSet]) && Sys.isDefined(a.runtimeReelStopDelaysOverride[a.activeReelSet][a.spinType])) {
            delete a.runtimeReelStopDelaysOverride[a.activeReelSet][a.spinType]
        }
    }, isValidReelStopDelays: function (a) {
        var b;
        if (!Sys.isArray(a)) {
            return false
        }
        if (a.length !== this.getReelCount()) {
            return false
        }
        for (b = 0; b < a.length; b++) {
            if (!Sys.isNumber(a[b]) || a[b] < 0) {
                return false
            }
        }
        return true
    }
};
Sys.ns("Core.Slots");
Core.Slots.SymbolBuffer = {
    SYMBOL_CONSTANTS: {any: -1, fakeReel: -2, lowWin: -3}, constructor: function (a, d, c) {
        var b = this;
        Core.Slots.SymbolBuffer.superclass.constructor.apply(b, arguments);
        b.pipeCount = a;
        b.clearBuffer();
        b.currentReelSet = undefined;
        b.setUpWorkspace(c);
        b.createFillers(d);
        b.setReelStartMap(true)
    }, clearBuffer: function () {
        this.buffer = Sys.utils.init2dMatrix(this.pipeCount, 0)
    }, setUpWorkspace: function (c) {
        var b = this, a = b.pipeCount;
        b.workspace = {
            pipeCount: a,
            currentReelSet: b.currentReelSet,
            currentOutcome: undefined,
            outcomeInsertedOnReel: Sys.utils.initArray(a, false),
            heldReels: [],
            linkedReels: Sys.utils.initArray(a, false),
            symbolsBeforeOutcome: Sys.utils.initArray(a, Infinity),
            symbolConstants: b.SYMBOL_CONSTANTS,
            announce: c.fillerEventCallback
        }
    }, createFillers: function (a) {
        var c = this, b;
        c.fillers = [];
        Sys.each(a, function (d) {
            b = Sys.utils.getClassFromString(d);
            c.fillers.push(new b(c.workspace))
        })
    }, getSymbols: function (b, a, d) {
        var c = this;
        if (c.buffer[b].length < a) {
            c.fill(a - c.buffer[b].length, b, d)
        }
        return c.buffer[b].splice(-a, a)
    }, fill: function (a, d, f) {
        var e = this, b = [], c;
        for (c = -1; ++c < e.pipeCount;) {
            if (c < d || (c !== d && f) || e.shouldNotPushSymbolToBuffer(c)) {
                b.push([])
            } else {
                b.push(Sys.utils.initArray(a, e.SYMBOL_CONSTANTS.any))
            }
        }
        e.fillBuffer(b, f === true)
    }, shouldNotPushSymbolToBuffer: function (a) {
        return this.workspace.heldReels.contains(a) || !this.workspace.reelStarted[a]
    }, fillBuffer: function (f, c) {
        var k = this, b = k.fillers, d = b.length, j = k.pipeCount, h = k.workspace.symbolsBeforeOutcome, e, g, a;
        for (g = -1; ++g < d;) {
            a = b[g].fill(f, c);
            if (!a) {
                break
            }
        }
        for (g = -1; ++g < j;) {
            e = f[g].length;
            if (h[g] >= e) {
                h[g] -= e
            } else {
                h[g] = 0
            }
            k.buffer[g] = f[g].reverse().concat(k.buffer[g])
        }
    }, cleanUp: function () {
        var c = this, d = c.fillers, a = d.length, b;
        for (b = -1; ++b < a;) {
            d[b].cleanUp()
        }
        c.cleanUpWorkspace()
    }, cleanUpWorkspace: function () {
        var a = this.workspace, b = a.pipeCount;
        a.currentOutcome = undefined;
        a.outcomeInsertedOnReel = Sys.utils.initArray(b, false);
        a.heldReels.length = 0;
        a.linkedReels = Sys.utils.initArray(b, false);
        a.symbolsBeforeOutcome = Sys.utils.initArray(b, Infinity)
    }, activateReelSet: function (b) {
        var a = this;
        if (b !== a.currentReelSet) {
            a.currentReelSet = b;
            a.workspace.currentReelSet = b;
            Sys.each(a.fillers, function (c) {
                c.setReelSet(b)
            })
        }
    }, setOutcome: function (a, b) {
        this.workspace.currentOutcome = a;
        Sys.each(this.fillers, function (c) {
            c.processOutcome(a, b)
        })
    }, setStopDistance: function (a) {
        this.fillers.forEach(function (b) {
            b.updateStoppingDistances(a)
        });
        this.workspace.symbolsBeforeOutcome = a
    }, getStopDistance: function () {
        return this.workspace.symbolsBeforeOutcome
    }, setVisibleSymbolsCounts: function (a) {
        this.workspace.visibleSymbolsCounts = a
    }, getIndexOfLastStoppingReel: function () {
        return Math.max(this.workspace.outcomeInsertedOnReel.indexOf(false) - 1, -1)
    }, setHeldReels: function (b) {
        var a = this.workspace;
        a.heldReels = b;
        a.heldReels.forEach(function (c) {
            a.outcomeInsertedOnReel[c] = true
        })
    }, setReelStartMap: function (a) {
        this.workspace.reelStarted = Sys.utils.initArray(this.pipeCount, a)
    }, updateReelStartedMap: function (a) {
        this.workspace.reelStarted[a] = true
    }
};
Core.Slots.SymbolBuffer = Sys.extend(Sys.Observable, Core.Slots.SymbolBuffer, "Core.Slots.SymbolBuffer");
Sys.ns("Core.Slots");
Core.Slots.Filler = function () {
};
Core.Slots.Filler.prototype = {
    fill: function () {
        return true
    }, cleanUp: function () {
    }, analyzePipeBuffer: function (g, a, d) {
        var f = [], h = -1, e, c, b;
        if (!Sys.isDefined(d)) {
            d = [this.workspace.symbols.any]
        }
        for (b = -1; ++b < g.length;) {
            e = d.contains(g[b]);
            c = h === -1;
            if (e && c) {
                h = b
            } else {
                if (!e && !c) {
                    f.push({start: h, length: b - h});
                    h = -1
                }
            }
        }
        if (h !== -1) {
            f.push({start: h, length: a ? g.length - h : Infinity})
        }
        return f
    }, fillSlots: function (b, a, c) {
        if (c < 0 || c >= a.length) {
            return
        }
        a.splice.apply(a, [c, b.length].concat(b))
    }, setReelSet: function () {
    }, wrapSymbols: function (c) {
        var a = [], b;
        for (b = -1; ++b < c.length;) {
            a.push(this.wrapSymbol(c[b]))
        }
        return a
    }, wrapSymbol: function (a) {
        return {symbol: a}
    }, evenBuffer: function (b) {
        var e = this, d, c = e.workspace, a = 0, f = false;
        for (d = -1; ++d < b.length;) {
            a = Math.max(a, b[d].length)
        }
        for (d = -1; ++d < b.length;) {
            if (!c.outcomeInsertedOnReel[d]) {
                while (b[d].length < a) {
                    b[d].push(c.symbolConstants.any)
                }
            }
            f = f || e.slotsLeftInPipe(b[d])
        }
        return f
    }, slotsLeftInBuffer: function (a, c) {
        var b = -1;
        for (; ++b < a.length;) {
            if (this.slotsLeftInPipe(a[b], c)) {
                return true
            }
        }
        return false
    }, slotsLeftInPipe: function (b, c) {
        var a = -1;
        for (; ++a < b.length;) {
            if (Sys.isObj(b[a])) {
                continue
            }
            if (!Sys.isDefined(c) || c.contains(b[a])) {
                return true
            }
        }
        return false
    }, pipeBufferContainsOutcome: function (b) {
        var a = -1;
        for (; ++a < b.length;) {
            if (b[a].isOutcomeSymbol) {
                return true
            }
        }
        return false
    }, processOutcome: function () {
    }, updateStoppingDistances: function () {
    }
};
Sys.ns("Core.Slots");
Core.Slots.SimpleFakeReelFiller = {
    constructor: function (a) {
        var b = this;
        Core.Slots.SimpleFakeReelFiller.superclass.constructor.apply(b, arguments);
        b.workspace = a;
        b.setReelSet(a.currentReelSet);
        b.cleanUp()
    }, fill: function (d) {
        var k = this, f, b, g, c = k.reelPositions, l = k.workspace.symbolConstants, e = [l.any, l.fakeReel], a, h;
        for (f = -1; ++f < d.length;) {
            g = d[f];
            if (!k.slotsLeftInPipe(g, e)) {
                continue
            }
            a = k.reelStrips[f];
            h = c[f];
            for (b = -1; ++b < g.length;) {
                if (e.contains(g[b])) {
                    g[b] = k.wrapSymbol(a[h]);
                    h = ++h % a.length
                }
            }
            c[f] = h
        }
        return false
    }, setReelSet: function (d) {
        var c = this, a = Resources.readData("config").reelSets, b = Sys.isDefined(a[d]) ? a[d] : a.basic;
        if (Sys.isDefined(b)) {
            c.reelStrips = b.fakeReels;
            c.reelPositions = Sys.utils.initArray(c.reelStrips.length, 0)
        }
    }
};
Core.Slots.SimpleFakeReelFiller = Sys.extend(Core.Slots.Filler, Core.Slots.SimpleFakeReelFiller, "Core.Slots.SimpleFakeReelFiller");
Sys.ns("Core.Slots");
Core.Slots.SimpleOutcomeFiller = {
    constructor: function (a) {
        Core.Slots.SimpleOutcomeFiller.superclass.constructor.apply(this, arguments);
        this.workspace = a;
        this.cleanUp()
    }, fill: function (g, e) {
        var l = this, h, d = l.workspace, k, b = d.currentOutcome, f = 0, j, a, c;
        if (!Sys.isDefined(b)) {
            return l.slotsLeftInBuffer(g)
        }
        for (h = -1; ++h < g.length;) {
            j = g[h];
            if (!l.slotsLeftInPipe(j, [d.symbolConstants.any])) {
                continue
            }
            k = d.symbolsBeforeOutcome[h];
            if (k >= j.length || !l.hasInsertedPreviousOutcome(h)) {
                break
            }
            if (d.outcomeInsertedOnReel[h]) {
                continue
            }
            a = b[h].symbols.slice(0);
            c = l.findOutcomeStart(l.analyzePipeBuffer(j, e, [d.symbolConstants.any]), a.length, Math.max(f, k));
            if (c >= 0) {
                l.fillSlots(l.wrapSymbols(a.reverse()), j, c);
                d.outcomeInsertedOnReel[h] = true;
                f = c
            }
        }
        return l.slotsLeftInBuffer(g)
    }, hasInsertedPreviousOutcome: function (a) {
        return a === 0 || this.workspace.outcomeInsertedOnReel[a - 1]
    }, findOutcomeStart: function (e, g, d) {
        var b, f, a, c;
        for (c = -1; ++c < e.length;) {
            b = e[c];
            if (b.start >= d) {
                f = b.start;
                a = b.length
            } else {
                f = d;
                a = b.length - (d - b.start)
            }
            if (a >= g) {
                return f
            }
        }
        return -1
    }, wrapSymbol: function (a) {
        return {symbol: a, isOutcomeSymbol: true}
    }
};
Core.Slots.SimpleOutcomeFiller = Sys.extend(Core.Slots.Filler, Core.Slots.SimpleOutcomeFiller, "Core.Slots.SimpleOutcomeFiller");
Sys.ns("Interface");
Interface.Ticker = {
    constructor: function () {
        Interface.Ticker.superclass.constructor.apply(this, arguments)
    }, getMixinDependencies: function () {
        return ["properties"]
    }, getDefaultMVCClasses: function () {
        return {controller: Interface.TickerController, view: Interface.TickerBaseView, model: Core.Model}
    }
};
Interface.Ticker = Sys.extend(Core.Module, Interface.Ticker, "Interface.Ticker");
Sys.ns("Interface");
Interface.TickerBaseView = {
    BASE_CSS: "interface-ticker_container",
    CONTENT_CSS: "interface-ticker_text",
    BACKGROUND_URI: "interface-ticker_uri",
    RENDER_TARGET: "gameWrapper",
    ANIMATION_SPEED: 20000,
    constructor: function () {
        Interface.TickerBaseView.superclass.constructor.apply(this, arguments)
    },
    enable: function () {
    },
    disable: function () {
    },
    update: function () {
    }
};
Interface.TickerBaseView = Sys.extend(Core.View, Interface.TickerBaseView, "Interface.TickerBaseView");
Sys.ns("Interface");
Interface.TickerMobileView = {
    constructor: function () {
        Interface.TickerMobileView.superclass.constructor.apply(this, arguments);
        this.constructDOMElement();
        this.setupAnimation()
    }, enable: function () {
        var a = this;
        if (a.model.hasProperty("enabled")) {
            a.container.el.style.display = "block";
            a.update();
            a.fireEvent("view:enabled")
        }
    }, disable: function () {
        var a = this;
        if (!a.model.hasProperty("enabled")) {
            a.container.el.style.display = "none";
            a.update();
            a.fireEvent("view:disabled")
        }
    }, update: function () {
        var b = this, a = b.model.readData("content");
        b.textContainer.removeAll();
        if (Sys.isDefined(a)) {
            if (!Sys.isArray(a)) {
                b.textContainer.add(a)
            } else {
                a.forEach(function (c) {
                    b.textContainer.add(c)
                })
            }
        }
        if (b.model.readData("animate") === true) {
            b.textContainer.el.style.paddingLeft = "100%";
            b.textContainer.el.style.width = "auto";
            b.animation.run(b.textContainer.el)
        } else {
            b.textContainer.el.style.paddingLeft = "0";
            b.textContainer.el.style.width = "100%";
            b.animation.removeAnimation(b.textContainer.el)
        }
    }, constructDOMElement: function () {
        var a = this;
        a.container = new Sys.Element({
            id: "ticker",
            tag: "div",
            cls: a.BASE_CSS + " " + a.BACKGROUND_URI,
            renderTo: a.RENDER_TARGET
        });
        a.textContainer = new Sys.Element({tag: "div", cls: a.CONTENT_CSS});
        a.container.add(a.textContainer)
    }, setupAnimation: function () {
        var a = this;
        if (!Sys.isDefined(a.animation)) {
            a.animationConfig = {
                name: "scrollingAnimation",
                duration: a.ANIMATION_SPEED,
                timingFunction: "linear",
                iterationCount: "infinite",
                frames: {
                    "0%": {
                        "-webkit-transform": "translateX(0);",
                        "-moz-transform": "translateX(0);",
                        "-o-transform": "translateX(0);",
                        "-MS-transform": "translateX(0);",
                        transform: "translateX(0);"
                    },
                    "100%": {
                        "-webkit-transform": "translateX(-100%);",
                        "-moz-transform": "translateX(-100%);",
                        "-o-transform": "translateX(-100%);",
                        "-MS-transform": "translateX(-100%);",
                        transform: "translateX(-100%);"
                    }
                }
            };
            a.animation = new Interface.utils.CSSAnimation(a.animationConfig)
        }
    }, onOrientationChange: function () {
        var a = this.container.el;
        if (Platform.isEdgeBrowser) {
            setTimeout(function () {
                a.style.visibility = "hidden";
                setTimeout(function () {
                    a.style.visibility = ""
                }, 200)
            }, 150)
        }
    }
};
Interface.TickerMobileView = Sys.extend(Interface.TickerBaseView, Interface.TickerMobileView, "Interface.TickerMobileView");
Sys.ns("Interface");
Interface.TickerController = {
    constructor: function () {
        Interface.TickerController.superclass.constructor.apply(this, arguments)
    }, setupEvents: function () {
        var a = this;
        a.on({
            "request:ticker.enable": a.enable,
            "request:ticker.disable": a.disable,
            "request:ticker.setText": a.setText,
            "notify:scaling.gameSizeChanged": a.onGameSizeChanged,
            "view:enabled": a.viewEnabled,
            "view:disabled": a.viewDisabled
        })
    }, onGameSizeChanged: function () {
        if (Sys.isFunc(this.view.onOrientationChange)) {
            this.view.onOrientationChange()
        }
    }, enable: function (c, a) {
        var b = this;
        b.addProperty("enabled", c);
        b.model.storeData("animate", a === true);
        b.view.enable()
    }, disable: function (b) {
        var a = this;
        a.removeProperty("enabled", b);
        a.model.storeData("animate", false);
        a.view.disable()
    }, setText: function (b) {
        var a = this;
        a.model.storeData("content", b);
        a.view.update()
    }, viewEnabled: function () {
        var c = this, b = c.model.readData("spinButtonAlignment") || false,
            a = {orientation: "portrait", vertical: 0.13};
        if (b === false) {
            c.model.storeData("spinButtonAlignment", true);
            c.fireEvent("request:spinButton.moveButton", a)
        }
        c.fireEvent("request:balanceDisplay.addClass", "ticker")
    }, viewDisabled: function () {
        var c = this, b = c.model.readData("spinButtonAlignment") || false,
            a = {orientation: "portrait", vertical: -0.13};
        if (b === true) {
            c.model.storeData("spinButtonAlignment", false);
            c.fireEvent("request:spinButton.moveButton", a)
        }
        c.fireEvent("request:balanceDisplay.removeClass", "ticker")
    }
};
Interface.TickerController = Sys.extend(Core.Controller, Interface.TickerController, "Interface.TickerController");
Sys.ns("Interface");
Interface.RoundStartButton = {
    constructor: function () {
        Interface.RoundStartButton.superclass.constructor.apply(this, arguments)
    }, getMixinDependencies: function () {
        return ["orientation", "userInput", "properties"]
    }, getDefaultMVCClasses: function () {
        return {
            model: Interface.RoundStartButtonModel,
            view: Interface.RoundStartButtonBaseView,
            controller: Interface.RoundStartButtonController
        }
    }
};
Interface.RoundStartButton = Sys.extend(Core.Module, Interface.RoundStartButton, "Interface.RoundStartButton");
Sys.ns("Game.Slots");
Interface.RoundStartButtonController = {
    ROUND_START_EVENT: undefined, constructor: function () {
        Interface.RoundStartButtonController.superclass.constructor.apply(this, arguments);
        this.view.setUpDOMStructure();
        this.properties = {}
    }, setupEvents: function () {
        var a = this, b = {
            "notify:stateHandler.enteringIdleState": a.onEnteringIdleState,
            "notify:stateHandler.leavingIdleState": a.onLeavingIdleState,
            "notify:stateHandler.leavingBeforeLoaderCloseState": a.onLeavingIdleState,
            "notify:gameModeChanged": a.onGameModeChanged,
            "view:clicked": a.onClick,
            "view:hidden": a.fireEvent.bind(a, "notify:" + a.MODULE_NAME + ".hidden"),
            "view:shown": a.fireEvent.bind(a, "notify:" + a.MODULE_NAME + ".shown"),
            "view:pressed": a.fireEvent.bind(a, "notify:" + a.MODULE_NAME + ".pressed"),
            "view:released": a.fireEvent.bind(a, "notify:" + a.MODULE_NAME + ".released"),
            "view:disable": a.disable.bind(a),
            "view:hide": a.hide.bind(a),
            "view:show": a.show.bind(a),
            "view:enable": a.enable.bind(a),
            "request:enableBasicGamePanel": a.enable,
            "request:disableBasicGamePanel": a.disable
        };
        b["request:" + a.MODULE_NAME + ".hide"] = a.hideRequested;
        b["request:" + a.MODULE_NAME + ".show"] = a.show;
        b["request:" + a.MODULE_NAME + ".enable"] = a.enable;
        b["request:" + a.MODULE_NAME + ".disable"] = a.disableRequested;
        b["request:" + a.MODULE_NAME + ".addDisplayType"] = a.addDisplayType;
        b["request:" + a.MODULE_NAME + ".removeDisplayType"] = a.removeDisplayType;
        b["request:" + a.MODULE_NAME + ".addProperty"] = a.addProperty;
        b["request:" + a.MODULE_NAME + ".removeProperty"] = a.removeProperty;
        a.on(b)
    }, onUserInputStart: function (a) {
        this.view.userInputStart(a)
    }, onUserInputMove: function (a) {
        this.view.userInputMove(a)
    }, onUserInputHover: function (a) {
        this.view.userInputHover(a)
    }, onUserInputEnd: function (a) {
        this.view.userInputEnd(a)
    }, onClick: function () {
        this.fireEvent(this.ROUND_START_EVENT)
    }, removeProperty: function (c, b) {
        var a = this;
        if (a.model.hasProperty(c)) {
            a.model.removeProperty(c, b);
            if (!a.model.hasProperty(c)) {
                a.updateAppearance()
            }
            if (!a.model.readData("inIdleState") && !a.model.hasProperty("visibleDuringRound")) {
                a.hide(a.MODULE_NAME)
            }
        }
    }, addDisplayType: function (b) {
        var a = !this.model.hasDisplayType(b);
        this.model.addDisplayType(b);
        if (a) {
            this.updateAppearance()
        }
    }, removeDisplayType: function (a) {
        var b = this;
        if (b.model.hasDisplayType(a)) {
            b.model.removeDisplayType(a);
            if (!b.model.hasDisplayType(a)) {
                b.updateAppearance()
            }
        }
    }, updateAppearance: function () {
    }, hide: function (a) {
        this.addProperty("hidden", a)
    }, hideRequested: function (a) {
        this.view.hideRequested(a)
    }, show: function (a) {
        this.removeProperty("hidden", a)
    }, enable: function (a) {
        this.removeProperty("disabled", a)
    }, disable: function (a) {
        this.addProperty("disabled", a)
    }, disableRequested: function (a) {
        this.view.disableRequested(a)
    }, onEnteringIdleState: function () {
        var a = this;
        a.model.storeData("inIdleState", true);
        a.show(a.MODULE_NAME)
    }, onLeavingIdleState: function () {
        var a = this;
        a.model.storeData("inIdleState", false);
        if (!a.model.hasProperty("visibleDuringRound")) {
            a.hide(a.MODULE_NAME)
        }
    }, onGameModeChanged: function (b) {
        var a = this;
        a.model.storeData("currentGameMode", b);
        if (b === "BASIC") {
            a.enable("notInBasicGame");
            a.show("globalRequest");
            a.view.show()
        } else {
            a.disable("notInBasicGame");
            a.hide("globalRequest");
            a.view.disableRequested("notInBasicGame");
            a.view.hideRequested("globalRequest");
            a.updateVisibility()
        }
    }
};
Interface.RoundStartButtonController = Sys.extend(Core.Controller, Interface.RoundStartButtonController, "Interface.RoundStartButtonController");
Sys.ns("Interface");
Interface.RoundStartButtonModel = {
    DISPLAY_TYPES: {},
    PROPERTIES: {hidden: [], visibleDuringRound: [], visibleOnInput: []},
    constructor: function () {
        Interface.RoundStartButtonModel.superclass.constructor.apply(this, arguments)
    },
    setupData: function () {
        var b = Resources.readData("gameServerInitResponseObject"), a = b.gamestate ? b.gamestate : undefined,
            c = a ? a.current : undefined;
        this.data = {
            properties: this.PROPERTIES,
            displayTypes: this.DISPLAY_TYPES,
            currentGameMode: c ? c.toUpperCase() : undefined
        }
    },
    hasDisplayType: function (a) {
        return this.readData("displayTypes")[a]
    },
    addDisplayType: function (a) {
        this.readData("displayTypes")[a] = true
    },
    removeDisplayType: function (a) {
        this.readData("displayTypes")[a] = false
    }
};
Interface.RoundStartButtonModel = Sys.extend(Core.Model, Interface.RoundStartButtonModel, "Interface.RoundStartButtonModel");
Sys.ns("Interface");
Interface.RoundStartButtonBaseView = {
    BUTTON_ID: "roundStartButton",
    BASE_CSS: "interface-roundStartButton_base",
    PRESSED_CSS: "interface-roundStartButton_pressed",
    URI_BASE_CSS: "interface-roundStartButton",
    PORTRAIT_POSITION: {TOP: 0.5, LEFT: 0.5},
    LANDSCAPE_POSITION: {TOP: 0.5, LEFT: 0.5},
    PORTRAIT_SIZE: {ASPECT_RATIO: 1, HEIGHT: 0.2},
    LANDSCAPE_SIZE: {ASPECT_RATIO: 1, WIDTH: 0.2},
    RENDER_TARGET: "gameWrapper",
    constructor: function () {
        Interface.RoundStartButtonBaseView.superclass.constructor.apply(this, arguments)
    },
    setUpDOMStructure: function () {
        var a = this;
        a.container = new Sys.Element({
            tag: "div",
            id: a.BUTTON_ID,
            cls: a.BASE_CSS + " " + a.URI_BASE_CSS + "_default_uri",
            renderTo: a.RENDER_TARGET
        });
        a.model.storeData("currentUri", a.URI_BASE_CSS + "_default_uri");
        a.show();
        if (Sys.isDefined(a.model.hasProperty) && !a.model.hasProperty("hidden")) {
            a.show()
        } else {
            a.hide()
        }
    },
    userInputStart: function (c) {
        var b = this, a = b.isInputTarget(c);
        if (a) {
            if (!b.hidden()) {
                b.press()
            }
        } else {
            if (b.shouldBeHiddenByUserInput(c)) {
                b.hide()
            }
        }
        b.model.storeData("wasInitialInputTarget", a)
    },
    shouldBeHiddenByUserInput: function (a) {
        return !this.model.hasProperty("visibleOnInput") && Sys.UserInputUtils.isCoordinateTarget(Game.stage.getGameContainer(), a)
    },
    userInputMove: function (c) {
        var b = this, a = b.isInputTarget(c);
        if (b.model.readData("wasInitialInputTarget") && !a) {
            b.userInputEnd(c)
        }
    },
    userInputHover: function (a) {
    },
    userInputEnd: function (c) {
        var b = this, a;
        if (b.model.readData("wasInitialInputTarget")) {
            a = b.isInputTarget(c);
            b.release(a);
            if (a) {
                b.fireEvent("view:clicked")
            }
        } else {
            if (!b.model.hasProperty("hidden")) {
                b.show()
            }
        }
        b.model.storeData("wasInitialInputTarget", false)
    },
    isInputTarget: function (a) {
        return Sys.UserInputUtils.isCoordinateTarget(this.container.el, a)
    },
    press: function () {
        this.container.addCls(this.PRESSED_CSS);
        this.fireEvent("view:pressed")
    },
    release: function (a) {
        this.container.removeCls(this.PRESSED_CSS);
        this.fireEvent("view:released", a)
    },
    hide: function () {
        if (!this.hidden()) {
            this.container.el.style.display = "none";
            this.fireEvent("view:hidden")
        }
    },
    hidden: function () {
        return this.container.el.style.display === "none"
    },
    show: function () {
        if (this.hidden()) {
            this.container.el.style.display = "block";
            this.fireEvent("view:shown")
        }
    },
    enable: function () {
        this.container.el.style.opacity = 1
    },
    disable: function () {
        this.container.el.style.opacity = 0.5
    },
    setAppearance: function (c) {
        var d = this.URI_BASE_CSS + "_" + c + "_uri", b = this.container, a = this.model.readData("currentUri");
        b.replaceCSSClass(a, d, true);
        this.model.storeData("currentUri", d)
    },
    disableRequested: function (a) {
        this.fireEvent("view:disable", a)
    },
    hideRequested: function (a) {
        if (Sys.isDefined(a)) {
            this.fireEvent("view:hide", a)
        } else {
            this.hide()
        }
    },
    beforeLoaderClose: function () {
    }
};
Interface.RoundStartButtonBaseView = Sys.extend(Core.View, Interface.RoundStartButtonBaseView, "Interface.RoundStartButtonBaseView");
Sys.ns("Interface.Slots");
Interface.Slots.SpinButton = {
    constructor: function () {
        Interface.Slots.SpinButton.superclass.constructor.apply(this, arguments)
    }, getMixinDependencies: function () {
        return {
            fallback: ["orientation", "userInput", "properties", "trigger"],
            desktop: [{userInput: {inputEvents: ["start", "end", "cancel", "move", "hover"]}}, "properties", "animation", "trigger"]
        }
    }, getDefaultMVCClasses: function () {
        return {
            model: Interface.Slots.SpinButtonModel,
            view: Interface.Slots.SpinButtonBaseView,
            controller: Interface.Slots.SpinButtonController
        }
    }
};
Interface.Slots.SpinButton = Sys.extend(Interface.RoundStartButton, Interface.Slots.SpinButton, "Interface.Slots.SpinButton");
Sys.ns("Interface.Slots");
Interface.Slots.SpinButtonController = {
    ROUND_START_EVENT: "request:spin.startNewRound",
    AUTOPLAY_START_EVENT: "request:spinSettings.startAutoPlay",
    constructor: function () {
        Interface.Slots.SpinButtonController.superclass.constructor.apply(this, arguments)
    },
    setupEvents: function () {
        var a = this;
        Interface.Slots.SpinButtonController.superclass.setupEvents.apply(this, arguments);
        a.on({
            "view:setSafeArea": a.fireEvent.bind(a, "request:fullscreen.setSafeArea"),
            "request:spinButton.startRound": a.startRound,
            "request:spinButton.showCounter": a.showCounter,
            "request:spinButton.hideCounter": a.hideCounter,
            "request:spinButton.updateCounter": a.updateCounter,
            "request:spinButton.pressed": a.onPressedRequest,
            "request:spinButton.released": a.onReleasedRequest,
            "request:spinButton.moveButton": a.onMoveButtonRequest,
            "notify:settingsManager.settingChanged": a.settingsChanged,
            "notify:stateHandler.enteringFreeSpinIntroState": a.onEnteringFreespinIntro,
            "notify:stateHandler.leavingFreeSpinIntroState": a.onLeavingFreespinIntro,
            "notify:stateHandler.enteringFreeSpinOutroState": a.onEnteringFreespinOutro,
            "notify:stateHandler.leavingFreeSpinOutroState": a.onLeavingFreespinOutro,
            "notify:stateHandler.leavingBeforeLoaderCloseState": a.onBeforeLoaderClose,
            "view:playSound": a.playSoundForView,
            "view:notify": a.onViewNotify
        });
        if (Sys.isGcmEnabled) {
            a.on({
                "notify:stateHandler.enteringspinTypeRespinRestoreState": a.disable,
                "notify:stateHandler.leavingspinTypeRespinRestoreState": a.enable
            })
        }
    },
    registerTriggers: function () {
        Services.trigger.registerTrigger("notify:spinButton.clicked", this, "Executed when the spin button is clicked");
        Services.trigger.registerTrigger("notify:spinButton.up", this, "When the spin button returns to the up state.");
        Services.trigger.registerTrigger("notify:spinButton.hover", this, "Executed when the spin button is hovered");
        Services.trigger.registerTrigger("notify:spinButton.down", this, "Executed when the spin button is down")
    },
    onMoveButtonRequest: function (a) {
        this.view.moveButtonPosition(a);
        this.fireEvent("request:quickSettingsMenu.movePosition", a)
    },
    playSoundForView: function (a) {
        this.fireEvent("request:audioPlayer.play", {name: a})
    },
    startRound: function () {
        this.fireEvent(this.ROUND_START_EVENT)
    },
    onPressedRequest: function () {
        if (this.model.readData("inIdleState")) {
            this.view.onPressedRequest()
        }
    },
    onReleasedRequest: function () {
        if (this.model.readData("inIdleState")) {
            this.view.onReleasedRequest()
        }
    },
    onLandscape: function () {
        var a = this;
        Mixins.orientation.controller.methods.onLandscape.apply(a, arguments);
        if (a.model.hasProperty("hidden")) {
            if (a.view.canInteractWhileHidden()) {
                a.startListeningToUserInput()
            } else {
                a.stopListeningToUserInput()
            }
        }
    },
    onPortrait: function () {
        var a = this;
        Mixins.orientation.controller.methods.onPortrait.apply(a, arguments);
        if (a.model.hasProperty("hidden")) {
            if (a.view.canInteractWhileHidden()) {
                a.startListeningToUserInput()
            } else {
                a.stopListeningToUserInput()
            }
        }
    },
    onEnteringIdleState: function () {
        var a = this;
        Interface.Slots.SpinButtonController.superclass.onEnteringIdleState.apply(a, arguments);
        if (a.model.hasProperty("disabledDuringRound")) {
            a.enable(a.MODULE_NAME)
        }
        a.view.disableSpinningAnimations()
    },
    onLeavingIdleState: function () {
        var a = this;
        Interface.Slots.SpinButtonController.superclass.onLeavingIdleState.apply(a, arguments);
        if (a.model.hasProperty("disabledDuringRound")) {
            a.disable(a.MODULE_NAME)
        }
        if (!a.model.hasProperty("disabled")) {
            a.view.enableSpinningAnimations()
        }
    },
    onBeforeLoaderClose: function () {
        this.view.beforeLoaderClose();
        this.updateAppearance();
        this.view.setFullscreenSafeArea()
    },
    onClick: function () {
        var b = this, a = b.model;
        if (a.hasProperty("hidden")) {
            if (b.view.canInteractWhileHidden()) {
                b.fireEvent("notify:spinButton.clickedWhileHidden")
            }
        } else {
            b.fireEvent("request:audioPlayer.play", {name: "spinButtonClick"});
            b.fireEvent("notify:spinButton.clicked", {skip: a.readData("noStopOnSpin")});
            if (a.readData("inIdleState")) {
                if (a.hasDisplayType("autoPlay")) {
                    b.fireEvent(b.AUTOPLAY_START_EVENT)
                } else {
                    b.fireEvent(b.ROUND_START_EVENT)
                }
            }
        }
    },
    onViewNotify: function (a) {
        this.fireEvent(a)
    },
    showCounter: function (a) {
        this.view.showCounter();
        if (Sys.isDefined(a)) {
            this.view.updateCounter(a)
        }
    },
    hideCounter: function () {
        this.view.hideCounter()
    },
    updateCounter: function (a) {
        this.view.updateCounter(a)
    },
    updateAppearance: function () {
        var c = this, b = c.model, a = "default";
        if (b.hasDisplayType("autoPlay")) {
            a = "autoPlay"
        } else {
            if (b.hasDisplayType("autoPlayStop")) {
                a = "autoPlayStop"
            } else {
                if (b.hasDisplayType("quickSpin")) {
                    a = "quickSpin"
                }
            }
        }
        c.view.setAppearance(a);
        c.updateVisibility()
    },
    updateVisibility: function () {
        var b = this, c = b.model.hasProperty("hidden"), a = b.model.hasProperty("disabled");
        if (c) {
            b.view.hide()
        } else {
            b.view.show()
        }
        if (a) {
            b.view.disable()
        } else {
            b.view.enable()
        }
        if (!a && (!c || b.view.canInteractWhileHidden())) {
            b.startListeningToUserInput()
        } else {
            b.stopListeningToUserInput()
        }
    },
    settingsChanged: function (a, c) {
        var b = this;
        if (a === "leftHandMode") {
            b.model.storeData("leftHandMode", c);
            b.view.setPosition()
        }
    },
    onEnteringFreespinIntro: function () {
        this.hide(this.MODULE_NAME)
    },
    onLeavingFreespinIntro: function () {
        this.show(this.MODULE_NAME)
    },
    onEnteringFreespinOutro: function () {
        this.hide(this.MODULE_NAME)
    },
    onLeavingFreespinOutro: function () {
        this.show(this.MODULE_NAME)
    }
};
Interface.Slots.SpinButtonController = Sys.extend(Interface.RoundStartButtonController, Interface.Slots.SpinButtonController, "Interface.Slots.SpinButtonController");
Sys.ns("Interface.Slots");
Interface.Slots.SpinButtonModel = {
    DISPLAY_TYPES: {autoPlay: false, autoPlayStop: false, quickSpin: false},
    constructor: function () {
        Interface.Slots.SpinButtonModel.superclass.constructor.apply(this, arguments)
    },
    setupData: function () {
        var a = Services.localStorageManager.hasData("leftHandMode") && Services.localStorageManager.readData("leftHandMode") === "true";
        Interface.Slots.SpinButtonModel.superclass.setupData.apply(this, arguments);
        this.storeData("leftHandMode", a)
    }
};
Interface.Slots.SpinButtonModel = Sys.extend(Interface.RoundStartButtonModel, Interface.Slots.SpinButtonModel, "Interface.Slots.SpinButtonModel");
Sys.ns("Interface.Slots");
Interface.Slots.SpinButtonBaseView = {
    BUTTON_ID: "spinButton",
    BASE_CSS: "interface-roundStartButton_base",
    URI_BASE_CSS: "interface-spinButton",
    COUNTER_BASE_CSS: "utils_center interface-spinButton_counter",
    BUTTON_POSITION: {
        PORTRAIT: {LEFT: {RIGHT: 0.5}, RIGHT: {LEFT: 0.5}},
        LANDSCAPE: {LEFT: {RIGHT: 0.5}, RIGHT: {LEFT: 0.5}}
    },
    constructor: function () {
        Interface.Slots.SpinButtonBaseView.superclass.constructor.apply(this, arguments)
    },
    setUpDOMStructure: function () {
        var a = this;
        a.updatePositionProperties();
        Interface.Slots.SpinButtonBaseView.superclass.setUpDOMStructure.apply(a, arguments);
        a.counter = new Sys.Element({tag: "div", cls: a.COUNTER_BASE_CSS, style: "display:none;"});
        a.container.add(a.counter)
    },
    setFullscreenSafeArea: function () {
        var a = this;
        a.fireEvent("view:setSafeArea", "spinButton", {element: a.container.getEl()})
    },
    showCounter: function () {
        this.counter.el.style.display = "block"
    },
    hideCounter: function () {
        this.counter.el.style.display = "none"
    },
    updateCounter: function (a) {
        this.counter.el.textContent = a
    },
    setStyle: function (c) {
        var d = this, a = d.counter, b = c === "LANDSCAPE" ? "PORTRAIT" : "LANDSCAPE";
        Mixins.orientation.view.methods.setStyle.call(d, c);
        a.removeCls(d["COUNTER_" + b + "_CSS"]);
        a.addCls(d["COUNTER_" + c + "_CSS"])
    },
    canInteractWhileHidden: function () {
        return false
    },
    setPosition: function (a) {
        this.updatePositionProperties();
        Mixins.orientation.view.methods.setPosition.call(this, a || this.currentOrientation)
    },
    updatePositionProperties: function () {
        var b = this, a = b.model.readData("leftHandMode") ? "LEFT" : "RIGHT";
        b.LANDSCAPE_POSITION = b.BUTTON_POSITION.LANDSCAPE[a];
        b.PORTRAIT_POSITION = b.BUTTON_POSITION.PORTRAIT[a]
    },
    enable: function () {
        if (!this.model.hasProperty("hidden")) {
            this.show()
        }
    },
    disable: function () {
        this.hide()
    },
    enableSpinningAnimations: function () {
    },
    disableSpinningAnimations: function () {
    },
    onPressedRequest: function () {
    },
    onReleasedRequest: function () {
    },
    moveButtonPosition: function () {
    }
};
Interface.Slots.SpinButtonBaseView = Sys.extend(Interface.RoundStartButtonBaseView, Interface.Slots.SpinButtonBaseView, "Interface.Slots.SpinButtonBaseView");
Sys.ns("Interface.Slots");
Interface.Slots.SpinButtonMobileView = {
    BUTTON_POSITION: {
        PORTRAIT: {
            LEFT: {
                BELOW_GAME: true,
                TOP: 0.4,
                LEFT: 0.5,
                MIN_TOP: 825
            }, RIGHT: {BELOW_GAME: true, TOP: 0.4, LEFT: 0.5, MIN_TOP: 825}
        }, LANDSCAPE: {LEFT: {TOP: 0.5, RIGHT: 0.82}, RIGHT: {TOP: 0.5, LEFT: 0.9}}
    },
    PORTRAIT_POSITION: {BELOW_GAME: true, TOP: 0.4, LEFT: 0.5, MIN_TOP: 825},
    LANDSCAPE_POSITION: {TOP: 0.5, LEFT: 0.9},
    PORTRAIT_SIZE: {VERTICAL_OFFSET: "center", HORIZONTAL_OFFSET: "center", ASPECT_RATIO: 1, WIDTH: 0.296},
    LANDSCAPE_SIZE: {VERTICAL_OFFSET: "center", HORIZONTAL_OFFSET: "center", ASPECT_RATIO: 1, HEIGHT: 0.296},
    constructor: function () {
        var a;
        Interface.Slots.SpinButtonMobileView.superclass.constructor.apply(this, arguments);
        this.canInteract = false;
        a = Resources.readData("config");
        this.hideSpinButtonInMobilePortrait = Sys.isObj(a) && Boolean(a.hideSpinButtonInMobilePortrait)
    },
    shouldBeHiddenByUserInput: function (a) {
        return Interface.Slots.SpinButtonMobileView.superclass.shouldBeHiddenByUserInput.apply(this, arguments) && (Environment.orientation() === "LANDSCAPE" || this.hideSpinButtonInMobilePortrait)
    },
    moveButtonPosition: function (b) {
        var c = this, a;
        if (Sys.isDefined(b)) {
            if (Sys.isDefined(b.orientation)) {
                a = b.orientation.toLowerCase() === "portrait" ? "PORTRAIT" : "LANDSCAPE";
                if (Sys.isDefined(b.vertical)) {
                    c.BUTTON_POSITION[a].LEFT.TOP = c.BUTTON_POSITION[a].LEFT.TOP + b.vertical;
                    c.BUTTON_POSITION[a].RIGHT.TOP = c.BUTTON_POSITION[a].RIGHT.TOP + b.vertical
                }
                if (Sys.isDefined(b.horizontal)) {
                    c.BUTTON_POSITION[a].LEFT.RIGHT = c.BUTTON_POSITION[a].LEFT.RIGHT + (-1 * b.horizontal);
                    c.BUTTON_POSITION[a].RIGHT.LEFT = c.BUTTON_POSITION[a].RIGHT.LEFT + b.horizontal
                }
            }
            c.setPosition()
        }
    },
    setStyle: function () {
        var a = this;
        Interface.Slots.SpinButtonMobileView.superclass.setStyle.apply(a, arguments);
        if (a.model.hasProperty("hidden")) {
            a.hide()
        } else {
            a.show()
        }
    },
    show: function (a) {
        this.container.el.style.opacity = 1;
        Interface.Slots.SpinButtonMobileView.superclass.show.call(this, a)
    },
    hide: function (a) {
        var b = this;
        if (Environment.orientation() === "PORTRAIT" && !b.hideSpinButtonInMobilePortrait) {
            b.container.el.style.opacity = "0.5";
            b.container.el.style.display = "block";
            b.canInteract = true
        } else {
            b.canInteract = false;
            b.container.el.style.opacity = 1;
            Interface.Slots.SpinButtonMobileView.superclass.hide.call(b, a)
        }
    },
    disable: function () {
        var a = this;
        if (a.model.hasProperty("hidden") && a.model.readData("currentGameMode") === "BASIC") {
            a.hide()
        } else {
            if (a.model.readData("currentGameMode") !== "BASIC") {
                a.fireEvent("view:show", "globalRequest");
                a.fireEvent("view:enable", "notInBasicGame");
                a.fireEvent("view:enable", "freespinSplash")
            }
        }
    },
    disableRequested: function () {
        this.disable()
    },
    hideRequested: function (b) {
        var a = this;
        if (a.model.readData("currentGameMode") === "BASIC") {
            a.fireEvent("view:hide", b)
        } else {
            if (a.model.readData("currentGameMode") !== "BASIC") {
                a.fireEvent("view:show", "globalRequest");
                a.fireEvent("view:enable", "notInBasicGame");
                a.fireEvent("view:enable", "freespinSplash")
            }
        }
    },
    hidden: function () {
        var a = this, b = Environment.orientation() === "PORTRAIT" && a.hideSpinButtonInMobilePortrait;
        return a.container.el.style.display === "none" || (b && a.container.el.style.opacity === "0.5")
    },
    canInteractWhileHidden: function () {
        return this.canInteract
    }
};
Interface.Slots.SpinButtonMobileView = Sys.extend(Interface.Slots.SpinButtonBaseView, Interface.Slots.SpinButtonMobileView, "Interface.Slots.SpinButtonMobileView");
Sys.ns("Interface.Slots");
Interface.Slots.SpinButtonTabletView = {
    BUTTON_POSITION: {
        PORTRAIT: {
            LEFT: {TOP: 0.5, RIGHT: 0.82},
            RIGHT: {TOP: 0.5, LEFT: 0.9}
        }, LANDSCAPE: {LEFT: {TOP: 0.5, RIGHT: 0.82}, RIGHT: {TOP: 0.5, LEFT: 0.9}}
    },
    PORTRAIT_POSITION: {TOP: 0.5, LEFT: 0.9},
    LANDSCAPE_POSITION: {TOP: 0.5, LEFT: 0.9},
    PORTRAIT_SIZE: {VERTICAL_OFFSET: "center", HORIZONTAL_OFFSET: "center", ASPECT_RATIO: 1, HEIGHT: 0.296},
    LANDSCAPE_SIZE: {VERTICAL_OFFSET: "center", HORIZONTAL_OFFSET: "center", ASPECT_RATIO: 1, HEIGHT: 0.222},
    constructor: function () {
        Interface.Slots.SpinButtonTabletView.superclass.constructor.apply(this, arguments)
    },
    disable: function () {
        var a = this;
        if (a.model.hasProperty("hidden") && a.model.readData("currentGameMode") === "BASIC") {
            a.hide()
        } else {
            if (a.model.readData("currentGameMode") !== "BASIC") {
                a.fireEvent("view:show", "globalRequest");
                a.fireEvent("view:enable", "notInBasicGame");
                a.fireEvent("view:enable", "freespinSplash")
            }
        }
    },
    disableRequested: function () {
        this.disable()
    },
    hideRequested: function (b) {
        var a = this;
        if (a.model.readData("currentGameMode") === "BASIC") {
            a.fireEvent("view:hide", b)
        } else {
            if (a.model.readData("currentGameMode") !== "BASIC") {
                a.fireEvent("view:show", "globalRequest");
                a.fireEvent("view:enable", "notInBasicGame");
                a.fireEvent("view:enable", "freespinSplash")
            }
        }
    }
};
Interface.Slots.SpinButtonTabletView = Sys.extend(Interface.Slots.SpinButtonBaseView, Interface.Slots.SpinButtonTabletView, "Interface.Slots.SpinButtonTabletView");
Sys.ns("Interface.Slots");
Interface.Slots.SpinButtonDesktopView = {
    SOUND_UP: "buttonUp",
    SOUND_DOWN: "buttonDown",
    SOUND_HOVER: "buttonHover",
    IMAGE_UP: "spinButtonIdle",
    IMAGE_DOWN: "spinButtonDown",
    IMAGE_OVER: "spinButtonOver",
    IMAGE_DISABLED: "spinButtonDisabled",
    BUTTON_POSITION: {x: 589, y: 597, width: 103, height: 105, centerX: 640, centerY: 649, radius: 51},
    constructor: function () {
        var a = this;
        Interface.Slots.SpinButtonDesktopView.superclass.constructor.apply(a, arguments);
        a.pressed = false;
        a.isHighlighted = false;
        a.permanentHighlight = false
    },
    initAnimations: function () {
        var c = this, b = new Animation.List({}), a = new Animation.Item({
            top: c.BUTTON_POSITION.y,
            left: c.BUTTON_POSITION.x,
            width: c.BUTTON_POSITION.width,
            height: c.BUTTON_POSITION.height,
            depth: c.getButtonDepth(),
            image: c.IMAGE_UP
        });
        b.add(a);
        Game.stage.view.addToRenderLoop(b);
        c.buttonList = b;
        c.buttonItem = a
    },
    getButtonDepth: function () {
        return 40
    },
    beforeLoaderClose: function () {
        this.fireEvent("view:addProperty", "visibleDuringRound", this.MODULE_NAME)
    },
    setUpDOMStructure: function () {
    },
    press: function () {
        var a = this;
        a.fireEvent("view:playSound", a.SOUND_DOWN);
        a.fireEvent("view:notify", "notify:spinButton.down");
        a.buttonItem.prop.image = a.IMAGE_DOWN
    },
    release: function () {
        this.buttonItem.prop.image = this.isHighlighted ? this.IMAGE_OVER : this.IMAGE_UP
    },
    enable: function () {
        this.playButtonSpecialEffects();
        this.buttonItem.prop.image = this.isHighlighted ? this.IMAGE_OVER : this.IMAGE_UP
    },
    disable: function () {
        this.removeHighlight();
        this.stopButtonSpecialEffects();
        this.buttonItem.prop.image = this.IMAGE_DISABLED
    },
    disableRequested: function (a) {
        this.fireEvent("view:disable", a)
    },
    userInputStart: function (b) {
        var a = this.isCollision(b) && !this.pressed;
        if (a) {
            this.press()
        }
        this.model.storeData("wasInitialInputTarget", a)
    },
    userInputMove: function (a) {
        if (this.model.readData("wasInitialInputTarget")) {
            this.toggleHighlight(a, true)
        }
    },
    userInputHover: function (a) {
        if (!this.pressed) {
            this.toggleHighlight(a)
        }
    },
    userInputEnd: function (c) {
        var b = this, a;
        if (b.model.readData("wasInitialInputTarget")) {
            a = b.isCollision(c);
            b.release(a);
            if (a) {
                if (!b.model.readData("noStopOnSpin")) {
                    b.model.storeData("noStopOnSpin", true)
                }
                b.fireEvent("view:clicked")
            }
        }
        b.model.storeData("wasInitialInputTarget", false)
    },
    enableSpinningAnimations: function () {
        this.addHighlight(false, true);
        this.permanentHighlight = true
    },
    disableSpinningAnimations: function () {
        this.permanentHighlight = false;
        if (!this.isHoveredOver) {
            this.removeHighlight()
        }
    },
    shouldBeHiddenByUserInput: function () {
    },
    hide: function () {
        var a = this;
        if (a.model.hasProperty("hidden") || !a.model.hasProperty("visibleDuringRound")) {
            a.buttonList.stop();
            a.fireEvent("view:hidden")
        }
    },
    hidden: function () {
    },
    show: function () {
        this.buttonList.play();
        this.fireEvent("view:shown")
    },
    setAppearance: function (a) {
    },
    canInteractWhileHidden: function () {
        return false
    },
    showCounter: function () {
    },
    updateCounter: function () {
    },
    hideCounter: function () {
    },
    onPressedRequest: function () {
        this.pressed = true;
        this.press()
    },
    onReleasedRequest: function () {
        this.pressed = false;
        this.release(true);
        this.fireEvent("view:clicked")
    },
    toggleHighlight: function (c, b) {
        var a = this;
        if (a.isCollision(c)) {
            if (!a.isHoveredOver) {
                a.fireEvent("view:playSound", a.SOUND_HOVER);
                a.fireEvent("view:notify", "notify:spinButton.hover")
            }
            a.isHoveredOver = true;
            a.addHighlight(b)
        } else {
            if (a.isHoveredOver) {
                a.fireEvent("view:playSound", a.SOUND_UP);
                a.fireEvent("view:notify", "notify:spinButton.up")
            }
            a.isHoveredOver = false;
            a.removeHighlight(b)
        }
    },
    isCollision: function (h) {
        var e = this, c = Sys.UserInputUtils.getCoordinatesRelativeToElement(h, Game.stage.getGameContainer()),
            f = Environment.getWindowToVirtualScale(3), a = e.BUTTON_POSITION, d = Math.abs((c.x * f) - a.centerX),
            b = Math.abs((c.y * f) - a.centerY), g = Math.sqrt((d * d) + (b * b));
        return (g <= a.radius)
    },
    addHighlight: function (c, a) {
        var b = this;
        if ((!b.isHighlighted || a) && !b.permanentHighlight) {
            b.isHighlighted = true;
            b.buttonItem.prop.image = b.IMAGE_OVER;
            if (c) {
                b.press()
            }
        }
    },
    removeHighlight: function (b) {
        var a = this;
        if (a.isHighlighted && !a.permanentHighlight) {
            a.isHighlighted = false;
            a.buttonItem.prop.image = this.IMAGE_UP;
            if (b) {
                a.playButtonSpecialEffects()
            }
        }
    },
    stopButtonSpecialEffects: function () {
    },
    playButtonSpecialEffects: function () {
    },
    setFullscreenSafeArea: function () {
    }
};
Interface.Slots.SpinButtonDesktopView = Sys.extend(Interface.RoundStartButtonBaseView, Interface.Slots.SpinButtonDesktopView, "Interface.Slots.SpinButtonDesktopView");
Sys.ns("Interface.Slots");
Interface.Slots.MaxBetButton = {
    constructor: function () {
        Interface.Slots.MaxBetButton.superclass.constructor.apply(this, arguments)
    }, getMixinDependencies: function () {
        return ["animation", "trigger"]
    }, getDefaultMVCClasses: function () {
        return {
            model: Interface.Slots.MaxBetButtonModel,
            controller: Interface.Slots.MaxBetButtonController,
            view: Interface.Slots.MaxBetButtonBaseView
        }
    }
};
Interface.Slots.MaxBetButton = Sys.extend(Core.Module, Interface.Slots.MaxBetButton, "Interface.Slots.MaxBetButton");
Sys.ns("Interface.Slots");
Interface.Slots.MaxBetButtonModel = {
    constructor: function () {
        Interface.Slots.MaxBetButtonModel.superclass.constructor.apply(this, arguments)
    }, setupData: function () {
        var d = Resources.readData("gameServerInitResponseObject").betlevel.all, a = Resources.readData("config"),
            b = Object.keys(a.winSituationsDisplay.betlines.numbers.configurations),
            e = a.winSituationsDisplay.winSituationMinimumDisplayTime, c = 0;
        Interface.Slots.MaxBetButtonModel.superclass.setupData.apply(this, arguments);
        Sys.each(d, function (f) {
            c = Math.max(f, c)
        });
        this.storeData("maxBetLevel", c);
        this.storeData("betlines", b);
        this.storeData("winSituationMinimumDisplayTime", e)
    }
};
Interface.Slots.MaxBetButtonModel = Sys.extend(Core.Model, Interface.Slots.MaxBetButtonModel, "Interface.Slots.MaxBetButtonModel");
Sys.ns("Interface.Slots");
Interface.Slots.MaxBetButtonController = {
    ROUND_START_EVENT: "request:spin.startNewRound", constructor: function () {
        Interface.Slots.MaxBetButtonController.superclass.constructor.apply(this, arguments)
    }, setupEvents: function () {
        var a = this;
        a.on({
            "notify:stateHandler.leavingBeforeLoaderCloseState": a.disable.bind(a, "notInIdleState"),
            "notify:stateHandler.leavingIdleState": a.onLeavingIdleState,
            "notify:stateHandler.enteringIdleState": a.enable.bind(a, "notInIdleState"),
            "notify:gameModeChanged": a.onGameModeChanged,
            "notify:freeRounds.ended": a.refreshModelData,
            "notify:freeRounds.reInitResponseReceived": a.refreshModelData,
            "view:clicked": a.onClick,
            "request:enableBasicGamePanel": a.enable,
            "request:disableBasicGamePanel": a.disable,
            "request:maxBetButton.enable": a.enable,
            "request:maxBetButton.disable": a.disable
        })
    }, registerTriggers: function () {
        Services.trigger.registerTrigger("notify:maxBetButton.startedRound", this, "When the max bet button is clicked and started a round.")
    }, onClick: function () {
        var d = this, b = Services.settingsManager.getSetting("betLevel"), c = d.model.readData("maxBetLevel"), a;
        if (b < c) {
            d.fireEvent("request:settingsManager.storeData", "betLevel", c);
            a = d.model.readData("betlines");
            d.fireEvent("request:winSituations.showDisplayBetline", a, "maxBetButton");
            setTimeout(d.fireEvent.bind(d, "request:winSituations.hideDisplayBetline", "maxBetButton"), d.model.readData("winSituationMinimumDisplayTime"))
        } else {
            d.startRound()
        }
    }, onGameModeChanged: function (a) {
        if (a === "BASIC") {
            this.view.show("gameModeNotBasic")
        } else {
            this.view.hide("gameModeNotBasic")
        }
    }, onLeavingIdleState: function () {
        var a = this;
        a.disable("notInIdleState");
        a.fireEvent("request:winSituations.hideDisplayBetline", "maxBetButton")
    }, startRound: function () {
        var a = this;
        a.fireEvent("request:audioPlayer.play", {name: "spinButtonClick"});
        a.fireEvent(a.ROUND_START_EVENT);
        a.fireEvent("notify:maxBetButton.startedRound")
    }, enable: function (a) {
        this.view.enable(a)
    }, disable: function (a) {
        this.view.disable(a)
    }, refreshModelData: function () {
        this.model.setupData()
    }
};
Interface.Slots.MaxBetButtonController = Sys.extend(Core.Controller, Interface.Slots.MaxBetButtonController, "Interface.Slots.MaxBetButtonController");
Sys.ns("Interface.Slots");
Interface.Slots.MaxBetButtonBaseView = {
    KEYPAD_BUTTON_CONFIG: {
        dimensions: {x: 700, y: 613, width: 143, height: 72},
        buttonImages: {
            up: "maxBetButtonUp",
            down: "maxBetButtonDown",
            hover: "maxBetButtonOver",
            disabled: "maxBetButtonDisabled"
        },
        buttonLabel: {
            width: 133,
            height: 67,
            text: Language.Keys.btn_maxbet,
            breakOn: "<br>",
            font: "24px NetentStandardUI",
            lineHeight: 24,
            color: "#000000",
            alignment: "center"
        }
    }, constructor: function () {
        Interface.Slots.MaxBetButtonBaseView.superclass.constructor.apply(this, arguments)
    }, show: function (a) {
        this.keypadButton.show(a)
    }, hide: function (a) {
        this.keypadButton.hide(a)
    }, enable: function (a) {
        this.keypadButton.enable(a)
    }, disable: function (a) {
        this.keypadButton.disable(a)
    }, onButtonClick: function () {
        this.fireEvent("view:clicked")
    }, initAnimations: function () {
        this.setUpKeypadButton()
    }, setUpKeypadButton: function () {
        var b = this, a = Sys.applyProperties({clickCallback: b.onButtonClick.bind(b)}, b.KEYPAD_BUTTON_CONFIG);
        a.buttonLabel.depth = Layering.Game.Slots.Keypad.maxBet.label;
        if (Sys.isDefined(a.buttonLayoutParameters)) {
            a.buttonLayoutParameters.depth = Layering.Game.Slots.Keypad.maxBet.button
        } else {
            a.dimensions.depth = Layering.Game.Slots.Keypad.maxBet.button
        }
        b.keypadButton = new Interface.utils.CanvasButton(a)
    }, shouldBeHiddenByUserInput: function () {
        return false
    }
};
Interface.Slots.MaxBetButtonBaseView = Sys.extend(Core.View, Interface.Slots.MaxBetButtonBaseView, "Interface.Slots.MaxBetButtonBaseView");
Sys.ns("Core.Slots");
Core.Slots.SpinBaseController = {
    constructor: function () {
        Core.Slots.SpinBaseController.superclass.constructor.apply(this, arguments);
        this.stopper = 0
    }, setupEvents: function () {
        var b = this, c = {
            "request:spin.child.storeServerResponse": b.handleServerResponse,
            "request:spin.child.wantStartSpin": b.startSpin,
            "request:spin.child.wantStopSpin": b.stopSpin,
            "request:spin.child.setSymbols": b.setSymbols,
            "request:spin.child.revertSpin": b.revertSpin
        }, a = "notify:stateHandler.entering" + b.MODULE_NAME + "RestoreState";
        c[a] = b.onRestore;
        b.on(c)
    }, handleServerResponse: function (b) {
        var a = this;
        a.model.storeServerResponse(b);
        if (b.clientaction === "init") {
            a.model.initData();
            if (a.model.readData("active")) {
                a.fireEvent("request:spin.activateInitReelset", "basic", a.model.readData("defaultScene"))
            }
        }
    }, onRestore: function () {
        this.requestRestoreStateDialog();
        this.startSpin()
    }, requestRestoreStateDialog: function () {
        var a = this;
        a.fireEvent("request:dialogWindow.showDialog", {
            title: Services.languageManager.getText(Language.Keys.restoredGameHeader),
            text: Services.languageManager.getText(Language.Keys.continuePlaying),
            buttons: [{
                scope: a,
                text: Services.languageManager.getText(Language.Keys.btn_continue),
                action: function () {
                    a.fireEvent("notify:" + a.MODULE_NAME + "RestoreStateDialog.closed")
                }
            }]
        })
    }, activateReelset: function () {
        var a = this, c = a.model.readData("requestedReelset"), b = a.model.readData("defaultScene");
        a.model.storeData("active", true);
        a.fireEvent("request:spin.activateReelset", c, b)
    }, startSpin: function () {
        var b = this, a = b.model, d = a.readData("requestedReelset"), c = a.readData("defaultScene");
        if (!a.isState("spinning")) {
            b.fireEvent("request:settingsWindow.close");
            if (a.readData("spinRequested")) {
                a.storeData("active", true);
                a.setState("spinning");
                b.fireEvent("request:spin.startSpin", d, c)
            } else {
                a.storeData("active", false)
            }
        }
    }, stopSpin: function () {
        var a = this, b = a.model.readData("serverResponse");
        if (a.model.readData("active")) {
            a.model.setState("stopped");
            a.fireEvent("request:spin.stopSpin", b.reelInfo, b.nearWinList, b)
        }
    }, revertSpin: function () {
        if (this.model.readData("active")) {
            this.model.setState("stopped")
        }
    }
};
Core.Slots.SpinBaseController = Sys.extend(Core.Controller, Core.Slots.SpinBaseController, "Core.Slots.SpinBaseController");
Sys.ns("Core.Slots");
Core.Slots.SpinBaseModel = {
    DEFAULT_SCENE: "base", constructor: function () {
        Core.Slots.SpinBaseModel.superclass.constructor.apply(this, arguments)
    }, setupData: function () {
        Core.Slots.SpinBaseModel.superclass.setupData.apply(this, arguments);
        this.storeData("defaultScene", this.DEFAULT_SCENE)
    }, storeServerResponse: function (b) {
        var a = this;
        a.storeData("serverResponse", b)
    }, initData: function () {
        var b = this, a = Resources.readData("config");
        b.storeData("layeringConfig", a.layering)
    }
};
Core.Slots.SpinBaseModel = Sys.extend(Core.Model, Core.Slots.SpinBaseModel, "Core.Slots.SpinBaseModel");
Sys.ns("Core");
Core.Slots.SpinTypeBasic = {
    constructor: function () {
        Core.Slots.SpinTypeBasic.superclass.constructor.apply(this, arguments)
    }, getStateChanges: function () {
        var a = this.model, b = {
            stopped: {
                queue: [function (c) {
                    if (a.readData("spinRequested")) {
                        c.stateHandler.pushState(c.states.idle)
                    }
                }]
            }
        };
        return b
    }, getDefaultMVCClasses: function () {
        return {model: Core.Slots.SpinTypeBasicModel, controller: Core.Slots.SpinBaseController}
    }
};
Core.Slots.SpinTypeBasic = Sys.extend(Core.Module, Core.Slots.SpinTypeBasic, "Core.Slots.SpinTypeBasic");
Sys.ns("Core.Slots");
Core.Slots.SpinTypeBasicModel = {
    constructor: function () {
        Core.Slots.SpinTypeBasicModel.superclass.constructor.apply(this, arguments)
    }, storeServerResponse: function (c) {
        var b = this, a;
        b.storeData("serverResponse", c);
        if (c.nextaction === "spin") {
            b.storeData("spinRequested", true);
            if (c.next) {
                a = c.next.rs
            } else {
                a = "basic"
            }
            b.storeData("requestedReelset", a)
        } else {
            b.storeData("spinRequested", false)
        }
    }, initData: function () {
        var c = this, b = Resources.readData("gameServerInitResponse"), d = false, a = false;
        Core.Slots.SpinTypeBasicModel.superclass.initData.apply(c, arguments);
        if (b.nextaction === "spin") {
            d = true;
            a = true
        }
        c.storeData("active", d);
        c.storeData("spinRequested", a)
    }
};
Core.Slots.SpinTypeBasicModel = Sys.extend(Core.Slots.SpinBaseModel, Core.Slots.SpinTypeBasicModel, "Core.Slots.SpinTypeBasicModel");
Sys.ns("Core.Slots");
Core.Slots.StandardWin = {
    constructor: function () {
        Core.Slots.StandardWin.superclass.constructor.apply(this, arguments)
    }, getStateChanges: function () {
        var a = this.model, b = {
            standardWinPresentation: {
                state: {
                    name: "StandardWinPresentation", execute: function () {
                    }, waitEvents: {"notify:standardWin.presentationComplete": false}
                }
            }, noWinPresentation: {
                state: {
                    name: "NoWinPresentation", execute: function () {
                    }, waitEvents: {"notify:standardWin.presentationComplete": false}
                }
            }, stopped: {
                queue: [function (c) {
                    if (a.readData("isStandardWin")) {
                        c.stateHandler.pushState(c.states.standardWinPresentation)
                    } else {
                        if (a.readData("isNoWin")) {
                            c.stateHandler.pushState(c.states.noWinPresentation)
                        }
                    }
                }]
            }
        };
        return b
    }, getMixinDependencies: function () {
        return ["serverResponse", "userInput", "waitSequence", "trigger"]
    }, getDefaultMVCClasses: function () {
        return {model: Core.Slots.StandardWinModel, view: Core.View, controller: Core.Slots.StandardWinController}
    }
};
Core.Slots.StandardWin = Sys.extend(Core.Module, Core.Slots.StandardWin, "Core.Slots.StandardWin");
Sys.ns("Core.Slots");
Core.Slots.StandardWinController = {
    constructor: function () {
        Core.Slots.StandardWinController.superclass.constructor.apply(this, arguments)
    }, setupEvents: function () {
        var a = this;
        a.on({
            "notify:stateHandler.enteringStandardWinPresentationState": a.startPresentation,
            "notify:stateHandler.enteringNoWinPresentationState": a.startNoWinPresentation,
            "notify:winBanner.countUpComplete": a.onShowingTotal,
            "notify:coinsField.countUpComplete": a.onShowingTotal,
            "notify:spinButton.clicked": a.handleUserInput,
            "notify:spinButton.clickedWhileHidden": a.handleUserInput,
            "request:abortPresentation": a.handleUserInput,
            "notify:winSituationsDisplay.showingAllWins": a.waitForWinSituationsDisplay
        })
    }, registerTriggers: function () {
        Services.trigger.registerTrigger("notify:standardWin.countupAborted", this, "When the countup is aborted.");
        Services.trigger.registerTrigger("notify:standardWin.presentationComplete", this, "When the standard win presentation has completed.");
        Services.trigger.registerTrigger("notify:standardWin.startPresentation", this, "When the win presentation starts.")
    }, startPresentation: function () {
        var b = this, a = b.model.readData("winClip"), c = b.model.readData("countUpDuration"),
            d = b.model.readData("totalWinDisplayDuration");
        b.fireEvent("request:settingsWindow.close");
        b.startListeningToUserInput();
        b.model.setState("countingUp");
        b.initializeWaitSequence("request:winSituationsDisplay.showAllWins", {
            showDuration: c + d,
            "standardWin:countUpDuration": c,
            "standardWin:showTotalDuration": d
        });
        if (b.model.readData("countUpDisplay") === "winBanner") {
            b.fireEvent("request:winBanner.animate", c)
        } else {
            b.fireEvent("request:coinsField.countUp", c)
        }
        if (a) {
            b.fireEvent("request:audioPlayer.play", {name: a, id: "winClip"})
        }
        b.fireEvent("notify:standardWin.startPresentation", a)
    }, startNoWinPresentation: function () {
        var b = this, a = b.model.readData("noWinDisplayDuration");
        b.fireEvent("request:coinsField.showWin");
        b.fireEvent("request:cashField.showWin");
        b.model.storeData("inNoWinPresentation", true);
        b.noWinTimeout = setTimeout(b.abortNoWinPresentation.bind(b), a)
    }, abortNoWinPresentation: function () {
        var a = this;
        if (a.model.readData("inNoWinPresentation")) {
            clearTimeout(a.noWinTimeout);
            a.endPresentation();
            a.model.storeData("inNoWinPresentation", false)
        }
    }, onUserInputStart: function (a) {
        if (Sys.UserInputUtils.isCoordinateTarget(Game.stage.getGameContainer(), a)) {
            this.handleUserInput()
        }
    }, handleUserInput: function () {
        var a = this;
        if (a.model.readData("inNoWinPresentation")) {
            a.abortNoWinPresentation()
        } else {
            if (a.model.isState("countingUp")) {
                if (a.model.readData("countUpDisplay") === "winBanner") {
                    a.fireEvent("request:winBanner.showTotal", {showUntilStopped: true})
                } else {
                    a.fireEvent("request:coinsField.showWin")
                }
                a.fireEvent("request:audioPlayer.stop", "winClip");
                a.onShowingTotal();
                a.fireEvent("notify:standardWin.countupAborted")
            } else {
                if (a.model.isState("showingTotal")) {
                    a.endPresentation(true)
                }
            }
        }
    }, onShowingTotal: function () {
        var a = this;
        if (a.model.isState("countingUp")) {
            a.model.setState("showingTotal");
            a.fireEvent("notify:standardWin.showingWinTotal");
            a.fireEvent("request:coinsField.showWin");
            a.fireEvent("request:cashField.showWin");
            if (a.eventsToWaitFor.indexOf("notify:winSituationsDisplay.finishedShowingAllWins") === -1) {
                a.showWinTimeout = setTimeout(a.endPresentation.bind(a, false), a.model.readData("totalWinDisplayDuration"))
            }
        }
    }, endPresentation: function (b) {
        var a = this;
        if (!a.model.isState("showingTotal") && !a.model.readData("inNoWinPresentation")) {
            return
        }
        a.stopListeningToUserInput();
        a.model.setState("complete");
        clearTimeout(a.showWinTimeout);
        a.fireEvent("request:winSituationsDisplay.abort");
        a.fireEvent("request:audioPlayer.stop", "winClip");
        if (a.model.readData("countUpDisplay") === "winBanner") {
            a.fireEvent("request:winBanner.hide")
        }
        if (a.model.shouldToggleWins()) {
            a.fireEvent("request:winSituationsDisplay.toggleWins")
        }
        a.fireEvent("notify:standardWin.presentationComplete", b)
    }, waitForWinSituationsDisplay: function () {
        this.onWaitRequested("notify:winSituationsDisplay.finishedShowingAllWins")
    }, onWaitIsComplete: function () {
        this.endPresentation(false)
    }
};
Core.Slots.StandardWinController = Sys.extend(Core.Controller, Core.Slots.StandardWinController, "Core.Slots.StandardWinController");
Sys.ns("Core.Slots");
Core.Slots.StandardWinModel = {
    STANDARD_WIN_TYPES: ["smallWin", "mediumWin", "largeWin"],
    COUNT_UP_DURATIONS: {smallWin: 1000, mediumWin: 2000, largeWin: 3000},
    NO_WIN_DISPLAY_DURATION: 500,
    NO_WIN_DISPLAY_DESKTOP_DURATION: 0,
    TOTAL_WIN_DISPLAY_DURATION: 3000,
    constructor: function () {
        Core.Slots.StandardWinModel.superclass.constructor.apply(this, arguments)
    },
    setupData: function () {
        var a = this;
        a.storeData("inFreeSpins", false);
        a.storeData("noWinDisplayDuration", a.NO_WIN_DISPLAY_DURATION);
        a.storeData("totalWinDisplayDuration", a.TOTAL_WIN_DISPLAY_DURATION);
        a.setupDesktopSpecificData()
    },
    processServerResponse: function (b) {
        var f = this, g = b.currentGameState === "freespin" ? "coinsField" : "winBanner",
            d = b.currentGameState === "freespin" || b.nextaction === "freespin", c, e, a;
        if (Sys.isDefined(b.wins)) {
            c = b.wins.winType;
            e = f.STANDARD_WIN_TYPES.contains(c);
            a = !Sys.isDefined(c);
            f.storeData("isStandardWin", e);
            f.storeData("isNoWin", a);
            f.storeData("countUpDuration", f.COUNT_UP_DURATIONS[c]);
            f.storeWinSound(c)
        }
        f.storeData("countUpDisplay", g);
        f.storeData("togglePreventedByFreeSpins", d)
    },
    storeWinSound: function (a) {
        this.storeData("winClip", a)
    },
    shouldToggleWins: function () {
        var a = Services.settingsManager.getSetting("autoPlayNrSpins");
        return (!Sys.isDefined(a) || a === 0) && !this.readData("togglePreventedByFreeSpins")
    },
    setupDesktopSpecificData: function () {
        if (Platform.isDesktopDevice) {
            this.storeData("noWinDisplayDuration", this.NO_WIN_DISPLAY_DESKTOP_DURATION)
        }
    }
};
Core.Slots.StandardWinModel = Sys.extend(Core.Model, Core.Slots.StandardWinModel, "Core.Slots.StandardWinModel");
Sys.ns("Core");
Core.AbstractCountUp = {
    constructor: function () {
        Core.AbstractCountUp.superclass.constructor.apply(this, arguments)
    }, getDefaultMVCClasses: function () {
        return {model: Core.CountUpModel, view: Core.AbstractCountUpView, controller: Core.AbstractCountUpController}
    }
};
Core.AbstractCountUp = Sys.extend(Core.CountUp, Core.AbstractCountUp, "Core.AbstractCountUp");
Sys.ns("Core");
Core.AbstractCountUpView = {
    constructor: function () {
        Core.AbstractCountUpView.superclass.constructor.apply(this, arguments)
    }, COUNT_UP_EASING_TYPE: "ease-out", SHOW_TOTAL_DURATION: 1000, countUpCallback: function (a) {
    }, setCountUpCallback: function (a) {
        this.countUpCallback = a
    }, createCountUpItem: function () {
        var a = this;
        return new Animation.CanvasAnimationItem({
            top: 0,
            left: 0,
            width: 0,
            height: 0,
            depth: a.COUNT_UP_DEPTH,
            executeBefore: function () {
                var d = this.value, c, e, b;
                if (a.model.readData("lastValue") !== d) {
                    a.countUpCallback(d);
                    a.model.storeData("lastValue", d);
                    if (Sys.isDefined(this.fireOnValue)) {
                        c = this.fireOnValue.length;
                        for (b = -1; ++b < c;) {
                            e = this.fireOnValue[b];
                            if (!e.fired && d >= e.value) {
                                e.scope.fireEvent(e.event, e.argument);
                                e.fired = true
                            }
                        }
                    }
                }
            },
            operations: {}
        })
    }
};
Core.AbstractCountUpView = Sys.extend(Core.CountUpView, Core.AbstractCountUpView, "Core.AbstractCountUpView");
Sys.ns("Core");
Core.AbstractCountUpController = {
    constructor: function () {
        Core.AbstractCountUpController.superclass.constructor.apply(this, arguments)
    }, setupEvents: function () {
        var a = this, b = {};
        Core.AbstractCountUpController.superclass.setupEvents.apply(a, arguments);
        b["request:" + a.MODULE_NAME + ".setCallback"] = a.view.setCountUpCallback.bind(a.view);
        a.on(b)
    }
};
Core.AbstractCountUpController = Sys.extend(Core.CountUpController, Core.AbstractCountUpController, "Core.AbstractCountUpController");
Sys.ns("Game");
Game.AmbienceManager = {
    constructor: function () {
        Game.AmbienceManager.superclass.constructor.apply(this, arguments)
    }, getDefaultMVCClasses: function () {
        return {model: Game.AmbienceManagerModel, controller: Game.AmbienceManagerController}
    }
};
Game.AmbienceManager = Sys.extend(Core.Module, Game.AmbienceManager, "Game.AmbienceManager");
Sys.ns("Game");
Game.AmbienceManagerModel = {
    constructor: function () {
        Game.AmbienceManagerModel.superclass.constructor.apply(this, arguments)
    }, setupData: function () {
        var a = this;
        a.storeData("activeAmbience", [{name: "ambienceGeneral", id: "ambienceGeneral", loop: true}]);
        Services.storage.storeData("AmbienceManager.playing", false)
    }, getActiveAmbience: function () {
        return this.readData("activeAmbience")
    }, setActiveAmbience: function (a) {
        this.storeData("activeAmbience", a)
    }
};
Game.AmbienceManagerModel = Sys.extend(Core.Model, Game.AmbienceManagerModel, "Game.AmbienceManagerModel");
Sys.ns("Game");
Game.AmbienceManagerController = {
    constructor: function () {
        Game.AmbienceManagerController.superclass.constructor.apply(this, arguments)
    }, setupEvents: function () {
        var a = this;
        a.on({
            "notify:audioPlayer.soundLoaded": a.changeAmbienceEnableState.bind(a, true),
            "request:ambienceManager.ambienceEnableState": a.changeAmbienceEnableState,
            "request:ambienceManager.ambienceChangeActive": a.setActiveAmbience,
            "request:ambienceManager.ambiencePauseSwitch": a.changePauseSwitch,
            "request:ambienceManager.ambienceStopActive": a.stopAmbience,
            "notify:stateHandler.leavingBeforeLoaderCloseState": a.onBeforeLoaderClose
        })
    }, onBeforeLoaderClose: function () {
        if (!this.model.isState("ambienceOn")) {
            this.changeAmbienceEnableState(false)
        }
        this.changePauseSwitch(false)
    }, changeAmbienceEnableState: function (a) {
        var b = this;
        if (a) {
            if (!b.model.isState("ambienceOn")) {
                b.model.setState("ambienceOn");
                b.playActiveAmbience()
            }
        } else {
            b.stopAmbience();
            b.model.setState("ambienceOff")
        }
    }, changePauseSwitch: function (a) {
        var b = this;
        if (a) {
            b.model.storeData("paused", true);
            if (b.model.isState("ambienceOn")) {
                b.stopAmbience()
            }
        } else {
            if (b.model.readData("paused")) {
                b.model.storeData("paused", false);
                if (b.model.isState("ambienceOn")) {
                    b.playActiveAmbience()
                }
            }
        }
    }, playAmbience: function (a) {
        var b = this;
        if (b.model.isState("ambienceOn")) {
            if (!b.model.readData("paused")) {
                Sys.each(a, function (c) {
                    b.dispatchPlaySoundRequest(c)
                })
            }
        } else {
            b.model.setActiveAmbience(a)
        }
    }, playActiveAmbience: function () {
        this.playAmbience(this.model.getActiveAmbience())
    }, stopAmbience: function () {
        var b = this, a = b.model.getActiveAmbience();
        if (b.model.isState("ambienceOn")) {
            Sys.each(a, function (c) {
                b.dispatchStopSoundRequest(c)
            })
        }
    }, setActiveAmbience: function (c) {
        var b = this, a;
        if (!Sys.isArray(c)) {
            a = [{
                name: c.name,
                id: c.id,
                loop: c.loop,
                buffer: c.buffer,
                syncWithId: c.syncWithId,
                fadeIn: c.fadeIn,
                fadeOut: c.fadeOut
            }]
        } else {
            a = c
        }
        b.playAmbience(a);
        b.stopAmbience();
        b.model.setActiveAmbience(a)
    }, dispatchPlaySoundRequest: function (a) {
        if (this.model.isState("ambienceOn")) {
            this.fireEvent("request:audioPlayer.play", a)
        }
    }, dispatchStopSoundRequest: function (a) {
        if (this.model.isState("ambienceOn")) {
            this.fireEvent("request:audioPlayer.stop", a.id)
        }
    }
};
Game.AmbienceManagerController = Sys.extend(Core.Controller, Game.AmbienceManagerController, "Game.AmbienceManagerController");
Sys.ns("Game.Slots");
Game.Slots.BigWin = {
    constructor: function () {
        Game.Slots.BigWin.superclass.constructor.apply(this, arguments)
    }, getStateChanges: function () {
        var a = this.model;
        return {
            bigWin: {
                state: {
                    name: "BigWin", execute: function (b) {
                    }, waitEvents: {"notify:bigWin.presentationFinished": false}
                }
            }, stopped: {
                queue: [function (b) {
                    if (a.isState("animationRequested")) {
                        b.stateHandler.pushState(b.states.bigWin)
                    }
                }]
            }
        }
    }, getMixinDependencies: function () {
        return ["serverResponse", "animation", "userInput", "waitSequence", "trigger"]
    }, getDefaultMVCClasses: function () {
        return {model: Game.Slots.BigWinModel, controller: Game.Slots.BigWinController, view: Game.Slots.BigWinView}
    }
};
Game.Slots.BigWin = Sys.extend(Core.Module, Game.Slots.BigWin, "Game.Slots.BigWin");
Sys.ns("Game.Slots");
Game.Slots.BigWinController = {
    constructor: function () {
        Game.Slots.BigWinController.superclass.constructor.apply(this, arguments)
    }, setupEvents: function () {
        var a = this;
        a.on({
            "view:startCountUp": a.onConutUpStart,
            "view:showTotalInCountUp": a.onShowTotalRequest,
            "view:hideCountUp": a.fireEvent.bind(a, "request:bigWinCountUp.stop"),
            "view:showWinText": a.showWinText,
            "view:playAudio": a.fireEvent.bind(a, "request:audioPlayer.play"),
            "view:stopAudio": a.fireEvent.bind(a, "request:audioPlayer.stop"),
            "notify:stateHandler.enteringBigWinState": a.show,
            "notify:bigWinCountUp.countUpComplete": a.finish,
            "notify:bigWinCountUp.hidden": a.close,
            "notify:stateHandler.leavingBigWinState": a.toggleWins,
            "notify:winSituationsDisplay.showingAllWins": a.waitForWinSituationsDisplay,
            "notify:spinButton.clicked": a.handleUserInput,
            "notify:spinButton.clickedWhileHidden": a.handleUserInput,
            "notify:scaling.gameSizeChanged": a.onGameSizeChanged,
            "request:abortPresentation": a.handleUserInput
        })
    }, registerTriggers: function () {
        Services.trigger.registerTrigger("notify:bigWin.showTotalInCountUp", this, "Show total count up")
    }, onUserInputStart: function (a) {
        if (Sys.UserInputUtils.isCoordinateTarget(Game.stage.getGameContainer(), a)) {
            this.handleUserInput()
        }
    }, handleUserInput: function () {
        var a = this;
        if (a.model.isState("showing")) {
            a.finish()
        } else {
            if (a.model.isState("finished")) {
                a.close()
            } else {
                if (a.model.isState("showingAllWins")) {
                    a.fireEvent("request:winSituationsDisplay.abort")
                }
            }
        }
    }, show: function () {
        var a = this;
        a.fireEvent("request:settingsWindow.close");
        a.startListeningToUserInput();
        a.model.setState("showing");
        a.view.show()
    }, onConutUpStart: function (a) {
        this.fireEvent("request:bigWinCountUp.start", a)
    }, onShowTotalRequest: function () {
        var a = this;
        a.fireEvent("notify:bigWin.showTotalInCountUp");
        a.fireEvent("request:bigWinCountUp.showTotal", {showDuration: a.model.readData("showTotalDuration")});
        a.fireEvent("request:coinsField.showWin");
        a.fireEvent("request:cashField.showWin")
    }, showWinText: function (a) {
        this.view.showWinText(a);
        this.fireEvent("notify:bigWin.showingWinType", a)
    }, finish: function () {
        var a = this;
        a.model.setState("finished");
        a.view.finish()
    }, close: function () {
        var a = this;
        a.model.setState("closed");
        a.view.close();
        if (a.model.readData("showAllWins")) {
            a.model.setState("showingAllWins");
            a.initializeWaitSequence("request:winSituationsDisplay.showAllWins", {showDuration: a.model.readData("showAllWinsDuration")})
        } else {
            a.onWaitIsComplete()
        }
    }, onGameSizeChanged: function () {
        if (Sys.isFunc(this.view.refresh)) {
            this.view.refresh()
        }
    }, waitForWinSituationsDisplay: function () {
        this.onWaitRequested("notify:winSituationsDisplay.finishedShowingAllWins")
    }, onWaitIsComplete: function () {
        var a = this;
        a.stopListeningToUserInput();
        a.model.storeData("showAllWins", false);
        a.fireEvent("notify:bigWin.presentationFinished")
    }, toggleWins: function () {
        if (this.model.shouldToggleWins()) {
            this.fireEvent("request:dimmedSymbols.dimNoWinSymbols");
            this.fireEvent("request:noWinSymbols.animate");
            this.fireEvent("request:winSituationsDisplay.toggleWins")
        }
    }
};
Game.Slots.BigWinController = Sys.extend(Core.Controller, Game.Slots.BigWinController, "Game.Slots.BigWinController");
Sys.ns("Game.Slots");
Game.Slots.BigWinView = {
    TEXT_OPERATIONS: [{fillStyle: "#FFFFFF"}, {
        lineWidth: 5,
        strokeStyle: "#00000",
        drawType: "stroke"
    }],
    FONT: "bold 80px Verdana",
    TEXT_OFFSET: 0,
    TEXT_TOP: 100,
    TEXT_LEFT: undefined,
    WIN_TEXTS: {bigWin: Language.Keys.bigWin, megaWin: Language.Keys.megaWin, superMegaWin: Language.Keys.superMegaWin},
    constructor: function () {
        var a = {TEXT_OFFSET: this.TEXT_OFFSET, TEXT_TOP: this.TEXT_TOP, TEXT_LEFT: this.TEXT_LEFT};
        Game.Slots.BigWinView.superclass.constructor.apply(this, arguments);
        this.CONFIG = this.CONFIG || {};
        this.CONFIG.DEFAULT = this.CONFIG.DEFAULT || {};
        Sys.applyProperties(this.CONFIG.DEFAULT, a)
    },
    configureTextAnimation: function (a) {
        a.prop.operations.fade = [{time: 0, value: 0}, {time: 300, value: 1}, {time: 1300, value: 0.5, goTo: 1}]
    },
    configureSwitchAnimation: function (a) {
        a.prop.operations.scale = [{time: 0, value: {scaleX: 1, scaleY: 1}}, {
            time: 200,
            value: {scaleX: 1.5, scaleY: 1.5}
        }];
        a.prop.operations.fade = [{time: 0, value: 1}, {time: 200, value: 0}]
    },
    configureTextEndingAnimation: function (a) {
        a.prop.operations.fade = [{time: 0, value: 1}, {time: this.model.readData("showTotalDuration"), value: 0}]
    },
    initAnimations: function () {
        var a = this, c = new Animation.CanvasAnimationList({}), e = {}, b, d;
        a.scaleFactor = a.getScaleFactor();
        Sys.each(a.model.getSupportedSubTypes(), function (f) {
            d = Services.languageManager.getText(a.WIN_TEXTS[f]);
            b = a.createWinAnimation(d);
            e[f] = b;
            c.add(b);
            b = a.createSwitchAnimation(d);
            e[f + "Switch"] = b;
            c.add(b);
            b = a.createEndAnimation(d);
            e[f + "End"] = b;
            c.add(b)
        });
        Game.stage.view.addToRenderLoop(c);
        c.stop();
        a.animations = e;
        a.list = c
    },
    getScaleFactor: function () {
        return Resources.readData("config").mobileResourceToVirtualScale || 1
    },
    show: function () {
        var a = this, b = a.model.readData("coinWin"), c = a.model.getWinCountUpDuration();
        a.doAnimation(0, b, c);
        a.playAudio("bigWinStart");
        a.fireEvent("view:playAudio", {name: "bigWinLoop", id: "bigWinLoop", loop: true})
    },
    finish: function () {
        var b = this, a = b.animations[b.model.readData("winType") + "End"], c = b.remainingWinTypes.length - 1;
        b.list.stop();
        b.fireEvent("view:stopAudio", "bigWinLoop");
        b.list.play(a);
        if (c >= 0) {
            b.fireEvent("view:stopAudio", "bigWin");
            b.playAudio(b.remainingWinTypes[c])
        }
        b.playAudio("bigWinEnd");
        b.playAudio("bigWinLoopEnd");
        b.fireEvent("view:showTotalInCountUp")
    },
    close: function () {
        this.list.stop();
        this.fireEvent("view:stopAudio", "bigWin");
        this.fireEvent("view:hideCountUp")
    },
    refresh: function () {
        var b = this, a;
        Sys.iterate(this.animations, function (c, d) {
            if (Animation.utils.isAnimationItem(d)) {
                a = b.getRenderingAttributes(d.prop);
                d.setTop(a.top);
                d.setLeft(a.left)
            }
        })
    },
    doAnimation: function (e, d, c) {
        var b = this, a = {from: e, to: d, duration: c, fireEventsOnValue: []};
        b.remainingWinTypes = [];
        Sys.iterate(b.model.readData("winTypeCoinLimits"), function (f, g) {
            a.fireEventsOnValue.push({value: g, event: "view:showWinText", argument: f, scope: b});
            if (g <= d) {
                b.remainingWinTypes.push(f)
            }
        });
        b.currentlyShowingWin = undefined;
        b.fireEvent("view:startCountUp", a)
    },
    showWinText: function (c) {
        var e = this, d = e.currentlyShowingWin, a = e.animations[d + "Switch"],
            b = Sys.isArray(e.animations[c]) ? e.animations[c] : [e.animations[c]];
        e.list.stop();
        if (Sys.isDefined(d) && Sys.isDefined(a)) {
            a = Sys.isArray(a) ? a : [a];
            b = b.concat(a)
        }
        e.currentlyShowingWin = c;
        e.list.play(b);
        e.playAudio(c);
        e.remainingWinTypes.splice(e.remainingWinTypes.indexOf(c), 1)
    },
    createText: (function () {
        var a = {};
        return function (c) {
            var b = this;
            return a[c] || (a[c] = Animation.utils.text.createText(c, b.FONT, b.TEXT_OFFSET, b.TEXT_OPERATIONS))
        }
    }()),
    createSwitchAnimation: function (c) {
        var b = this, a = b.createTextAnimation(c);
        b.configureSwitchAnimation(a);
        return a
    },
    createEndAnimation: function (c) {
        var b = this, a = b.createTextAnimation(c);
        b.configureTextEndingAnimation(a);
        return a
    },
    createWinAnimation: function (c) {
        var b = this, a = b.createTextAnimation(c);
        b.configureTextAnimation(a);
        return a
    },
    createTextAnimation: function (f) {
        var d = this, e = d.createText(f), c = e.width, a = e.height, b = d.getRenderingAttributes({width: c});
        return new Animation.CanvasAnimationItem({
            width: c,
            height: a,
            top: b.top,
            left: b.left,
            opacity: 1,
            depth: Layering.Game.Slots.BigWin.text,
            image: e,
            operations: {},
            text: f
        })
    },
    playAudio: function (b, a) {
        this.fireEvent("view:playAudio", {name: b, id: "bigWin", loop: a})
    },
    getRenderingAttributes: function (b) {
        var d = this.getScaleFactor(), c = Environment.getStageResolution(),
            a = Environment.getOrientationSpecificConfig(this.CONFIG, true);
        return {left: Sys.isDefined(a.TEXT_LEFT) ? a.TEXT_LEFT * d : (c.width - b.width) / 2, top: a.TEXT_TOP * d}
    }
};
Game.Slots.BigWinView = Sys.extend(Core.View, Game.Slots.BigWinView, "Game.Slots.BigWinView");
Sys.ns("Game.Slots");
Game.Slots.BigWinModel = {
    SUPPORTED_SUB_TYPES: ["bigWin"],
    SUB_TYPE_LIMITS: {bigWin: {from: 0}},
    COUNT_UP_DURATIONS: {bigWin: 9000},
    SHOW_TOTAL_DURATION: 3000,
    SHOW_ALL_WINS_DURATION: 1000,
    constructor: function () {
        Game.Slots.BigWinModel.superclass.constructor.apply(this, arguments)
    },
    setupData: function () {
        var a = this;
        a.storeData("autoplayActive", false);
        a.storeData("showTotalDuration", a.SHOW_TOTAL_DURATION);
        a.storeData("showAllWinsDuration", a.SHOW_ALL_WINS_DURATION);
        a.storeData("latestWinnings", {previousWinnings: 0, currentWinnings: 0})
    },
    processServerResponse: function (d) {
        var c = this, a, b = d.currentGameState === "freespin" || d.nextaction === "freespin";
        c.storeData("serverResponse", d);
        if (Sys.isDefined(d.wins) && d.wins.winType === "bigWin") {
            a = d.wins.coins;
            c.storeData("coinWin", a);
            c.determineWinType(a);
            c.setState("animationRequested");
            c.storeData("togglePreventedByFreeSpins", b);
            c.storeData("showAllWins", c.shouldShowAllWins(d))
        } else {
            c.storeData("coinWin", 0);
            c.storeData("winType", undefined);
            c.setState("idle")
        }
    },
    determineWinType: function (d) {
        var c = this, f = Services.moneyManager.getBetCoins(), b, e, a, g = {};
        Sys.iterate(c.SUB_TYPE_LIMITS, function (i, h) {
            e = f * h.from;
            a = f * h.to;
            g[i] = e;
            if (d >= e && (isNaN(a) || d < f * a)) {
                b = i
            }
        });
        this.storeData("winType", b);
        this.storeData("winTypeCoinLimits", g)
    },
    shouldShowAllWins: function (a) {
        return true
    },
    getWinCountUpDuration: function () {
        var b = this, a = b.readData("winType");
        return b.COUNT_UP_DURATIONS[a]
    },
    getSupportedSubTypes: function () {
        return this.SUPPORTED_SUB_TYPES
    },
    shouldToggleWins: function () {
        var a = Services.settingsManager.getSetting("autoPlayNrSpins"), b = Sys.isDefined(a) && a > 0;
        return !b && !this.readData("togglePreventedByFreeSpins")
    }
};
Game.Slots.BigWinModel = Sys.extend(Core.Model, Game.Slots.BigWinModel, "Game.Slots.BigWinModel");
Sys.ns("Game.Slots");
Game.Slots.WinSituationsDisplay = {
    constructor: function () {
        Game.Slots.WinSituationsDisplay.superclass.constructor.apply(this, arguments)
    }, getMixinDependencies: function () {
        return ["waitSequence", "serverResponse"]
    }, getDefaultMVCClasses: function () {
        return {model: Game.Slots.WinSituationsDisplayModel, controller: Game.Slots.WinSituationsDisplayController}
    }
};
Game.Slots.WinSituationsDisplay = Sys.extend(Core.Module, Game.Slots.WinSituationsDisplay, "Game.Slots.WinSituationsDisplay");
Sys.ns("Game.Slots");
Game.Slots.WinSituationsDisplayModel = {
    constructor: function () {
        Game.Slots.WinSituationsDisplayModel.superclass.constructor.apply(this, arguments)
    }, setupData: function () {
        var a = Resources.readData("config");
        this.storeData("winSituationMinimumDisplayTime", a.winSituationsDisplay.winSituationMinimumDisplayTime)
    }, processServerResponse: function (c) {
        var b = this, a = [];
        if (c.wins && Sys.isArray(c.wins.winSituations)) {
            Sys.each(c.wins.winSituations, function (e, d) {
                if (b.shouldToggleWinSituation(e)) {
                    a.push(d)
                }
            })
        }
        b.storeData("winSituationsToToggle", a)
    }, shouldToggleWinSituation: function (a) {
        return a.wins.type === "coins"
    }
};
Game.Slots.WinSituationsDisplayModel = Sys.extend(Core.Model, Game.Slots.WinSituationsDisplayModel, "Game.Slots.WinSituationsDisplayModel");
Sys.ns("Game.Slots");
Game.Slots.WinSituationsDisplayController = {
    constructor: function () {
        Game.Slots.WinSituationsDisplayController.superclass.constructor.apply(this, arguments)
    }, setupEvents: function () {
        var a = this;
        a.on({
            "notify:stateHandler.enteringSpinningState": a.abort,
            "request:winSituationsDisplay.abort": a.abort,
            "request:winSituationsDisplay.showAllWins": a.showAllWins,
            "request:winSituationsDisplay.toggleWins": a.startToggling,
            "notify:settingsManager.settingChanged": a.processSettingsChanges,
            "request:winSituationsDisplay.waitFor": a.handleWaitRequest
        })
    }, showAllWins: function (b) {
        var a = this;
        a.model.setState("showingAllWins");
        a.initializeWaitSequence("notify:winSituationsDisplay.showingAllWins", b)
    }, startToggling: function (b) {
        var a = this;
        a.winSituationCounter = -1;
        a.pulseDurationPassed = true;
        a.clearWaitSequence();
        a.model.storeData("extraTogglingParameters", b);
        a.showNextBetline()
    }, showNextBetline: function () {
        var b = this, a = b.model.readData("winSituationsToToggle");
        if (b.eventsToWaitFor.length === 0 && a.length > 0 && b.pulseDurationPassed) {
            b.abort();
            b.model.setState("toggling");
            ++b.winSituationCounter;
            b.initializeWaitSequence("notify:winSituationsDisplay.togglingWinSituation", a[b.winSituationCounter % a.length], b.model.readData("extraTogglingParameters"));
            b.pulseDurationPassed = false;
            b.toggleTimeout = setTimeout(function () {
                b.pulseDurationPassed = true;
                b.showNextBetline()
            }, b.model.readData("winSituationMinimumDisplayTime"))
        }
    }, handleWaitRequest: function (a) {
        this.onWaitRequested(a)
    }, onWaitIsComplete: function () {
        var b = this, a = b.model.isState("toggling");
        if (a) {
            b.showNextBetline()
        } else {
            b.abort()
        }
    }, processSettingsChanges: function (a) {
        if (this.model.isState("toggling") && (a === "betLevel" || a === "denomination")) {
            this.abort()
        }
    }, abort: function () {
        var b = this, a = b.model.isState("showingAllWins");
        clearTimeout(b.toggleTimeout);
        if (!b.model.isState("abort")) {
            b.model.setState("abort");
            b.fireEvent("notify:winSituationsDisplay.abort");
            if (a) {
                b.fireEvent("notify:winSituationsDisplay.finishedShowingAllWins")
            }
        }
    }
};
Game.Slots.WinSituationsDisplayController = Sys.extend(Core.Controller, Game.Slots.WinSituationsDisplayController, "Game.Slots.WinSituationsDisplayController");
Sys.ns("Game.Slots");
Game.Slots.WinSituations = {
    constructor: function () {
        Game.Slots.WinSituations.superclass.constructor.apply(this, arguments)
    }, getMixinDependencies: function () {
        return ["animation", "serverResponse"]
    }, getDefaultMVCClasses: function () {
        return {
            model: Game.Slots.WinSituationsModel,
            view: Game.Slots.WinSituationsView,
            controller: Game.Slots.WinSituationsController
        }
    }
};
Game.Slots.WinSituations = Sys.extend(Core.Module, Game.Slots.WinSituations, "Game.Slots.WinSituations");
Sys.ns("Game.Slots");
Game.Slots.WinSituationsController = {
    constructor: function () {
        Game.Slots.WinSituationsController.superclass.constructor.apply(this, arguments)
    }, setupEvents: function () {
        var a = this;
        a.on({
            "notify:winSituationsDisplay.showingAllWins": a.animateAllWinningBetlines,
            "notify:winSituationsDisplay.togglingWinSituation": a.animateWinSituation,
            "notify:winSituationsDisplay.abort": a.abort,
            "request:winSituations.showDisplayBetline": a.showDisplayBetline,
            "request:winSituations.hideDisplayBetline": a.hideDisplayBetline,
            "view:animationComplete": a.fireEvent.bind(a, "notify:winSituations.animationComplete"),
            "notify:scaling.gameSizeChanged": a.onGameSizeChanged
        })
    }, onGameSizeChanged: function () {
        if (Sys.isFunc(this.view.refresh)) {
            this.view.refresh()
        }
    }, animateAllWinningBetlines: function (a) {
        this.fireEvent("request:winSituationsDisplay.waitFor", "notify:winSituations.animationComplete");
        this.view.showAllWinningBetlines(a)
    }, animateWinSituation: function (a, b) {
        this.fireEvent("request:winSituationsDisplay.waitFor", "notify:winSituations.animationComplete");
        this.model.storeData("currentWinSituationIndex", a);
        this.view.showSingleWinSituation(a, b)
    }, abort: function () {
        this.view.stop();
        this.model.removeData("currentWinSituationIndex")
    }, showDisplayBetline: function (b, a) {
        this.view.showDisplayBetline(b, a)
    }, hideDisplayBetline: function (a) {
        this.view.hideDisplayBetline(a)
    }
};
Game.Slots.WinSituationsController = Sys.extend(Core.Controller, Game.Slots.WinSituationsController, "Game.Slots.WinSituationsController");
Sys.ns("Game.Slots");
Game.Slots.WinSituationsModel = {
    constructor: function () {
        Game.Slots.WinSituationsModel.superclass.constructor.apply(this, arguments)
    }, setupData: function () {
        var a = Resources.readData("config").winSituationsDisplay || {}, b = a.betlines || {};
        this.storeData("lineConfig", b.lines);
        this.storeData("frameConfig", b.frames)
    }, processServerResponse: function (b) {
        var a = this;
        if (b.wins && Sys.isArray(b.wins.winSituations)) {
            a.storeData("winSituations", b.wins.winSituations.slice(0))
        }
    }, shouldFrameWinningSymbols: function () {
        return Sys.isDefined(this.readData("frameConfig"))
    }
};
Game.Slots.WinSituationsModel = Sys.extend(Core.Model, Game.Slots.WinSituationsModel, "Game.Slots.WinSituationsModel");
Sys.ns("Game.Slots");
Game.Slots.WinSituationsView = {
    constructor: function () {
        Game.Slots.WinSituationsView.superclass.constructor.apply(this, arguments)
    }, setAllBetlinesDisplayItemProps: function (a) {
    }, setSingleWinSituationDisplayItemProps: function (a) {
    }, initAnimations: function () {
        var a = this, b = Environment.getStageResolution();
        a.origin = {x: Environment.scaleX(0), y: Environment.scaleY(0)};
        a.offlineCanvas = document.createElement("canvas");
        a.offlineCanvas.width = b.width;
        a.offlineCanvas.height = b.height;
        a.offlineContext = a.offlineCanvas.getContext("2d");
        a.animationList = new Animation.CanvasAnimationList();
        a.hoverBetlineCanvas = document.createElement("canvas");
        a.hoverBetlineCanvas.width = b.width;
        a.hoverBetlineCanvas.height = b.height;
        a.hoverBetlineContext = a.hoverBetlineCanvas.getContext("2d");
        a.hoverBetlineAnimationList = new Animation.CanvasAnimationList();
        a.createAnimationItems();
        a.createHoverBetlineAnimationItems();
        Game.stage.view.addToRenderLoop(a.animationList);
        Game.stage.view.addToRenderLoop(a.hoverBetlineAnimationList);
        a.hoverBetlineAnimationList.stop();
        a.animationList.stop()
    }, createAnimationItems: function () {
        var a = this;
        a.item = new Animation.CanvasAnimationItem({
            top: 0,
            left: 0,
            width: a.offlineCanvas.width,
            height: a.offlineCanvas.height,
            depth: Layering.Game.Slots.WinSituationsDisplay.betlines,
            image: a.offlineCanvas,
            operations: {
                fade: [{time: 0, value: 1, fireEvent: {event: "view:animationComplete", scope: a}}, {
                    time: 1,
                    value: 1,
                    goTo: 0
                }]
            }
        });
        a.animationList.add(a.item)
    }, createHoverBetlineAnimationItems: function () {
        var a = this,
            b = Layering.Game.Slots.WinSituationsDisplay.hoverBetlines || Layering.Game.Slots.WinSituationsDisplay.betlines;
        a.hoverItem = new Animation.CanvasAnimationItem({
            top: 0,
            left: 0,
            width: a.hoverBetlineCanvas.width,
            height: a.hoverBetlineCanvas.height,
            depth: b,
            image: a.hoverBetlineCanvas
        });
        a.hoverBetlineAnimationList.add(a.hoverItem)
    }, showAllWinningBetlines: function (c) {
        var b = this, a = b.model.readData("winSituations");
        Sys.each(a, function (d) {
            if (Sys.isDefined(d.betline)) {
                b.drawBetline(d.betline)
            }
        });
        b.setAllBetlinesDisplayItemProps(c);
        b.animationList.restore();
        b.animationList.play()
    }, drawBetline: function (e, b) {
        var d = this, g = d.model.readData("lineConfig"), c = g[e].lineCoordinates, f = g[e].color || g.defaultColor, a,
            h;
        b = b ? b : d.offlineContext;
        if (!Array.isArray(c)) {
            h = Environment.getConfigForCurrentDeviceState(c)
        } else {
            h = c
        }
        b.beginPath();
        b.moveTo(h[0], h[1]);
        if (g.lineType === "curve") {
            for (a = 2; a < h.length; a += 6) {
                b.bezierCurveTo(h[a], h[a + 1], h[a + 2], h[a + 3], h[a + 4], h[a + 5])
            }
        } else {
            for (a = 2; a < h.length; a += 2) {
                b.lineTo(h[a], h[a + 1])
            }
        }
        for (a = 0; a < g.drawingOperations.length; a++) {
            b.strokeStyle = f;
            b = Sys.applyProperties(b, g.drawingOperations[a]);
            b.stroke()
        }
    }, showSingleWinSituation: function (c, d) {
        var b = this, a = b.model.readData("winSituations")[c];
        if (Sys.isDefined(a.betline)) {
            b.drawBetline(a.betline)
        }
        if (b.model.shouldFrameWinningSymbols()) {
            b.frameWinningSymbols(a)
        }
        b.setSingleWinSituationDisplayItemProps(d);
        b.animationList.restore();
        b.animationList.play()
    }, frameWinningSymbols: function (k) {
        var h = this, b = h.model.readData("lineConfig"), g = h.model.readData("frameConfig"),
            e = (k.betline && b[k.betline].color) || b.defaultColor, c = h.offlineContext, j, l, i, a, m, f = g.image,
            d;
        if (f) {
            f = Resources.readData("animationImages")[f]
        }
        Sys.each(k.positions, function (n) {
            j = Game.stage.model.getSymbolConfiguration(n.reelIndex, n.symbolIndex);
            l = j.left + g.xOffset;
            i = j.top + g.yOffset;
            a = j.width - g.xOffset * 2;
            m = j.height - g.yOffset * 2;
            c.clearRect(l, i, a, m);
            if (f) {
                c.drawImage(f, l, i)
            } else {
                for (d = 0; d < b.drawingOperations.length; d++) {
                    c.strokeStyle = e;
                    c = Sys.applyProperties(c, b.drawingOperations[d]);
                    c.strokeRect(l, i, a, m)
                }
            }
        })
    }, stop: function () {
        var a = this;
        a.animationList.stop();
        a.offlineContext.clearRect(0, 0, a.offlineCanvas.width, a.offlineCanvas.height)
    }, showDisplayBetline: function (a, b) {
        var d = this, c = d.model.readData("displayBetlineWho");
        if (!Sys.isArray(a)) {
            a = [a]
        }
        if (!Sys.isDefined(b)) {
            b = "hover"
        }
        if (b !== c) {
            d.hideDisplayBetline(c)
        }
        d.model.storeData("displayBetlineWho", b);
        a.forEach(function (e) {
            d.drawBetline(e, d.hoverBetlineContext)
        });
        d.hoverBetlineAnimationList.play()
    }, hideDisplayBetline: function (a) {
        var b = this;
        if (!Sys.isDefined(a)) {
            a = "hover"
        }
        if (a === b.model.readData("displayBetlineWho")) {
            b.hoverBetlineAnimationList.stop();
            b.hoverBetlineContext.clearRect(0, 0, b.hoverBetlineCanvas.width, b.hoverBetlineCanvas.height)
        }
    }, refresh: function () {
        var b = this.model.readData("currentWinSituationIndex"), a = this.item, c;
        this.animationList.stop();
        c = Environment.getStageResolution();
        this.offlineCanvas.width = c.width;
        this.offlineCanvas.height = c.height;
        if (Animation.utils.isAnimationItem(a)) {
            a.setWidth(c.width);
            a.setHeight(c.height);
            a.updatePivot()
        }
        if (Sys.isNumber(b)) {
            this.showSingleWinSituation(b, {})
        }
    }
};
Game.Slots.WinSituationsView = Sys.extend(Core.View, Game.Slots.WinSituationsView, "Game.Slots.WinSituationsView");
Sys.ns("Game.Slots");
Game.Slots.WinBanner = {
    constructor: function () {
        Game.Slots.WinBanner.superclass.constructor.apply(this, arguments)
    }, getMixinDependencies: function () {
        return ["animation"]
    }, getDefaultMVCClasses: function () {
        return {
            model: Game.Slots.WinBannerModel,
            view: Game.Slots.WinBannerView,
            controller: Game.Slots.WinBannerController
        }
    }
};
Game.Slots.WinBanner = Sys.extend(Core.CountUp, Game.Slots.WinBanner, "Game.Slots.WinBanner");
Sys.ns("Game.Slots");
Game.Slots.WinBannerModel = {
    constructor: function () {
        Game.Slots.WinBannerModel.superclass.constructor.apply(this, arguments)
    }, setupData: function () {
        Game.Slots.WinBannerModel.superclass.setupData.apply(this, arguments);
        this.storeData("coinWin", 0);
        this.storeData("countUpDuration", 0)
    }, processServerResponse: function (d) {
        var b = this, a = 0, c = 0;
        if (Sys.isDefined(d.wins) && Sys.isDefined(d.wins.coins)) {
            a = d.wins.coins
        }
        if (Sys.isDefined(d.wins) && Sys.isDefined(d.wins.coinsTotal)) {
            c = d.wins.coinsTotal
        }
        b.storeData("coinWin", a);
        b.storeData("totalCoinWin", c)
    }
};
Game.Slots.WinBannerModel = Sys.extend(Core.CountUpModel, Game.Slots.WinBannerModel, "Game.Slots.WinBannerModel");
Sys.ns("Game.Slots");
Game.Slots.WinBannerView = {
    BACKGROUND_LEFT: 0,
    BACKGROUND_TOP: 460,
    BACKGROUND_DEPTH: 101,
    BACKGROUND_IMAGE: undefined,
    BACKGROUND_IMAGE_WIDTH: 0,
    BACKGROUND_IMAGE_HEIGHT: 0,
    SHOW_TOTAL_DURATION: 500,
    NUMBER_IMAGE: undefined,
    NUMBER_WIDTH: 80,
    NUMBER_HEIGHT: 100,
    NUMBER_FONT: "bold 100px Verdana",
    NUMBER_OFFSET: 0,
    NUMBER_TEXT_OPERATIONS: [{fillStyle: "#FFFFFF"}, {lineWidth: 5, strokeStyle: "#00000", drawType: "stroke"}],
    COUNT_UP_LEFT: undefined,
    COUNT_UP_DEPTH: 100,
    COUNT_UP_TOP: 475,
    COUNT_UP_EASING_TYPE: "ease-out",
    constructor: function () {
        var a = {
            BACKGROUND_LEFT: this.BACKGROUND_LEFT,
            BACKGROUND_TOP: this.BACKGROUND_TOP,
            COUNT_UP_LEFT: this.COUNT_UP_LEFT,
            COUNT_UP_TOP: this.COUNT_UP_TOP
        };
        Game.Slots.WinBannerView.superclass.constructor.apply(this, arguments);
        this.CONFIG = this.CONFIG || {};
        this.CONFIG.DEFAULT = this.CONFIG.DEFAULT || {};
        Sys.applyProperties(this.CONFIG.DEFAULT, a)
    },
    configureStartAnimation: function (a) {
    },
    configureEndAnimation: function () {
    },
    createBackgroundItem: function () {
        var c = this, b = this.scaleFactor, a = this.getPositionForBackgroundItem();
        return new Animation.CanvasAnimationItem({
            left: a.left,
            top: a.top,
            width: Math.round(c.BACKGROUND_IMAGE_WIDTH * b),
            height: Math.round(c.BACKGROUND_IMAGE_HEIGHT * b),
            image: c.BACKGROUND_IMAGE,
            opacity: 1,
            delay: 0,
            depth: c.BACKGROUND_DEPTH,
            operations: {}
        })
    },
    getPositionForBackgroundItem: function () {
        var a = Environment.getOrientationSpecificConfig(this.CONFIG, true), c = Environment.getStageResolution(),
            b = this.scaleFactor;
        return {
            left: Sys.isDefined(a.BACKGROUND_LEFT) ? Math.round(a.BACKGROUND_LEFT * b) : c.width / 2 - Math.round(this.BACKGROUND_IMAGE_WIDTH * b) / 2,
            top: Math.round(a.BACKGROUND_TOP * b)
        }
    },
    createItems: function () {
        var a = this;
        Game.Slots.WinBannerView.superclass.createItems.apply(this, arguments);
        a.backgroundItem = a.createBackgroundItem();
        a.list.add(a.backgroundItem)
    },
    start: function (c) {
        var b = this, a = b.model.readData("coinWin"), d = b.model.readData("totalCoinWin");
        Game.Slots.WinBannerView.superclass.start.call(b, {
            from: d - a,
            to: d,
            duration: c,
            fireEventsOnValue: [{value: 0, event: "view:playSound", scope: b}, {
                value: d,
                event: "view:stopSound",
                scope: b
            }]
        })
    },
    stop: function () {
        this.fireEvent("view:stopSound");
        Game.Slots.WinBannerView.superclass.stop.apply(this, arguments)
    },
    pause: function () {
        this.fireEvent("view:stopSound");
        this.fireEvent("view:stopSound");
        Game.Slots.WinBannerView.superclass.pause.apply(this, arguments)
    },
    resume: function () {
        if (this.model.isState("countingUp")) {
            this.fireEvent("view:playSound")
        }
        Game.Slots.WinBannerView.superclass.resume.apply(this, arguments)
    },
    refresh: function () {
        var a = this.getPositionForBackgroundItem(), b = this.backgroundItem;
        if (Animation.utils.isAnimationItem(b)) {
            b.setLeft(a.left);
            b.setTop(a.top)
        }
        Game.Slots.WinBannerView.superclass.refresh.apply(this)
    },
    showTotal: function () {
        this.fireEvent("view:stopSound");
        Game.Slots.WinBannerView.superclass.showTotal.apply(this, arguments)
    }
};
Game.Slots.WinBannerView = Sys.extend(Core.CountUpView, Game.Slots.WinBannerView, "Game.Slots.WinBannerView");
Sys.ns("Game.Slots");
Game.Slots.CoinWin = {
    constructor: function () {
        Game.Slots.CoinWin.superclass.constructor.apply(this, arguments)
    }, getMixinDependencies: function () {
        return ["animation"]
    }, getDefaultMVCClasses: function () {
        return {model: Game.Slots.CoinWinModel, view: Game.Slots.CoinWinView, controller: Game.Slots.CoinWinController}
    }
};
Game.Slots.CoinWin = Sys.extend(Core.Module, Game.Slots.CoinWin, "Game.Slots.CoinWin");
Sys.ns("Game.Slots");
Game.Slots.CoinWinModel = {
    SYMBOL_ORDER_FREFERENCE: [2, 1, 3, 0, 4], constructor: function () {
        Game.Slots.CoinWinModel.superclass.constructor.apply(this, arguments)
    }, processServerResponse: function (c) {
        var b = this, a = [];
        if (c.wins && Sys.isArray(c.wins.winSituations)) {
            Sys.each(c.wins.winSituations, function (d) {
                a.push(b.parseWinSituation(d))
            })
        }
        b.storeData("winSituations", a)
    }, parseWinSituation: function (e) {
        var d, a = [], c, f, b;
        if (e.wins.type === "coins") {
            d = e.positions;
            for (b = 0; b < d.length; b++) {
                a.push(d[b].reelIndex)
            }
            for (b = 0; b < this.SYMBOL_ORDER_FREFERENCE.length; b++) {
                f = this.SYMBOL_ORDER_FREFERENCE[b];
                c = a.indexOf(f);
                if (c >= 0) {
                    return {x: f, y: d[c].symbolIndex, coins: e.wins.coins}
                }
            }
        }
        return undefined
    }
};
Game.Slots.CoinWinModel = Sys.extend(Core.Model, Game.Slots.CoinWinModel, "Game.Slots.CoinWinModel");
Sys.ns("Game.Slots");
Game.Slots.CoinWinView = {
    NUMBER_IMAGE: undefined,
    NUMBER_WIDTH: 100,
    NUMBER_HEIGHT: 100,
    NUMBER_FONT: "bold 100px Verdana",
    NUMBER_OFFSET: 0,
    NUMBER_TEXT_OPERATIONS: [{fillStyle: "#fff"}, {lineWidth: 5, strokeStyle: "#000", drawType: "stroke"}],
    BACKGROUND_IMAGE: undefined,
    BACKGROUND_DRAWING_FUNCTION: function (a) {
        a.fillStyle = "#ff00e0";
        a.fillRect(this.pivot.x, this.pivot.y, this.width, this.height)
    },
    BACKGROUND_WIDTH: undefined,
    BACKGROUND_HEIGHT: undefined,
    constructor: function () {
        var b = this, a = {
            NUMBER_IMAGE: b.NUMBER_IMAGE,
            NUMBER_WIDTH: b.NUMBER_WIDTH,
            NUMBER_HEIGHT: b.NUMBER_HEIGHT,
            NUMBER_FONT: b.NUMBER_FONT,
            NUMBER_OFFSET: b.NUMBER_OFFSET,
            NUMBER_TEXT_OPERATIONS: b.NUMBER_TEXT_OPERATIONS,
            BACKGROUND_IMAGE: b.BACKGROUND_IMAGE,
            BACKGROUND_DRAWING_FUNCTION: b.BACKGROUND_DRAWING_FUNCTION,
            BACKGROUND_WIDTH: b.BACKGROUND_WIDTH,
            BACKGROUND_HEIGHT: b.BACKGROUND_HEIGHT
        };
        Game.Slots.CoinWinView.superclass.constructor.apply(b, arguments);
        b.CONFIG = b.CONFIG || {};
        b.CONFIG.DEFAULT = b.CONFIG.DEFAULT || {};
        Sys.applyProperties(b.CONFIG.DEFAULT, a);
        b.renderingProperties = {}
    },
    initAnimations: function () {
        var a = this;
        a.animationList = new Animation.CanvasAnimationList();
        a.textItem = a.createTextItem();
        a.backgroundItem = a.createBackgroundItem();
        a.animationList.add(a.backgroundItem);
        a.animationList.add(a.textItem);
        Game.stage.view.addToRenderLoop(a.animationList);
        a.animationList.stop()
    },
    createTextItem: function () {
        var b = this, a = Environment.getOrientationSpecificConfig(b.CONFIG, true),
            c = Animation.utils.text.createNumberDrawingProperties(a);
        b.renderingProperties[Environment.getOrientation()] = c;
        return new Animation.CanvasAnimationItem({
            top: 0,
            left: 0,
            width: 0,
            height: 0,
            depth: Layering.Game.Slots.CoinWin.text,
            customProps: {text: "not set yet", renderingProperties: c},
            executeBefore: function (d) {
                var e = this.customProps.renderingProperties;
                Animation.utils.text.drawTextFromImage(this.customProps.text, a.NUMBER_OFFSET, this.pivot.x, this.pivot.y, true, e.image, e.charMap, e.width, e.height, d)
            },
            operations: {
                fade: [{time: 0, value: 1, fireEvent: {event: "view:animationComplete", scope: b}}, {
                    time: 1,
                    value: 1,
                    goTo: 0
                }]
            }
        })
    },
    createBackgroundItem: function () {
        var a = this, b = Game.stage.model.getSymbolConfiguration(0, 0);
        return new Animation.CanvasAnimationItem({
            width: a.CONFIG.DEFAULT.BACKGROUND_WIDTH || b.width,
            height: a.CONFIG.DEFAULT.BACKGROUND_HEIGHT || b.height,
            depth: Layering.Game.Slots.CoinWin.background,
            executeBefore: a.CONFIG.DEFAULT.BACKGROUND_DRAWING_FUNCTION,
            image: a.CONFIG.DEFAULT.BACKGROUND_IMAGE
        })
    },
    animate: function (a) {
        this.animationList.restore();
        this.updateAnimationItems(a);
        this.animationList.play()
    },
    updateAnimationItems: function (a) {
        var b = this, c;
        c = Game.stage.model.getSymbolConfiguration(a.x, a.y);
        b.backgroundItem.prop.top = c.top;
        b.backgroundItem.prop.left = c.left;
        b.textItem.setTop(c.top + c.height / 2);
        b.textItem.setLeft(c.left + c.width / 2);
        b.textItem.prop.customProps.text = a.coins
    },
    abort: function () {
        this.animationList.stop();
        this.fireEvent("view:animationAborted")
    },
    updateItems: function () {
        var e = this, c = Environment.getOrientationSpecificConfig(e.CONFIG, true),
            d = e.model.readData("currentWinSituation") || {x: 0, y: 0}, b = Environment.getOrientation(),
            f = Game.stage.model.getSymbolConfiguration(d.x, d.y), a = e.setRenderingProperties(c, b);
        if (Animation.utils.isAnimationItem(e.textItem)) {
            e.textItem.setWidth(a.width);
            e.textItem.setHeight(a.height);
            e.textItem.setTop(f.top + f.height / 2);
            e.textItem.setLeft(f.left + f.width / 2);
            e.textItem.prop.customProps.renderingProperties = a
        }
        if (Animation.utils.isAnimationItem(e.backgroundItem)) {
            e.backgroundItem.setWidth(c.BACKGROUND_WIDTH || f.width);
            e.backgroundItem.setHeight(c.BACKGROUND_HEIGHT || f.height);
            e.backgroundItem.setTop(f.top);
            e.backgroundItem.setLeft(f.left)
        }
    },
    setRenderingProperties: function (b, a) {
        if (!Sys.isDefined(this.renderingProperties[a])) {
            this.renderingProperties[a] = Animation.utils.text.createNumberDrawingProperties(b)
        }
        return this.renderingProperties[a]
    },
    refresh: function () {
        this.updateItems()
    }
};
Game.Slots.CoinWinView = Sys.extend(Core.View, Game.Slots.CoinWinView, "Game.Slots.CoinWinView");
Sys.ns("Game.Slots");
Game.Slots.CoinWinController = {
    constructor: function () {
        Game.Slots.CoinWinController.superclass.constructor.apply(this, arguments)
    }, setupEvents: function () {
        var a = this;
        a.on({
            "notify:responseParser.responseParsed": a.model.processServerResponse.bind(a.model),
            "notify:winSituationsDisplay.togglingWinSituation": a.animate,
            "notify:winSituationsDisplay.abort": a.abort,
            "view:animationComplete": a.animationComplete,
            "view:animationAborted": a.animationComplete,
            "notify:scaling.gameSizeChanged": a.onGameSizeChanged
        })
    }, animate: function (b) {
        var d = this, a = d.model.readData("winSituations"), c = b % a.length;
        if (a.length > 0 && Sys.isDefined(a[c])) {
            d.model.setState("animating");
            d.view.animate(a[c]);
            d.model.storeData("currentWinSituation", a[c]);
            d.fireEvent("request:winSituationsDisplay.waitFor", "notify:coinWin.animationComplete")
        }
    }, animationComplete: function () {
        this.fireEvent("notify:coinWin.animationComplete")
    }, abort: function () {
        if (this.model.isState("animating")) {
            this.view.abort();
            this.model.removeData("currentWinSituation");
            this.model.setState("idle")
        }
    }, onGameSizeChanged: function () {
        if (Sys.isFunc(this.view.refresh)) {
            this.view.refresh()
        }
    }
};
Game.Slots.CoinWinController = Sys.extend(Core.Controller, Game.Slots.CoinWinController, "Game.Slots.CoinWinController");
Sys.ns("Game.Slots");
Game.Slots.NoWinSymbols = {
    constructor: function () {
        Game.Slots.NoWinSymbols.superclass.constructor.apply(this, arguments)
    }, getMixinDependencies: function () {
        return ["serverResponse", "animation"]
    }, getDefaultMVCClasses: function () {
        return {
            model: Game.Slots.NoWinSymbolsModel,
            controller: Game.Slots.NoWinSymbolsController,
            view: Game.Slots.NoWinSymbolsView
        }
    }
};
Game.Slots.NoWinSymbols = Sys.extend(Core.Module, Game.Slots.NoWinSymbols, "Game.Slots.NoWinSymbols");
Sys.ns("Game.Slots");
Game.Slots.NoWinSymbolsModel = {
    constructor: function () {
        Game.Slots.NoWinSymbolsModel.superclass.constructor.apply(this, arguments)
    }, processServerResponse: function (f) {
        var d = f.reelInfo, h = 0, a, c, b, j, i = {}, g = [], e;
        if (Sys.isDefined(d) && Sys.isDefined(f.wins) && Sys.isArray(f.wins.winSituations)) {
            a = d.length;
            for (c = 0; c < a; c++) {
                h = Math.max(h, d[c].symbols.length)
            }
            j = Sys.utils.init2dMatrix(a, h, false);
            Sys.each(f.wins.winSituations, function (k) {
                Sys.each(k.positions, function (l) {
                    j[l.reelIndex][l.symbolIndex] = true
                })
            });
            for (c = 0; c < a; c++) {
                for (b = 0; b < d[c].symbols.length; b++) {
                    if (!j[c][b]) {
                        if (d[c].overlaySymbols[b]) {
                            e = d[c].overlaySymbols[b]
                        } else {
                            e = d[c].symbols[b]
                        }
                        g.push({x: c, y: b, symbol: e});
                        if (!i.hasOwnProperty(c)) {
                            i[c] = []
                        }
                        i[c].push(b)
                    }
                }
            }
        }
        this.storeData("symbolsToAnimateMatrix", i);
        this.storeData("symbolsToAnimate", g)
    }
};
Game.Slots.NoWinSymbolsModel = Sys.extend(Core.Model, Game.Slots.NoWinSymbolsModel, "Game.Slots.NoWinSymbolsModel");
Sys.ns("Game.Slots");
Game.Slots.NoWinSymbolsView = {
    constructor: function () {
        var a = this;
        Game.Slots.NoWinSymbolsView.superclass.constructor.apply(a, arguments);
        a.animationList = new Animation.List({id: "noWinSymbols"});
        Game.stage.view.addToRenderLoop(a.animationList);
        a.animationList.stop()
    }, initAnimations: function () {
    }, animateNoWinSymbols: function () {
        var b = this, a = b.model.readData("symbolsToAnimate"), c = Resources.readData("symbolLayout");
        Sys.each(a, function (d) {
            b.animationList.add(b.getAnimationItem({
                symbolName: d.symbol,
                reelIndex: d.x,
                symbolIndex: d.y,
                top: c[d.x][d.y].top,
                left: c[d.x][d.y].left,
                width: c[d.x][d.y].width,
                height: c[d.x][d.y].height,
                depth: c[d.x][d.y].depth
            }))
        });
        b.animationList.play()
    }, refresh: function () {
        this.stopAnimateNoWinSymbols();
        if (this.model.readData("shouldAnimate")) {
            this.animateNoWinSymbols()
        }
    }, getAnimationItem: function (a) {
    }, stopAnimateNoWinSymbols: function () {
        this.animationList.stop();
        this.animationList.removeItems()
    }
};
Game.Slots.NoWinSymbolsView = Sys.extend(Core.View, Game.Slots.NoWinSymbolsView, "Game.Slots.NoWinSymbolsView");
Sys.ns("Game.Slots");
Game.Slots.NoWinSymbolsController = {
    constructor: function () {
        Game.Slots.NoWinSymbolsController.superclass.constructor.apply(this, arguments)
    }, setupEvents: function () {
        var a = this;
        a.on({
            "request:noWinSymbols.animate": a.animateNoWinSymbols,
            "request:noWinSymbols.stopAnimate": a.stopAnimateNoWinSymbols,
            "notify:winSituationsDisplay.showingAllWins": a.animateNoWinSymbols,
            "notify:stateHandler.enteringSpinningState": a.enteringSpinningState,
            "notify:stateHandler.enteringFreeSpinOutroState": a.stopAnimateNoWinSymbols,
            "notify:stateHandler.enteringFreeSpinIntroState": a.stopAnimateNoWinSymbols,
            "notify:settingsManager.settingChanged": a.onSettingsChanged,
            "notify:scaling.gameSizeChanged": a.onGameSizeChanged
        })
    }, onGameSizeChanged: function () {
        if (Sys.isFunc(this.view.refresh)) {
            this.view.refresh()
        }
    }, enteringSpinningState: function () {
        this.model.storeData("shouldAnimate", false);
        this.stopAnimateNoWinSymbols()
    }, animateNoWinSymbols: function () {
        var c = this, b = c.model, a = b.readData("symbolsToAnimateMatrix");
        if (a && Object.keys(a).length > 0) {
            c.model.storeData("shouldAnimate", true);
            c.fireEvent("request:spin.hideSymbols", a);
            c.view.animateNoWinSymbols()
        }
    }, stopAnimateNoWinSymbols: function () {
        var c = this, b = c.model, a = b.readData("symbolsToAnimateMatrix");
        if (a && Object.keys(a).length > 0) {
            c.view.stopAnimateNoWinSymbols();
            c.fireEvent("request:spin.showSymbols", a)
        }
    }, onSettingsChanged: function (a) {
        if (["betLevel", "denomination"].contains(a)) {
            this.stopAnimateNoWinSymbols()
        }
    }
};
Game.Slots.NoWinSymbolsController = Sys.extend(Core.Controller, Game.Slots.NoWinSymbolsController, "Game.Slots.NoWinSymbolsController");
Sys.ns("Game.Slots");
Game.Slots.DimmedNoWinSymbols = {
    constructor: function () {
        Game.Slots.DimmedNoWinSymbols.superclass.constructor.apply(this, arguments)
    }, getDefaultMVCClasses: function () {
        return {
            model: Game.Slots.NoWinSymbolsModel,
            controller: Game.Slots.NoWinSymbolsController,
            view: Game.Slots.DimmedNoWinSymbolsView
        }
    }
};
Game.Slots.DimmedNoWinSymbols = Sys.extend(Game.Slots.NoWinSymbols, Game.Slots.DimmedNoWinSymbols, "Game.Slots.DimmedNoWinSymbols");
Sys.ns("Game.Slots");
Game.Slots.DimmedNoWinSymbolsView = {
    OPACITY: 0.3, constructor: function () {
        Game.Slots.DimmedNoWinSymbolsView.superclass.constructor.apply(this, arguments)
    }, initAnimations: function () {
        var e = this, a = Resources.readData("animationImages"), b, c, d = {};
        Sys.iterate(a, function (f, g) {
            if (f.match(/^SYM\d+$/)) {
                b = document.createElement("canvas");
                b.width = g.width;
                b.height = g.height;
                c = b.getContext("2d");
                c.globalAlpha = e.OPACITY;
                c.drawImage(g, 0, 0);
                d[f] = b
            }
        });
        e.model.storeData("animatedImages", d)
    }, getAnimationItem: function (b) {
        var a = this.model.readData("animatedImages")[b.symbolName];
        return new Animation.Item({
            top: b.top,
            left: b.left,
            width: b.width,
            height: b.height,
            image: a,
            depth: b.depth
        })
    }
};
Game.Slots.DimmedNoWinSymbolsView = Sys.extend(Game.Slots.NoWinSymbolsView, Game.Slots.DimmedNoWinSymbolsView, "Game.Slots.DimmedNoWinSymbolsView ");
Sys.ns("Game.Slots");
Game.Slots.ReelStopAnimations = {
    constructor: function () {
        Game.Slots.ReelStopAnimations.superclass.constructor.apply(this, arguments)
    }, getMixinDependencies: function () {
        return ["animation", "serverResponse", "trigger"]
    }, getStateChanges: function () {
        var c = this, b = c.model, a = c.MODULE_NAME, d = {
            state: {
                name: a[0].toUpperCase() + a.substr(1), execute: function () {
                }, waitEvents: {}
            }
        }, e = {
            stopped: {
                queue: [function (f) {
                    if (b.readData("shouldAnimate") && !b.readData("quickStopTriggered") && !b.readData("animationsComplete")) {
                        f.stateHandler.pushState(f.states[a])
                    }
                }]
            }
        };
        d.state.waitEvents["notify:" + a + ".animationsComplete"] = false;
        e[a] = d;
        return e
    }, getDefaultMVCClasses: function () {
        return undefined
    }
};
Game.Slots.ReelStopAnimations = Sys.extend(Core.Module, Game.Slots.ReelStopAnimations, "Game.Slots.ReelStopAnimations");
Sys.ns("Game.Slots");
Game.Slots.ReelStopAnimationsModel = {
    SYMBOLS_TO_ANIMATE: [], constructor: function () {
        Game.Slots.ReelStopAnimationsModel.superclass.constructor.apply(this, arguments)
    }, processServerResponse: function (d) {
        var a = this.SYMBOLS_TO_ANIMATE, c = [], b;
        Sys.each(d.reelInfo, function (e, f) {
            c.push([]);
            Sys.each(e.symbols, function (h, g) {
                b = e.overlaySymbols[g];
                if (a.contains(b)) {
                    c[f].push({symbol: b, symbolIndex: g})
                } else {
                    if (a.contains(h)) {
                        c[f].push({symbol: h, symbolIndex: g})
                    }
                }
            })
        });
        c = this.applyConditions(c);
        this.calculateLastReelToAnimate(c);
        this.storeData("symbolsToAnimateInOutcome", c)
    }, applyConditions: function (a) {
        return a
    }, calculateLastReelToAnimate: function (c) {
        var b = this, d = {}, a = false;
        Sys.each(c, function (f, e) {
            Sys.each(f, function (g) {
                if (b.SYMBOLS_TO_ANIMATE.contains(g.symbol)) {
                    a = true;
                    d[g.symbol] = e
                }
            })
        });
        b.storeData("shouldAnimate", a);
        b.storeData("lastReelToAnimate", d)
    }
};
Game.Slots.ReelStopAnimationsModel = Sys.extend(Core.Model, Game.Slots.ReelStopAnimationsModel, "Game.Slots.ReelStopAnimationsModel");
Sys.ns("Game.Slots");
Game.Slots.ReelStopAnimationsController = {
    constructor: function () {
        Game.Slots.ReelStopAnimationsController.superclass.constructor.apply(this, arguments)
    }, setupEvents: function () {
        var a = this;
        a.on({
            "notify:stateHandler.enteringSpinningState": a.onSpinStart,
            "notify:quickStopper.quickStop": a.onQuickStopTriggered,
            "request:reelStopAnimations.abort": a.abortTriggered,
            "notify:spin.reelStoppedSpinning": a.onReelStopped,
            "view:animationsComplete": a.onAnimationsComplete,
            "view:playSound": a.fireEvent.bind(a, "request:audioPlayer.play"),
            "view:stopSound": a.fireEvent.bind(a, "request:audioPlayer.stop")
        })
    }, registerTriggers: function () {
        Services.trigger.registerTrigger("notify:reelStopAnimations.symbolsToAnimate", this, "When there are scatter symbols to animate.")
    }, onSpinStart: function () {
        this.model.storeData("quickStopTriggered", false);
        this.model.storeData("animationsComplete", false);
        this.model.storeData("abortTriggered", false)
    }, onQuickStopTriggered: function () {
        this.model.storeData("quickStopTriggered", true);
        this.abort()
    }, abortTriggered: function () {
        this.model.storeData("abortTriggered", true);
        this.abort()
    }, onReelStopped: function (c) {
        var b = this.model, a = b.readData("symbolsToAnimateInOutcome")[c];
        if (!b.readData("quickStopTriggered") && !b.readData("abortTriggered") && a.length > 0) {
            this.view.animate(a, c);
            this.fireEvent("notify:reelStopAnimations.symbolsToAnimate", c, a)
        }
    }, onAnimationsComplete: function () {
        this.model.storeData("animationsComplete", true);
        this.fireEvent("notify:" + this.MODULE_NAME + ".animationsComplete")
    }, abort: function () {
        this.view.abort();
        this.fireEvent("notify:" + this.MODULE_NAME + ".animationsComplete")
    }
};
Game.Slots.ReelStopAnimationsController = Sys.extend(Core.Controller, Game.Slots.ReelStopAnimationsController, "Game.Slots.ReelStopAnimationsController");
Sys.ns("Game.Slots");
Game.Slots.WinningSymbols = {
    constructor: function () {
        Game.Slots.WinningSymbols.superclass.constructor.apply(this, arguments)
    }, getMixinDependencies: function () {
        return ["animation"]
    }, getDefaultMVCClasses: function () {
        return {
            model: Game.Slots.WinningSymbolsModel,
            view: Game.Slots.WinningSymbolsView,
            controller: Game.Slots.WinningSymbolsController
        }
    }
};
Game.Slots.WinningSymbols = Sys.extend(Core.Module, Game.Slots.WinningSymbols, "Game.Slots.WinningSymbols");
Sys.ns("Game.Slots");
Game.Slots.WinningSymbolsView = {
    constructor: function () {
        Game.Slots.WinningSymbolsView.superclass.constructor.apply(this, arguments)
    },
    ALL_WINNING_SYMBOLS_ANIMATION_TIME: 1000,
    WIN_SITUATION_ANIMATION_TIMES: {SYM0: 1000, SYM1: 1000},
    configureItemForAllWinningSymbolsDisplay: function (d, a, f) {
        var b = this, c = Game.stage.model.getSymbolConfiguration(a.x, a.y),
            e = this.ALL_WINNING_SYMBOLS_ANIMATION_TIME;
        d.prop = Sys.apply(d.prop, {
            depth: Layering.Game.Slots.WinningSymbols.animationItems,
            executeBefore: function (h, i, g, k) {
                var j = k.prop;
                h.fillStyle = "#ffffff";
                h.fillRect(j.pivot.x, j.pivot.y, j.width, j.height)
            },
            operations: {
                fade: [{time: 0, value: 0}, {time: e / 2, value: 1}, {
                    time: e,
                    value: 0,
                    fireEvent: {event: "view:animationComplete", scope: b}
                }]
            }
        });
        d.prop.top = c.top;
        d.prop.left = c.left;
        d.prop.width = c.width;
        d.prop.height = c.height;
        d.restore()
    },
    configureItemForWinSituationToggling: function (d, a, f) {
        var b = this, c = Game.stage.model.getSymbolConfiguration(a.x, a.y),
            e = this.WIN_SITUATION_ANIMATION_TIMES[a.symbol];
        d.prop = Sys.apply(d.prop, {
            depth: Layering.Game.Slots.WinningSymbols.animationItems,
            executeBefore: function (g) {
                g.fillStyle = "#fdfd00";
                g.fillRect(this.pivot.x, this.pivot.y, this.width, this.height)
            },
            operations: {
                fade: [{time: 0, value: 0}, {time: e / 2, value: 1}, {
                    time: e,
                    value: 0,
                    fireEvent: {event: "view:animationComplete", scope: b}
                }]
            }
        });
        d.prop.top = c.top;
        d.prop.left = c.left;
        d.prop.width = c.width;
        d.prop.height = c.height;
        d.restore()
    },
    initAnimations: function () {
        var c = this, d = Game.stage.model.getCurrentReelGroupConfiguration(), a = d.symbolCols, b = d.symbolRows;
        c.animationItems = Sys.utils.init2dMatrix(a, b);
        c.animationList = new Animation.CanvasAnimationList();
        Game.stage.view.addToRenderLoop(c.animationList);
        c.animationList.stop()
    },
    animateAllWinningSymbols: function (a) {
        this.animateSymbols(this.model.readData("winningSymbols"), this.configureItemForAllWinningSymbolsDisplay, a)
    },
    animateWinSituationSymbols: function (a, b) {
        this.animateSymbols(a, this.configureItemForWinSituationToggling, b)
    },
    animateSymbols: function (b, c, g) {
        var e = this, a, f, d;
        e.animationList.restore();
        e.animationList.stop();
        Sys.each(b, function (h) {
            a = h.x;
            f = h.y;
            if (Sys.isDefined(e.animationItems[a][f])) {
                d = e.animationItems[a][f]
            } else {
                d = new Animation.CanvasAnimationItem({});
                e.animationList.add(d);
                e.animationItems[a][f] = d
            }
            c.call(e, d, h, g);
            d.play()
        })
    },
    stop: function () {
        this.animationList.stop();
        this.fireEvent("view:animationComplete")
    },
    refresh: function () {
        var b = this, a = this.model.readData("winningSymbols");
        Sys.each(a, function (f) {
            var c = f.x, g = f.y, e = Game.stage.model.getSymbolConfiguration(c, g), d = b.animationItems[c][g];
            if (Animation.utils.isAnimationItem(d)) {
                d.prop.top = e.top;
                d.prop.left = e.left;
                d.prop.width = e.width;
                d.prop.height = e.height
            }
        })
    }
};
Game.Slots.WinningSymbolsView = Sys.extend(Core.View, Game.Slots.WinningSymbolsView, "Game.Slots.WinningSymbolsView");
Sys.ns("Game.Slots");
Game.Slots.WinningSymbolsController = {
    constructor: function () {
        Game.Slots.WinningSymbolsController.superclass.constructor.apply(this, arguments)
    }, setupEvents: function () {
        var a = this;
        a.on({
            "notify:responseParser.responseParsed": a.model.processServerResponse.bind(a.model),
            "notify:winSituationsDisplay.showingAllWins": a.animateAllWinningSymbols,
            "notify:winSituationsDisplay.togglingWinSituation": a.animateWinSituationSymbols,
            "notify:winSituationsDisplay.abort": a.abort,
            "view:animationComplete": a.onAnimationComplete,
            "view:hideSymbol": a.hideSymbol,
            "view:showSymbol": a.showSymbol,
            "view:playSound": a.playSound,
            "view:stopSound": a.stopSound,
            "notify:scaling.gameSizeChanged": a.onGameSizeChanged
        })
    }, onGameSizeChanged: function () {
        if (Sys.isFunc(this.view.refresh)) {
            this.view.refresh()
        }
    }, playSound: function (a) {
        this.fireEvent("request:audioPlayer.play", a)
    }, stopSound: function (a) {
        this.fireEvent("request:audioPlayer.stop", a)
    }, animateWinSituationSymbols: function (b, d) {
        var c = this, a = c.model.readData("winSituationSymbols")[b];
        if (Sys.isArray(a) && a.length > 0) {
            c.model.setState("animating");
            c.fireEvent("request:winSituationsDisplay.waitFor", "notify:winningSymbols.animationComplete");
            c.view.animateWinSituationSymbols(a, d)
        }
    }, animateAllWinningSymbols: function (b) {
        var a = this;
        if (a.model.readData("winningSymbols").length > 0) {
            a.model.setState("animating");
            a.fireEvent("request:winSituationsDisplay.waitFor", "notify:winningSymbols.animationComplete");
            a.view.animateAllWinningSymbols(b)
        }
    }, abort: function () {
        if (this.model.isState("animating")) {
            this.view.stop()
        }
    }, onAnimationComplete: function () {
        this.model.setState("idle");
        this.fireEvent("notify:winningSymbols.animationComplete")
    }, hideSymbol: function (a) {
        this.fireEvent("request:spin.hideSymbols", a)
    }, showSymbol: function (a) {
        this.fireEvent("request:spin.showSymbols", a)
    }
};
Game.Slots.WinningSymbolsController = Sys.extend(Core.Controller, Game.Slots.WinningSymbolsController, "Game.Slots.WinningSymbolsController");
Sys.ns("Interface.utils");
Interface.utils.CSSAnimation = {
    constructor: function (a) {
        Interface.utils.CSSAnimation.superclass.constructor.apply(this, arguments);
        this.init(a)
    }, run: function (a, c) {
        var b = this;
        if (Sys.isDefined(c)) {
            b.setupEvent(a, "AnimationEnd", c)
        }
        a.style[b.animationType] = b.name + " " + b.duration + "ms " + b.delay + "ms";
        if (Sys.isDefined(b.timingFunction)) {
            a.style[b.animationType + "TimingFunction"] = b.timingFunction
        }
        if (Sys.isDefined(b.iterationCount)) {
            a.style[b.animationType + "IterationCount"] = b.iterationCount
        }
        if (Sys.isDefined(b.fillMode.mode)) {
            a.style[b.fillMode.type] = b.fillMode.mode
        }
    }, removeAnimation: function (a) {
        a.style[this.animationType] = "none"
    }, init: function (a) {
        var b = this;
        b.name = a.name;
        b.duration = a.duration;
        b.delay = Sys.isDefined(a.delay) ? a.delay : 0;
        b.timingFunction = a.timingFunction;
        b.iterationCount = a.iterationCount;
        b.fillMode = {type: Sys.utils.pollyFill("animationFillMode"), mode: a.fillMode};
        b.setupAnimation(a);
        b.animationType = Sys.utils.pollyFill("animation");
        b.prefixes = ["webkit", "moz", "MS", "o", ""]
    }, setupAnimation: function (a) {
        var c = this, b = this.getRuleString(a);
        c.style = document.head.appendChild(document.createElement("style"));
        c.insertRule(b)
    }, insertRule: function (a) {
        if (CSSRule.WEBKIT_KEYFRAMES_RULE) {
            this.style.sheet.insertRule("@-webkit-keyframes" + a, 0)
        } else {
            if (CSSRule.KEYFRAMES_RULE) {
                this.style.sheet.insertRule("@keyframes" + a, 0)
            }
        }
    }, removeRule: function (a) {
        this.style.sheet.deleteRule(a)
    }, getRuleString: function (a) {
        var g = Object.keys(a.frames), b = g.length, d = 0, f = " " + a.name + " {", k, l, h, e, c;
        while (d < b) {
            k = g[d];
            f += " " + k;
            l = Object.keys(a.frames[k]);
            e = l.length;
            c = 0;
            f += " {";
            while (c < e) {
                h = l[c];
                f += h + " : " + a.frames[k][h] + ";";
                ++c
            }
            f += " }";
            ++d
        }
        f += " }";
        return f
    }, setupEvent: function (c, d, g) {
        var e = this, f = e.prefixes, b, a;
        for (b = -1, a = f.length; ++b < a;) {
            if (!f[b]) {
                d = d.toLowerCase()
            }
            c.addEventListener(f[b] + d, g, false)
        }
    }, removeEvent: function (c, d, g) {
        var e = this, f = e.prefixes, b, a;
        for (b = -1, a = f.length; ++b < a;) {
            if (!f[b]) {
                d = d.toLowerCase()
            }
            c.removeEventListener(f[b] + d, g, false)
        }
    }
};
Interface.utils.CSSAnimation = Sys.extend(Sys.Observable, Interface.utils.CSSAnimation, "Interface.utils.CSSAnimation");
Sys.ns("Interface.utils");
Interface.utils.CardNavigation = {
    CSS: {
        ARROWS: "interface-cardNavigation_arrows clearfix trim",
        ARROWS_PREVIOUS: "interface-cardNavigation_arrows_previous",
        ARROWS_CLOSE: "interface-cardNavigation_arrows_close",
        ARROWS_NEXT: "interface-cardNavigation_arrows_next",
        INDICATORS: "interface-cardNavigation_indicators clearfix utils_horizontal_center trim",
        INDICATORS_CHILD: "interface-cardNavigation_indicator",
        INDICATORS_SELECTED: "interface-cardNavigation_selectedIndicator",
        DISABLED: "interface-cardNavigation_disabled"
    }, constructor: function (a) {
        this.currentCard = 0;
        Interface.utils.CardNavigation.superclass.constructor.apply(this, arguments)
    }, getArrows: function () {
        return this.arrowContainer
    }, getIndicators: function () {
        return this.indicatorContainer
    }, getContainer: function (a) {
        if (a === "arrows") {
            return this.getArrows()
        } else {
            if (a === "indicators") {
                return this.getIndicators()
            }
        }
        return undefined
    }, getCurrentCardIndex: function () {
        return this.currentCard
    }, next: function () {
        var c = this, a = c.currentCard + 1, b = false;
        if (a >= c.numCards) {
            a = 0;
            b = true
        }
        c.selectCard(a, false, b)
    }, previous: function () {
        var c = this, a = c.currentCard - 1, b = false;
        if (a < 0) {
            a = c.numCards - 1;
            b = true
        }
        c.selectCard(a, false, b)
    }, selectCard: function (b, e, a) {
        var d = this, c = d.indicatorChildren;
        if (b >= 0 && b < d.numCards) {
            c[d.currentCard].removeCls(d.CSS.INDICATORS_SELECTED);
            c[b].addCls(d.CSS.INDICATORS_SELECTED);
            if (e !== true) {
                d.selectionCallback(b, d.currentCard, a)
            }
            d.currentCard = b
        }
    }, enable: function () {
        var a = this;
        a.enabled = true;
        a.arrowContainer.removeCls(a.CSS.DISABLED);
        a.indicatorContainer.removeCls(a.CSS.DISABLED);
        a.performActionOnSubComponent("enable")
    }, disable: function () {
        var a = this;
        a.enabled = false;
        a.arrowContainer.removeCls(a.CSS.DISABLED);
        a.indicatorContainer.removeCls(a.CSS.DISABLED);
        a.performActionOnSubComponent("disable")
    }, close: function () {
        if (this.hasCloseButton) {
            this.closeCallback()
        }
    }, performActionOnSubComponent: function (d) {
        var c = this.subComponents, a = c.length, b;
        for (b = -1; ++b < a;) {
            c[b][d]()
        }
    }, setupContainer: function (b) {
        var c = this, a = Sys.isDefined(b.selectedCard) ? b.selectedCard : 0;
        c.numCards = b.numCards;
        c.selectionCallback = b.selectionCallback;
        c.closeCallback = b.closeCallback;
        c.hasCloseButton = Sys.isDefined(b.closeCallback);
        c.subComponents = [];
        c.setupArrows(b.arrowLabels);
        c.setupIndicators();
        c.selectCard(a, true)
    }, setupArrows: function (c) {
        var b = this, a = Sys.isObj(c);
        b.arrowContainer = new Sys.Element({id: b.id + "_arrows", tag: "ul", cls: b.CSS.ARROWS});
        b.previousArrow = new Interface.utils.DOMButton({
            id: "paytablePrevious",
            tag: "li",
            baseCSS: b.CSS.ARROWS_PREVIOUS,
            textContent: (a && Sys.isDefined(c.previous)) ? c.previous : "",
            clickCallback: b.previous.bind(b)
        });
        b.arrowContainer.add(b.previousArrow.getContainer());
        b.subComponents.push(b.previousArrow);
        if (b.hasCloseButton) {
            b.closeArrow = new Interface.utils.DOMButton({
                id: "paytableClose",
                tag: "li",
                baseCSS: b.CSS.ARROWS_CLOSE,
                textContent: (a && Sys.isDefined(c.close)) ? c.close : "",
                clickCallback: b.close.bind(b)
            });
            b.arrowContainer.add(b.closeArrow.getContainer());
            b.subComponents.push(b.closeArrow)
        }
        b.nextArrow = new Interface.utils.DOMButton({
            id: "paytableNext",
            tag: "li",
            baseCSS: b.CSS.ARROWS_NEXT,
            textContent: (a && Sys.isDefined(c.next)) ? c.next : "",
            clickCallback: b.next.bind(b)
        });
        b.arrowContainer.add(b.nextArrow.getContainer());
        b.subComponents.push(b.nextArrow)
    }, setupIndicators: function () {
        var c = this, d = new Sys.Element({id: c.id + "indicators", tag: "ul", cls: c.CSS.INDICATORS}), b = [], e, a;
        for (a = -1; ++a < c.numCards;) {
            e = new Interface.utils.DOMButton({
                id: "paytableIndicator_" + a,
                tag: "li",
                baseCSS: c.CSS.INDICATORS_CHILD,
                clickCallback: c.selectCard.bind(c, a)
            });
            b.push(d.add(e.getContainer()));
            c.subComponents.push(e)
        }
        c.indicatorContainer = d;
        c.indicatorChildren = b
    }
};
Interface.utils.CardNavigation = Sys.extend(Interface.utils.UserInputBase, Interface.utils.CardNavigation, "Interface.utils.CardNavigation");
Sys.ns("Interface.utils");
Interface.utils.GroupTitle = {
    CSS: {
        base: "interface-groupTitle_base",
        disabled: "interface-groupTitle_disabled",
        label: "interface-groupTitle_label"
    }, constructor: function (a) {
        Interface.utils.GroupTitle.superclass.constructor.apply(this, arguments)
    }, init: function (b) {
        var c = this, a = b.CSS;
        if (Sys.isDefined(a)) {
            c.CSS = Sys.applyIf(a, c.CSS)
        }
        c.title = b.title;
        Interface.utils.GroupTitle.superclass.init.apply(c, arguments)
    }, setupContainer: function (a) {
        var b = this;
        b.container = new Sys.Element({id: b.id, tag: "div", cls: a.cls + " " + b.CSS.base});
        if (b.title) {
            b.label = b.container.add(new Sys.Element({
                id: b.id + "_title",
                tag: "div",
                cls: b.CSS.label,
                textContent: b.title
            }))
        }
    }, setCSS: function (d) {
        var c = this, b = c.container, a = c.CSS;
        if (d.base) {
            b.replaceCSSClass(a.base, d.base)
        }
        if (!c.enabled && d.disabled) {
            b.replaceCSSClass(a.disabled, d.disabled)
        }
        if (d.label) {
            c.label.replaceCSSClass(a.label, d.label)
        }
        c.CSS = Sys.applyIf(d, a)
    }
};
Interface.utils.GroupTitle = Sys.extend(Interface.utils.UserInputBase, Interface.utils.GroupTitle, "Interface.utils.GroupTitle");
Sys.ns("Interface.utils");
Interface.utils.ToggleSwitch = {
    CSS: {
        base: "interface-toggleSwitch_base",
        disabled: "interface-toggleSwitch_disabled",
        label: "interface-toggleSwitch_label",
        button_wrapper: "interface-toggleSwitch_buttonWrapper",
        button_background: "interface-toggleSwitch_buttonBackground interface-toggleSwitch_buttonBackgroundSize",
        button_handle: "interface-toggleSwitch_buttonHandle interface-toggleSwitch_buttonHandleSize",
        loadAnimation: "interface-toggleSwitch_loadAnimation interface-smallSpinner_uri hidden"
    }, constructor: function (a) {
        Interface.utils.ToggleSwitch.superclass.constructor.apply(this, arguments)
    }, init: function (b) {
        var c = this, a = b.CSS || {};
        b.cls = Sys.isString(b.cls) ? b.cls : "";
        if (Sys.isDefined(a)) {
            c.CSS = Sys.applyIf(a, c.CSS)
        }
        c.title = b.title;
        c.callback = b.callback;
        c.turnedOn = false;
        c.listensToInput = b.listensToInput !== false;
        Interface.utils.ToggleSwitch.superclass.init.apply(c, arguments)
    }, setupContainer: function (a) {
        var b = this;
        b.container = new Sys.Element({id: b.id, tag: "div", cls: a.cls + " " + b.CSS.base + " off"});
        if (b.title) {
            b.label = b.container.add(new Sys.Element({
                id: b.id + "_title",
                tag: "div",
                cls: b.CSS.label,
                textContent: b.title
            }))
        }
        b.buttonWrapper = b.container.add(new Sys.Element({
            id: b.id + "_button_wrapper",
            tag: "div",
            cls: b.CSS.button_wrapper
        }));
        b.background = b.buttonWrapper.add(new Sys.Element({
            id: b.id + "_button_background",
            tag: "div",
            cls: b.CSS.button_background
        }));
        b.handle = b.background.add(new Sys.Element({
            id: b.id + "_button_handle",
            tag: "div",
            cls: b.CSS.button_handle
        }));
        b.loadAnimation = b.container.add(new Sys.Element({
            id: b.id + "_loadAnimation",
            tag: "div",
            cls: b.CSS.loadAnimation
        }))
    }, setCSS: function (e) {
        var d = this, b = d.container, c = d.button, a = d.CSS;
        if (e.base) {
            b.replaceCSSClass(a.base, e.base)
        }
        if (!d.enabled && e.disabled) {
            b.replaceCSSClass(a.disabled, e.disabled)
        }
        if (e.label) {
            d.label.replaceCSSClass(a.label, e.label)
        }
        if (e.button_wrapper) {
            c.replaceCSSClass(a.button_wrapper, e.button_wrapper)
        }
        if (e.button_background) {
            c.replaceCSSClass(a.button_background, e.button_background)
        }
        if (e.button_handle) {
            c.replaceCSSClass(a.button_handle, e.button_handle)
        }
        d.CSS = Sys.applyIf(e, a)
    }, toggle: function (e, d) {
        var b = this, a = b.turnedOn, c = Sys.isDefined(e) ? e : !a;
        if (b.isLocked()) {
            return
        }
        if (c !== a) {
            if (c) {
                b.container.replaceCSSClass("off", "on")
            } else {
                b.container.replaceCSSClass("on", "off")
            }
            b.turnedOn = c;
            if (!d) {
                b.callback(c)
            }
        }
    }, isOn: function () {
        return this.turnedOn
    }, onUserInputStart: function (a) {
        this.wasInitialInputTarget = Sys.UserInputUtils.isCoordinateTarget(this.buttonWrapper.el, a) && this.enabled
    }, onUserInputEnd: function (c) {
        var b = this, a = Sys.UserInputUtils.isCoordinateTarget(b.buttonWrapper.el, c);
        if (a && b.wasInitialInputTarget) {
            b.toggle()
        }
        b.wasInitialInputTarget = false
    }, startListeningToUserInput: function () {
        var a = this;
        if (!a.listensToInput) {
            return
        }
        a.on({
            "notify:userInputManager.userInputStarted": a.onUserInputStart,
            "notify:userInputManager.userInputEnded": a.onUserInputEnd
        })
    }, stopListeningToUserInput: function () {
        if (!this.listensToInput) {
            return
        }
        this.removeListener("notify:userInputManager.userInputStarted");
        this.removeListener("notify:userInputManager.userInputEnded")
    }, displayLoadAnimation: function () {
        this.loadAnimation.removeCls("hidden");
        this.buttonWrapper.addCls("hidden")
    }, hideLoadAnimation: function () {
        this.loadAnimation.addCls("hidden");
        this.buttonWrapper.removeCls("hidden")
    }, setValue: function (b, a) {
        this.toggle(b, a)
    }
};
Interface.utils.ToggleSwitch = Sys.extend(Interface.utils.UserInputBase, Interface.utils.ToggleSwitch, "Interface.utils.ToggleSwitch");
Sys.ns("Interface.utils");
Interface.utils.Slider = {
    CSS: {
        base: "interface-slider_base",
        disabled: "interface-slider_disabled",
        label: "interface-slider_label",
        sliderWrapper: "interface-slider_sliderWrapper",
        background: "interface-slider_background",
        handle: "utils_center interface-slider_handle",
        fill: "interface-slider_fill",
        display: "utils_center interface-slider_display",
        verticalLine: "utils_center interface-slider_verticalLine"
    }, constructor: function () {
        Interface.utils.Slider.superclass.constructor.apply(this, arguments)
    }, init: function (b) {
        var d = this, a, c;
        if (Sys.isArray(b.values)) {
            a = b.values
        } else {
            a = [];
            for (c = b.minValue; c <= b.maxValue; c = Animation.utils.toNthDecimalPlace(c + b.valueStep, 5)) {
                a.push(c)
            }
        }
        if (!Sys.isDefined(b.useStepIndicator)) {
            b.useStepIndicator = true
        }
        d.callback = b.callback;
        d.values = a;
        d.callbackOnlyOnEndEvent = (b.callbackOnlyOnEndEvent === true);
        d.endCallback = Sys.isFunc(b.endCallback) ? b.endCallback : function () {
        };
        Interface.utils.Slider.superclass.init.apply(d, arguments);
        d.setStartValue(b);
        d.selectRenderFunction();
        d.transform = Sys.utils.pollyFill("transform")
    }, setStartValue: function (c) {
        var b = c.startValue, a = this.values, d = (Sys.isDefined(b) && a.indexOf(b) !== -1) ? b : a[0];
        this.setValue(d, true)
    }, setupContainer: function (a) {
        var b = this, c;
        b.container = new Sys.Element({id: b.id, tag: "div", cls: b.CSS.base, "data-input": true});
        b.sliderWrapper = b.container.add(new Sys.Element({id: b.id + "Slider", tag: "div", cls: b.CSS.sliderWrapper}));
        b.background = b.sliderWrapper.add(new Sys.Element({
            id: b.id + "SliderBackground",
            tag: "div",
            cls: b.CSS.background
        }));
        b.fill = b.background.add(new Sys.Element({id: b.id + "Fill", tag: "div", cls: b.CSS.fill}));
        if (a.showLabels) {
            b.showLabels = true;
            c = b.values[0].toString();
            b.minimumLabel = b.container.addAsFirst(new Sys.Element({
                id: b.id + "Minimum",
                tag: "div",
                cls: b.CSS.label + " " + b.CSS.label + "_left",
                textContent: c
            }));
            c = b.values[b.values.length - 1].toString();
            b.maximumLabel = b.container.add(new Sys.Element({
                id: b.id + "Maximum",
                tag: "div",
                cls: b.CSS.label + " " + b.CSS.label + "_right",
                textContent: c
            }))
        }
        b.handle = b.sliderWrapper.add(new Sys.Element({id: b.id + "Handle", tag: "div", cls: b.CSS.handle}));
        if (a.showDisplay !== false) {
            b.display = b.sliderWrapper.add(new Sys.Element({id: b.id + "Display", tag: "div", cls: b.CSS.display}));
            b.showDisplay = true
        }
    }, onUserInputStart: function (a) {
        var c = this, b = Sys.UserInputUtils.isCoordinateTarget(c.container.el, a) && c.enabled;
        c.startValue = c.value;
        if (b) {
            c.moveSliderToCoordinate(a, c.callbackOnlyOnEndEvent)
        }
        this.wasInitialInputTarget = b
    }, onUserInputMove: function (a) {
        var b = this;
        if (this.wasInitialInputTarget) {
            if (!b.bigDisplayShowing) {
                if (b.showDisplay) {
                    b.display.addCls("interface-slider_bigDisplay")
                }
                b.bigDisplayShowing = true
            }
            this.animationFunction.call(window, function () {
                b.moveSliderToCoordinate(a, b.callbackOnlyOnEndEvent)
            })
        }
    }, onUserInputEnd: function () {
        var b = this, a;
        if (b.wasInitialInputTarget) {
            b.animationFunction(function () {
                a = b.calculatePercentageFromValue(b.value);
                b.moveSlider(a, false, true);
                if (b.showDisplay) {
                    b.display.removeCls("interface-slider_bigDisplay")
                }
                if (b.bigDisplayShowing) {
                    b.bigDisplayShowing = false
                }
            });
            b.endCallback(b.value)
        }
        b.wasInitialInputTarget = false
    }, moveSliderToCoordinate: function (b, c) {
        var a = this.calculatePercentageFromCoordinate(b);
        this.moveSlider(a, c)
    }, calculatePercentageFromCoordinate: function (c) {
        var a = Sys.UserInputUtils.getCoordinatesRelativeToElement(c, this.sliderWrapper.el).x,
            d = this.sliderWrapper.el.offsetWidth, b;
        if (a < 0) {
            b = 0
        } else {
            if (a > d) {
                b = 1
            } else {
                b = a / d
            }
        }
        return b
    }, moveSlider: function (c, g, f) {
        var d = this, a = Animation.utils.toNthDecimalPlace((c * 100), 2) + "%", e = d.getValueFromPercentage(c),
            b = d.value;
        d.fill.el.style.width = a;
        d.handle.el.style.marginLeft = a;
        if (d.showDisplay) {
            d.display.el.style.marginLeft = a
        }
        if (e !== b || f) {
            d.setValue(e, g)
        }
    }, getValueFromPercentage: function (a) {
        var b = this.values, c = Math.round(a * (b.length - 1));
        return b[c]
    }, setValue: function (b, c) {
        var a = this;
        a.value = b;
        if (a.showDisplay) {
            a.display.el.textContent = b
        }
        if (!a.wasInitialInputTarget) {
            a.moveSlider(a.calculatePercentageFromValue(b), c)
        }
        if (!c) {
            a.callback(b)
        }
    }, calculatePercentageFromValue: function (d) {
        var b = this.values, c = b.indexOf(d), a = 1 / (b.length - 1);
        return c * a
    }, getValue: function () {
        return this.value
    }, selectRenderFunction: function () {
        var a = this;
        a.animationFunction = (window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (b) {
            clearTimeout(a.renderTimeout);
            a.renderTimeout = setTimeout(b, Math.round(1000 / 60))
        }).bind(window)
    }
};
Interface.utils.Slider = Sys.extend(Interface.utils.UserInputBase, Interface.utils.Slider, "Interface.utils.Slider");
Sys.ns("Interface.utils");
Interface.utils.VerticalSlider = {
    CSS: {
        base: "interface-verticalSlider_base",
        disabled: "interface-slider_disabled",
        label: "interface-slider_label",
        sliderWrapper: "interface-verticalSlider_sliderWrapper",
        background: "interface-verticalSlider_background interface-soundSettings_sliderBar_background_uri",
        handle: "interface-verticalSlider_handle interface-soundSettings_sliderHandle_uri",
        fill: "interface-verticalSlider_fill interface interface-soundSettings_sliderBar_fill_uri",
        display: "utils_center interface-verticalSlider_display",
        verticalLine: "utils_center interface-slider_verticalLine"
    }, ASCENDING_GROWTH: false, constructor: function () {
        Interface.utils.VerticalSlider.superclass.constructor.apply(this, arguments)
    }, init: function (a) {
        var c = this, b = (a.ascendingGrowth === true);
        c.ASCENDING_GROWTH = b;
        Interface.utils.VerticalSlider.superclass.init.apply(this, arguments);
        if (b) {
            c.fill.el.style.top = "auto";
            c.fill.el.style.bottom = 0
        }
    }, calculatePercentageFromCoordinate: function (c) {
        var d = Sys.UserInputUtils.getCoordinatesRelativeToElement(c, this.sliderWrapper.el).y,
            a = this.sliderWrapper.el.offsetHeight, b;
        if (d < 0) {
            b = 0
        } else {
            if (d > a) {
                b = 1
            } else {
                b = d / a
            }
        }
        if (this.ASCENDING_GROWTH) {
            b = 1 - b
        }
        return b
    }, moveSlider: function (c, g, f) {
        var d = this, a = Animation.utils.toNthDecimalPlace((c * 100), 2) + "%", e = d.getValueFromPercentage(c),
            b = d.value;
        d.fill.el.style.height = a;
        a = Animation.utils.toNthDecimalPlace(((d.ASCENDING_GROWTH ? 1 - c : c) * 100), 2) + "%";
        d.handle.el.style.top = a;
        if (e !== b || f) {
            d.setValue(e, g)
        }
    }
};
Interface.utils.VerticalSlider = Sys.extend(Interface.utils.Slider, Interface.utils.VerticalSlider, "Interface.utils.VerticalSlider");
Sys.ns("Interface.utils");
Interface.utils.CanvasValueSelector = {
    FONT_LABEL: "10px Verdana",
    FILLSTYLE_LABEL: "rgba( 238, 239, 206, 1 )",
    POSITION_OFFSET_LABEL: {x: 0, y: -18},
    FONT_VALUE: "bold 12px Verdana",
    FILLSTYLE_VALUE: "rgba( 238, 239, 206, 1 )",
    POSITION_OFFSET_VALUE: {x: 0, y: 9},
    IMAGE_RIGHT_UP: "selectorPlusUp",
    IMAGE_RIGHT_OVER: "selectorPlusUp",
    IMAGE_RIGHT_CLICK: "selectorPlusUp",
    IMAGE_RIGHT_DISABLED: "selectorPlusDisabled",
    IMAGE_RIGHT_DOWN: "selectorPlusDown",
    IMAGE_RIGHT_HOVER: "selectorPlusOver",
    IMAGE_LEFT_UP: "selectorMinusUp",
    IMAGE_LEFT_OVER: "selectorMinusUp",
    IMAGE_LEFT_CLICK: "selectorMinusUp",
    IMAGE_LEFT_DISABLED: "selectorMinusDisabled",
    IMAGE_LEFT_DOWN: "selectorMinusDown",
    IMAGE_LEFT_HOVER: "selectorMinusOver",
    HANDLE_DIMENSIONS: {LEFT: {width: 44, height: 52}, RIGHT: {width: 44, height: 52}},
    HANDLE_POSITION_OFFSET: {LEFT: {x: 0, y: 0}, RIGHT: {x: 88, y: 0}},
    HANDLE_COLLISION_BOX: {
        LEFT: {xOffset: 0, yOffset: 0, width: 44, height: 52},
        RIGHT: {xOffset: 0, yOffset: 0, width: 44, height: 52}
    },
    BAR_BACKGROUND: "selectorBarBackground",
    BAR_BACKGROUND_DISABLED: "selectorBarBackgroundDisabled",
    BAR_FILL: "selectorBarFill",
    BAR_FILL_DISABLED: "selectorBarFillDisabled",
    BAR_DIMENSIONS: {background: {width: 57, height: 7}, fill: {width: 53, height: 3}},
    BAR_POSITION_OFFSET: {background: {x: 37, y: 36}, fill: {x: 39, y: 38}},
    SLIDER_BAR_INPUT_OFFSET: {start: {width: 0, height: 0}, move: {width: 0, height: 0}},
    constructor: function () {
        Interface.utils.CanvasValueSelector.superclass.constructor.apply(this, arguments)
    },
    init: function (a) {
        var b = this;
        Interface.utils.CanvasValueSelector.superclass.init.call(b, a);
        b.currentIndex = 0;
        b.callback = a.callback;
        b.label = a.label;
        b.valueArray = a.values;
        b.valueNameArray = Sys.isDefined(a.valueNames) ? a.valueNames : b.valueArray;
        b.basePosition = {x: a.x, y: a.y};
        b.setupConfiguration(a);
        b.setupLayering(a);
        b.setupFontStyle(a);
        b.initAnimations();
        if (a.disabled === true) {
            b.disable("CanvasValueSelector")
        } else {
            b.enable("CanvasValueSelector")
        }
    },
    destroy: function () {
        this.disable("CanvasValueSelector");
        this.clearAnimationLists();
        this.destroyButtons()
    },
    destroyButtons: function () {
        this.buttons.LEFT.destroy();
        this.buttons.RIGHT.destroy();
        delete this.buttons
    },
    setupConfiguration: function (a) {
        var c = this, b = {
            position: {
                offsetLabel: a.positionOffsetLabel || c.POSITION_OFFSET_LABEL,
                offsetValue: a.positionOffsetValue || c.POSITION_OFFSET_VALUE
            },
            rightButton: a.rightButtonImage || {},
            leftButton: a.leftButtonImage || {},
            handle: {
                positionOffset: a.handlePositionOffset || c.HANDLE_POSITION_OFFSET,
                dimensions: a.handleDimensions || c.HANDLE_DIMENSIONS,
                collisionBox: a.handleCollisionBox || c.HANDLE_COLLISION_BOX
            },
            bar: {
                background: a.barBackground || c.BAR_BACKGROUND,
                backgroundDisabled: a.barBackgroundDisabled || c.BAR_BACKGROUND_DISABLED,
                fill: a.barFill || c.BAR_FILL,
                fillDisabled: a.barFillDisabled || c.BAR_FILL_DISABLED,
                dimensions: a.barDimensions || c.BAR_DIMENSIONS,
                positionOffset: a.barPositionOffset || c.BAR_POSITION_OFFSET
            }
        };
        c.setupPositionConfig(b.position);
        c.setupRightButtonConfig(b.rightButton);
        c.setupLeftButtonConfig(b.leftButton);
        c.setupHandleConfig(b.handle);
        c.setupBarConfig(b.bar)
    },
    setupPositionConfig: function (a) {
        var b = this;
        b.POSITION_OFFSET_LABEL = a.offsetLabel || b.POSITION_OFFSET_LABEL;
        b.POSITION_OFFSET_VALUE = a.offsetValue || b.POSITION_OFFSET_VALUE
    },
    setupRightButtonConfig: function (a) {
        var b = this;
        if (a && !Sys.isEmpty(a)) {
            b.IMAGE_RIGHT_UP = a.up || b.IMAGE_RIGHT_UP;
            b.IMAGE_RIGHT_DOWN = a.down || b.IMAGE_RIGHT_DOWN;
            b.IMAGE_RIGHT_HOVER = a.hover || b.IMAGE_RIGHT_HOVER;
            b.IMAGE_RIGHT_DISABLED = a.disabled || b.IMAGE_RIGHT_DISABLED
        }
    },
    setupLeftButtonConfig: function (a) {
        var b = this;
        if (a && !Sys.isEmpty(a)) {
            b.IMAGE_LEFT_UP = a.up || b.IMAGE_LEFT_UP;
            b.IMAGE_LEFT_DOWN = a.down || b.IMAGE_LEFT_DOWN;
            b.IMAGE_LEFT_HOVER = a.hover || b.IMAGE_LEFT_HOVER;
            b.IMAGE_LEFT_DISABLED = a.disabled || b.IMAGE_LEFT_DISABLED
        }
    },
    setupHandleConfig: function (a) {
        var b = this;
        b.HANDLE_POSITION_OFFSET = a.positionOffset || b.HANDLE_POSITION_OFFSET;
        b.HANDLE_DIMENSIONS = a.dimensions || b.HANDLE_DIMENSIONS;
        b.HANDLE_COLLISION_BOX = a.collisionBox || b.HANDLE_COLLISION_BOX
    },
    setupBarConfig: function (a) {
        var b = this;
        b.BAR_BACKGROUND = a.background || b.BAR_BACKGROUND;
        b.BAR_BACKGROUND_DISABLED = a.backgroundDisabled || b.BAR_BACKGROUND_DISABLED;
        b.BAR_FILL = a.fill || b.BAR_FILL;
        b.BAR_FILL_DISABLED = a.fillDisabled || b.BAR_FILL_DISABLED;
        b.BAR_DIMENSIONS = a.dimensions || b.BAR_DIMENSIONS;
        b.BAR_POSITION_OFFSET = a.positionOffset || b.BAR_POSITION_OFFSET
    },
    setupLayering: function (a) {
        var b = a.depth;
        this.layeringConfig = {
            background: b,
            barBackground: b + 1,
            value: b + 2,
            barFrame: b + 3,
            barFill: b + 4,
            buttons: b + 4,
            label: b + 4
        }
    },
    setupFontStyle: function (a) {
        var b = this;
        b.FILLSTYLE_LABEL = a.fillstyleLabel || b.FILLSTYLE_LABEL;
        b.FILLSTYLE_VALUE = a.fillstyleValue || b.FILLSTYLE_VALUE;
        b.FONT_LABEL = a.fontLabel || b.FONT_LABEL;
        b.FONT_VALUE = a.fontValue || b.FONT_VALUE
    },
    initAnimations: function () {
        var a = this;
        a.initAnimationLists();
        a.initCanvasButtons(a.HANDLE_POSITION_OFFSET, a.HANDLE_DIMENSIONS, a.HANDLE_COLLISION_BOX);
        a.initBar();
        a.initValueItem();
        a.initLabelItem()
    },
    initAnimationLists: function () {
        var e = ["VALUE", "BAR", "LABEL"], b = {}, c, a, d;
        for (c = -1, a = e.length; ++c < a;) {
            d = new Animation.List({});
            b[e[c]] = d;
            Game.stage.view.addToRenderLoop(d)
        }
        this.animationLists = b
    },
    clearAnimationLists: function () {
        Sys.iterate(this.animationLists, function (a, b) {
            Game.stage.view.removeFromRenderLoop(b)
        })
    },
    initCanvasButtons: function (a, c, b) {
        var d = this;
        d.buttons = {
            LEFT: d.createCanvasButton(a.LEFT, c.LEFT, b.LEFT, "LEFT"),
            RIGHT: d.createCanvasButton(a.RIGHT, c.RIGHT, b.RIGHT, "RIGHT")
        }
    },
    initBar: function () {
        var a = this;
        a.bar = new Interface.utils.CanvasStepSlider({
            images: {
                background: {
                    enabled: a.BAR_BACKGROUND,
                    disabled: a.BAR_BACKGROUND_DISABLED
                }, fill: {enabled: a.BAR_FILL, disabled: a.BAR_FILL_DISABLED}
            },
            dimensions: {
                background: {
                    x: a.basePosition.x + a.BAR_POSITION_OFFSET.background.x,
                    y: a.basePosition.y + a.BAR_POSITION_OFFSET.background.y,
                    width: a.BAR_DIMENSIONS.background.width,
                    height: a.BAR_DIMENSIONS.background.height
                },
                fill: {
                    x: a.basePosition.x + a.BAR_POSITION_OFFSET.fill.x,
                    y: a.basePosition.y + a.BAR_POSITION_OFFSET.fill.y,
                    width: a.BAR_DIMENSIONS.fill.width,
                    height: a.BAR_DIMENSIONS.fill.height
                }
            },
            depth: {background: a.layeringConfig.barBackground, fill: a.layeringConfig.barFill},
            sliderInputOffsets: a.SLIDER_BAR_INPUT_OFFSET,
            values: a.valueArray,
            callback: a.onBarChanged.bind(a)
        });
        a.animationLists.BAR.add(a.bar.getContainer());
        a.updateBar()
    },
    initValueItem: function () {
        var a = this,
            b = Animation.utils.text.createText(0, a.FONT_VALUE, 0, [{fillStyle: a.FILLSTYLE_VALUE, drawType: "fill"}]);
        a.valueItem = new Animation.Item({
            top: 0,
            left: 0,
            width: 0,
            height: 0,
            depth: a.layeringConfig.value,
            image: b,
            customProps: {ctx: b.getContext("2d")}
        });
        a.animationLists.VALUE.add(a.valueItem);
        a.updateValueItem(a.valueArray[a.currentIndex])
    },
    initLabelItem: function () {
        var a = this, f = Animation.utils.text.createText(a.label, a.FONT_LABEL, 0, [{
                fillStyle: a.FILLSTYLE_LABEL,
                drawType: "fill"
            }]), e = a.HANDLE_DIMENSIONS.RIGHT.width + a.HANDLE_POSITION_OFFSET.RIGHT.x, d = a.POSITION_OFFSET_LABEL,
            c = ((a.basePosition.x + (e / 2)) - (f.width / 2)) + d.x, b = a.basePosition.y + d.y;
        a.labelItem = new Animation.Item({
            top: b,
            left: c,
            width: f.width,
            height: f.height,
            depth: a.layeringConfig.label,
            image: f
        });
        a.animationLists.LABEL.add(a.labelItem)
    },
    createCanvasButton: function (a, d, b, c) {
        var e = this;
        return new Interface.utils.CanvasButton({
            buttonLayoutParameters: {
                x: e.basePosition.x + a.x,
                y: e.basePosition.y + a.y,
                width: d.width,
                height: d.height,
                depth: e.layeringConfig.buttons
            },
            dimensions: {
                x: e.basePosition.x + a.x + b.xOffset,
                y: e.basePosition.y + a.y + b.yOffset,
                width: b.width,
                height: b.height
            },
            buttonImages: {
                up: e["IMAGE_" + c + "_UP"],
                down: e["IMAGE_" + c + "_DOWN"],
                hover: e["IMAGE_" + c + "_HOVER"],
                disabled: e["IMAGE_" + c + "_DISABLED"]
            },
            clickCallback: e.click.bind(e, c)
        })
    },
    click: function (a) {
        var b = this, c = b.getValue(a);
        if (this.enabled) {
            b.updateValueItem(c);
            b.callback(c)
        }
    },
    getValue: function (a) {
        var b = this;
        b.currentIndex = (a === "LEFT") ? b.currentIndex -= 1 : b.currentIndex += 1;
        if (b.currentIndex < 0) {
            b.currentIndex = 0
        } else {
            if (b.currentIndex > b.valueArray.length - 1) {
                b.currentIndex = b.valueArray.length - 1
            }
        }
        return b.valueArray[b.currentIndex]
    },
    updateValueItem: function (e) {
        var b = this, h = b.valueItem.prop, a = h.customProps.ctx, d = b.valueNameArray[b.valueArray.indexOf(e)],
            c = Animation.utils.text.measureText(d, b.FONT_VALUE, 0, a),
            g = b.HANDLE_DIMENSIONS.RIGHT.width + b.HANDLE_POSITION_OFFSET.RIGHT.x, f = b.POSITION_OFFSET_VALUE;
        h.image.width = c.width;
        h.image.height = c.height;
        h.width = c.width;
        h.height = c.height;
        h.top = b.basePosition.y + f.y;
        h.left = ((b.basePosition.x + (g / 2)) - (h.image.width / 2)) + f.x;
        a.clearRect(0, 0, h.width, h.height);
        Animation.utils.text.performOperations(d, b.FONT_VALUE, 0, c.height / 2, [{
            fillStyle: b.FILLSTYLE_VALUE,
            drawType: "fill"
        }], a)
    },
    updateBar: function () {
        var a = this;
        a.bar.setValue(a.valueArray[a.currentIndex], true)
    },
    onBarChanged: function (a) {
        this.update(a);
        this.callback(a)
    },
    enable: function (b) {
        var a = this;
        a.enabled = true;
        if (Sys.isDefined(this.animationLists) && Sys.isDefined(a.buttons)) {
            a.enableLeftButton(b);
            a.enableRightButton(b);
            a.bar.enable(b)
        }
    },
    disable: function (b) {
        var a = this;
        if (Sys.isDefined(a.animationLists) && Sys.isDefined(a.buttons)) {
            a.bar.disable(b);
            a.disableLeftButton(b);
            a.disableRightButton(b);
            a.enabled = false
        }
    },
    enableLeftButton: function (b) {
        var a = this;
        if (Sys.isDefined(a.buttons)) {
            a.buttons.LEFT.enable(b)
        }
    },
    disableLeftButton: function (b) {
        var a = this;
        if (Sys.isDefined(a.buttons)) {
            a.buttons.LEFT.disable(b)
        }
    },
    enableRightButton: function (b) {
        var a = this;
        if (Sys.isDefined(a.buttons)) {
            a.buttons.RIGHT.enable(b)
        }
    },
    disableRightButton: function (b) {
        var a = this;
        if (Sys.isDefined(a.buttons)) {
            a.buttons.RIGHT.disable(b)
        }
    },
    hide: function (b) {
        var a = this;
        Sys.iterate(a.animationLists, function (c, d) {
            d.stop()
        });
        a.buttons.LEFT.hide(b);
        a.buttons.RIGHT.hide(b)
    },
    show: function (b) {
        var a = this;
        Sys.iterate(a.animationLists, function (c, d) {
            d.play()
        });
        a.buttons.LEFT.show(b);
        a.buttons.RIGHT.show(b)
    },
    update: function (e) {
        var c = this, b = this.valueArray, a = b.indexOf(e), d = "CanvasValueSelector";
        if (a === 0) {
            c.disableLeftButton(d);
            c.enableRightButton(d)
        } else {
            if (a === b.length - 1) {
                c.disableRightButton(d);
                c.enableLeftButton(d)
            } else {
                c.enableLeftButton(d);
                c.enableRightButton(d)
            }
        }
        if (Sys.isDefined(b[a])) {
            c.currentIndex = a;
            c.updateValueItem(b[a]);
            c.updateBar()
        }
    }
};
Interface.utils.CanvasValueSelector = Sys.extend(Interface.utils.UserInputBase, Interface.utils.CanvasValueSelector, "Interface.utils.CanvasValueSelector");
Sys.ns("Interface");
Interface.AbstractButton = {
    STATES: ["UP", "DOWN", "HOVER", "CLICK"],
    SOUND_UP: "buttonUp",
    SOUND_DOWN: "buttonDown",
    SOUND_CLICK: "buttonClick",
    SOUND_HOVER: "buttonHover",
    ID: "button",
    DEFAULT_USER_INPUT_EVENTS: {
        started: "notify:userInputManager.userInputStarted",
        ended: "notify:userInputManager.userInputEnded",
        move: "notify:userInputManager.userInputMove",
        hover: "notify:userInputManager.userInputHover"
    },
    constructor: function (a) {
        Interface.AbstractButton.superclass.constructor.apply(this, arguments);
        this.init(a)
    },
    enable: function (a) {
        this.removeProperty("disabled", a);
        this.tryStartListeningToUserInput()
    },
    disable: function (a) {
        this.addProperty("disabled", a);
        this.stopListeningToUserInput()
    },
    isEnabled: function () {
        return !this.hasProperty("disabled")
    },
    show: function (a) {
        this.removeProperty("hidden", a);
        this.tryStartListeningToUserInput()
    },
    hide: function (a) {
        this.addProperty("hidden", a);
        this.stopListeningToUserInput()
    },
    isHidden: function () {
        return !this.hasProperty("hidden")
    },
    init: function (a) {
        var b = this;
        b.dimensions = a.dimensions;
        b.properties = {};
        if (Sys.isDefined(a.id)) {
            b.ID = a.id
        }
        if (Sys.isDefined(a.upCallback)) {
            b.upCallback = a.upCallback
        } else {
            b.upCallback = function () {
            }
        }
        if (Sys.isDefined(a.downCallback)) {
            b.downCallback = a.downCallback
        } else {
            b.downCallback = function () {
            }
        }
        if (Sys.isDefined(a.overCallback)) {
            b.overCallback = a.overCallback
        } else {
            b.overCallback = function () {
            }
        }
        if (Sys.isDefined(a.clickCallback)) {
            b.clickCallback = a.clickCallback
        } else {
            b.clickCallback = function () {
            }
        }
        if (Sys.isDefined(a.hoverCallback)) {
            b.hoverCallback = a.hoverCallback
        } else {
            b.hoverCallback = function () {
            }
        }
        b.userInputEvents = b.DEFAULT_USER_INPUT_EVENTS;
        if (Sys.isDefined(a.exclusiveUserInput)) {
            b.userInputEvents = {
                started: "notify:userInputManager." + a.exclusiveUserInput + "ExclusiveStart",
                ended: "notify:userInputManager." + a.exclusiveUserInput + "ExclusiveEnd",
                move: "notify:userInputManager." + a.exclusiveUserInput + "ExclusiveMove",
                hover: "notify:userInputManager." + a.exclusiveUserInput + "ExclusiveKeyUp"
            }
        }
        if (Sys.isDefined(a.userInputEvents)) {
            Sys.iterate(a.userInputEvents, function (c, d) {
                b.userInputEvents[c] = d
            })
        }
        b.startListeningToUserInput();
        b.state = "up";
        if (Sys.isDefined(a.sounds)) {
            b.setupSounds(a.sounds)
        }
        if (Sys.isDefined(Services.trigger)) {
            b.registerTriggers()
        }
    },
    setupSounds: function (b) {
        var e = this, c = e.STATES, d, a, f;
        for (d = -1, a = c.length; ++d < a;) {
            f = c[d].toLowerCase();
            if (Sys.isDefined(b[f])) {
                e["SOUND_" + e[c[d]]] = b.state
            }
        }
    },
    registerTriggers: function () {
        var a = this.ID;
        Services.trigger.registerTrigger("notify:" + a + ".up", this, "When the button returns to the up state.");
        Services.trigger.registerTrigger("notify:" + a + ".hover", this, "When the button is hovered.");
        Services.trigger.registerTrigger("notify:" + a + ".over", this, "When the button hovered but wasn't the initial input target.");
        Services.trigger.registerTrigger("notify:" + a + ".down", this, "When the button is pressed down.");
        Services.trigger.registerTrigger("notify:" + a + ".click", this, "When the button is clicked.")
    },
    up: function () {
        var a = this;
        if (a.state !== "up") {
            a.state = "up";
            a.upCallback();
            a.fireEvent("request:audioPlayer.play", {name: a.SOUND_UP});
            a.fireEvent("notify:" + a.ID + ".up")
        }
    },
    click: function () {
        var a = this;
        a.clickCallback();
        a.fireEvent("request:audioPlayer.play", {name: a.SOUND_CLICK});
        a.fireEvent("notify:" + a.ID + ".click")
    },
    over: function () {
        var a = this;
        if (a.state !== "over") {
            a.overCallback();
            a.state = "over";
            a.fireEvent("notify:" + a.ID + ".over")
        }
    },
    down: function () {
        var a = this;
        if (a.state !== "down") {
            a.downCallback();
            a.state = "down";
            a.fireEvent("request:audioPlayer.play", {name: a.SOUND_DOWN});
            a.fireEvent("notify:" + a.ID + ".down")
        }
    },
    hover: function (a) {
        var b = this;
        if (b.state !== "hover") {
            b.hoverCallback();
            b.state = "hover";
            if (!a) {
                b.fireEvent("request:audioPlayer.play", {name: b.SOUND_HOVER})
            }
            b.fireEvent("notify:" + b.ID + ".hover", a)
        }
    },
    userInputStart: function (c) {
        var b = this, a = b.isInputTarget(c);
        if (a) {
            b.down()
        }
        b.active = a;
        b.wasInitialInputTarget = a
    },
    userInputHover: function (c) {
        var b = this, a = b.isInputTarget(c);
        if (a) {
            b.hover()
        } else {
            if (b.state !== "up") {
                b.up()
            }
        }
    },
    userInputEnd: function (b) {
        var a = this;
        if (a.isInputTarget(b) && a.wasInitialInputTarget) {
            a.wasInitialInputTarget = false;
            a.hover(true);
            a.click()
        } else {
            if (a.active) {
                a.up()
            }
        }
    },
    userInputMove: function (c) {
        var b = this, a = b.isInputTarget(c);
        if (a) {
            if (b.wasInitialInputTarget) {
                b.down()
            } else {
                b.over()
            }
            b.active = true
        } else {
            if (b.wasInitialInputTarget || b.active) {
                b.up()
            }
        }
    },
    tryStartListeningToUserInput: function () {
        if (!this.hasProperty("disabled") && !this.hasProperty("hidden")) {
            this.startListeningToUserInput()
        }
    },
    startListeningToUserInput: function () {
        var a = this;
        if (Sys.isDefined(a.userInputEvents.started)) {
            a.addListener(a.userInputEvents.started, a.userInputStart)
        }
        if (Sys.isDefined(a.userInputEvents.started)) {
            a.addListener(a.userInputEvents.ended, a.userInputEnd)
        }
        if (Sys.isDefined(a.userInputEvents.move)) {
            a.addListener(a.userInputEvents.move, a.userInputMove)
        }
        if (Sys.isDefined(a.userInputEvents.hover)) {
            a.addListener(a.userInputEvents.hover, a.userInputHover)
        }
    },
    stopListeningToUserInput: function () {
        var a = this;
        if (Sys.isDefined(a.userInputEvents.started)) {
            a.removeListener(a.userInputEvents.started)
        }
        if (Sys.isDefined(a.userInputEvents.ended)) {
            a.removeListener(a.userInputEvents.ended)
        }
        if (Sys.isDefined(a.userInputEvents.move)) {
            a.removeListener(a.userInputEvents.move)
        }
        if (Sys.isDefined(a.userInputEvents.hover)) {
            a.removeListener(a.userInputEvents.hover)
        }
    },
    isInputTarget: function (c) {
        var a = this, b = Sys.UserInputUtils.getCoordinatesRelativeToElement(c, Game.stage.getGameContainer());
        return a.isDOMElement(a.dimensions) ? Sys.UserInputUtils.isCoordinateTarget(a.dimensions, c) : Sys.UserInputUtils.isUserInputInSegment(b, a.dimensions)
    },
    isDOMElement: function (a) {
        return a.nodeType === 1
    },
    hasProperty: function (b) {
        var a = this.properties[b];
        return Sys.isDefined(a) && a.length > 0
    },
    addProperty: function (d, c) {
        var b = this.properties, a = false;
        if (!Sys.isDefined(b[d])) {
            b[d] = [c];
            a = true
        } else {
            if (!b[d].contains(c)) {
                a = b[d].length === 0;
                b[d].push(c)
            }
        }
        if (a) {
            this.update()
        }
    },
    removeProperty: function (c, b) {
        var a = this.properties[c];
        if (Sys.isDefined(a) && a.contains(b)) {
            a.splice(a.indexOf(b), 1);
            if (a.length === 0) {
                this.update()
            }
        }
    },
    update: function () {
    }
};
Interface.AbstractButton = Sys.extend(Sys.Observable, Interface.AbstractButton, "Interface.AbstractButton");
Sys.ns("Interface.utils");
Interface.utils.AbstractUserInputBase = {
    constructor: function (a) {
        Interface.utils.AbstractUserInputBase.superclass.constructor.apply(this, arguments);
        this.init(a)
    }, enable: function () {
        this.enabled = true;
        this.startListeningToUserInput()
    }, disable: function () {
        this.enabled = false;
        this.stopListeningToUserInput()
    }, isEnabled: function () {
        return this.enabled
    }, init: function (a) {
        var b = this;
        b.id = a.id;
        b.listensToInput = a.listensToInput !== false;
        if (a.enabled) {
            b.enable()
        } else {
            b.disable()
        }
    }, onUserInputStart: function () {
    }, onUserInputEnd: function () {
    }, startListeningToUserInput: function () {
        if (!this.listensToInput) {
            return
        }
        this.on({
            "notify:userInputManager.userInputStarted": this.onUserInputStart,
            "notify:userInputManager.userInputEnded": this.onUserInputEnd
        })
    }, stopListeningToUserInput: function () {
        if (!this.listensToInput) {
            return
        }
        this.removeListener("notify:userInputManager.userInputStarted");
        this.removeListener("notify:userInputManager.userInputEnded")
    }
};
Interface.utils.AbstractUserInputBase = Sys.extend(Sys.Observable, Interface.utils.AbstractUserInputBase, "Interface.utils.AbstractUserInputBase");
Sys.ns("Interface.utils");
Interface.utils.AbstractSlider = {
    constructor: function (a) {
        var b = this;
        Interface.utils.AbstractControlList.superclass.constructor.apply(b, arguments);
        b.callback = a.callback;
        b.wasInitialInputTarget = false;
        b.properties = {};
        b.setUpContent(a)
    }, setUpContent: function () {
    }, enable: function (a) {
        this.removeProperty("disabled", a);
        this.tryStartListeningToUserInput()
    }, disable: function (a) {
        this.addProperty("disabled", a);
        this.stopListeningToUserInput()
    }, tryStartListeningToUserInput: function () {
        if (!this.hasProperty("disabled") && !this.hasProperty("hidden")) {
            this.startListeningToUserInput()
        }
    }, startListeningToUserInput: function () {
        var a = this;
        a.on({
            "notify:userInputManager.userInputStarted": a.userInputStart,
            "notify:userInputManager.userInputEnded": a.userInputEnd,
            "notify:userInputManager.userInputMove": a.userInputMove
        })
    }, stopListeningToUserInput: function () {
        var a = this;
        a.removeListener("notify:userInputManager.userInputStarted");
        a.removeListener("notify:userInputManager.userInputEnded");
        a.removeListener("notify:userInputManager.userInputMove")
    }, hasProperty: function (b) {
        var a = this.properties[b];
        return Sys.isDefined(a) && a.length > 0
    }, addProperty: function (d, c) {
        var b = this.properties, a = false;
        if (!Sys.isDefined(b[d])) {
            b[d] = [c];
            a = true
        } else {
            if (!b[d].contains(c)) {
                a = b[d].length === 0;
                b[d].push(c)
            }
        }
        if (a) {
            this.update()
        }
    }, removeProperty: function (c, b) {
        var a = this.properties[c];
        if (Sys.isDefined(a) && a.contains(b)) {
            a.splice(a.indexOf(b), 1);
            if (a.length === 0) {
                this.update()
            }
        }
    }, userInputMove: function (b) {
        var a = this;
        if (a.wasInitialInputTarget) {
            a.movedTo(b)
        }
    }, userInputEnd: function (b) {
        var a = this;
        if (a.wasInitialInputTarget && a.isInputTarget(b)) {
            a.clickedAt(b)
        }
    }, userInputStart: function (b) {
        var a = this;
        a.wasInitialInputTarget = a.isInputTarget(b)
    }, update: function () {
    }, setValue: function () {
    }, clickedAt: function () {
    }, movedTo: function () {
    }, isInputTarget: function () {
    }
};
Interface.utils.AbstractSlider = Sys.extend(Sys.Observable, Interface.utils.AbstractSlider, "Interface.utils.AbstractSlider");
Sys.ns("Interface.utils");
Interface.utils.AbstractOptionScroller = {
    constructor: function () {
        Interface.utils.AbstractOptionScroller.superclass.constructor.apply(this, arguments)
    }, onUserInputStart: function (a) {
        this.initialInputTarget = this.getInputTarget(a)
    }, onUserInputEnd: function (d) {
        var b = this, a = b.getInputTarget(d), c = b.initialInputTarget;
        if (Sys.isDefined(c) && a === c) {
            b.scroll(a)
        } else {
            if (Sys.isObj(a) && Sys.isObj(c) && a.value === c.value) {
                b.callback(a)
            } else {
                b.initialInputTarget = undefined
            }
        }
    }, init: function (a) {
        Interface.utils.AbstractOptionScroller.superclass.init.apply(this, arguments);
        this.callback = a.callback
    }, getInputTarget: function (a) {
    }, scroll: function (a) {
    }
};
Interface.utils.AbstractOptionScroller = Sys.extend(Interface.utils.AbstractUserInputBase, Interface.utils.AbstractOptionScroller, "Interface.utils.AbstractOptionScroller");
Sys.ns("Interface.utils");
Interface.utils.AbstractInputField = {
    constructor: function () {
        Interface.utils.AbstractInputField.superclass.constructor.apply(this, arguments)
    }, init: function (a) {
        Interface.utils.AbstractInputField.superclass.init.apply(this, arguments);
        this.callback = a.callback
    }, onKeyUp: function (a) {
        var b = this, c;
        if (b.enabled && b.active) {
            c = b.getValue(a);
            b.setValue(c);
            b.callback(c)
        }
    }, getValue: function (a) {
    }, setValue: function (a) {
    }
};
Interface.utils.AbstractInputField = Sys.extend(Interface.utils.AbstractUserInputBase, Interface.utils.AbstractInputField, "Interface.utils.AbstractInputField");
Sys.ns("Interface.utils");
Interface.utils.AbstractControlList = {
    constructor: function (a) {
        var b = this;
        Interface.utils.AbstractControlList.superclass.constructor.apply(b, arguments);
        b.callback = a.callback;
        b.model = new Core.Model({name: a.id + "ControlListModel"});
        b.controls = {};
        b.setUpContent(a)
    }, setUpContent: function (a) {
    }, getContainer: function () {
    }, getControl: function (a) {
        return this.controls[a]
    }
};
Interface.utils.AbstractControlList = Sys.extend(Sys.Observable, Interface.utils.AbstractControlList, "Interface.utils.AbstractControlList");
Sys.ns("Interface.utils");
Interface.utils.AbstractCheckBoxWithInput = {
    constructor: function (a) {
        var b = this;
        Interface.utils.AbstractCheckBoxWithInput.superclass.constructor.apply(b, arguments);
        b.callback = a.callback;
        b.model = new Core.Model({name: a.id + "CheckBoxWithInputModel"});
        b.setUpContent(a)
    }, setUpContent: function () {
    }, getContainer: function () {
    }
};
Interface.utils.AbstractCheckBoxWithInput = Sys.extend(Sys.Observable, Interface.utils.AbstractCheckBoxWithInput, "Interface.utils.AbstractCheckBoxWithInput");
Sys.ns("Interface.utils");
Interface.utils.CanvasButton = {
    constructor: function (a) {
        Interface.utils.CanvasButton.superclass.constructor.apply(this, arguments);
        this.setUpAnimations(a)
    }, destroy: function () {
        this.disable("CanvasButton");
        Game.stage.view.removeFromRenderLoop(this.animationList)
    }, down: function () {
        Interface.utils.CanvasButton.superclass.down.apply(this, arguments);
        this.setActiveAnimation(this.downAnimation)
    }, up: function () {
        Interface.utils.CanvasButton.superclass.up.apply(this, arguments);
        this.setActiveAnimation(this.upAnimation)
    }, hover: function () {
        Interface.utils.CanvasButton.superclass.hover.apply(this, arguments);
        this.setActiveAnimation(this.hoverAnimation)
    }, setActiveAnimation: function (a) {
        this.activeAnimation = a;
        this.update()
    }, update: function () {
        var a = this;
        a.animationList.stop();
        if (!a.hasProperty("hidden")) {
            if (a.hasProperty("disabled")) {
                a.textLabelAnimation.prop.ownOpacity = 0.32;
                a.animationList.play(a.disabledAnimation)
            } else {
                a.textLabelAnimation.prop.ownOpacity = 1;
                a.animationList.play(a.activeAnimation)
            }
            a.animationList.play(a.textLabelAnimation)
        }
    }, isInputTarget: function (c) {
        var a = this, b = Sys.UserInputUtils.getCoordinatesRelativeToElement(c, Game.stage.getGameContainer());
        return Sys.UserInputUtils.isUserInputInSegment(b, a.dimensions) && Sys.UserInputUtils.isCoordinateTarget(a.canvasElement, c)
    }, init: function (a) {
        Interface.utils.CanvasButton.superclass.init.apply(this, arguments);
        this.canvasElement = (a.canvasElement) ? a.canvasElement : document.getElementById("canvasAnimationManager")
    }, setUpAnimations: function (b) {
        var d = this, e = new Animation.List({}), g = b.buttonImages, f, c, a = b.buttonLabel;
        ["up", "down", "hover", "disabled"].forEach(function (h) {
            f = d.verifyImage(g[h]);
            c = new Animation.Item(d.createBaseConfig(f, b.buttonLayoutParameters));
            d[h + "Animation"] = c;
            e.add(c)
        });
        if (Sys.isDefined(a)) {
            d.textLabelAnimation = d.createTextLabel(a)
        } else {
            d.textLabelAnimation = new Animation.Item({})
        }
        e.add(d.textLabelAnimation);
        e.stop();
        Game.stage.view.addToRenderLoop(e);
        d.animationList = e;
        d.setActiveAnimation(d.upAnimation)
    }, verifyImage: function (a) {
        if (a.indexOf("#") === 0 || a.indexOf("rgba") === 0) {
            return this.createButtonImage(a)
        }
        return a
    }, createTextLabel: function (i) {
        var g = this, f = i.text, c = i.offsetY || 0, e = i.offsetX || 0, j = 0, k = i.width, d = i.height,
            b = Animation.utils.getInMemoryCanvas(k, d),
            a = Services.languageManager.hasText(f) ? Services.languageManager.getText(f) : f;
        if (i.alignment === "center") {
            b.ctx.textAlign = i.alignment;
            j = k / 2
        }
        Animation.utils.text.wrapCanvasText(a, i.font, j, 0, k, i.lineHeight, [{
            fillStyle: i.color,
            drawType: "fill"
        }], b.ctx, true, i.breakOn);
        return new Animation.Item({
            width: k,
            height: d,
            left: g.dimensions.x + Math.round(Math.abs((k - g.dimensions.width) / 2)) + e,
            top: g.dimensions.y + Math.round(Math.abs((d - g.dimensions.height) / 2)) + c,
            depth: i.depth,
            image: b.canvas
        })
    }, createBaseConfig: function (c, b) {
        var a = Sys.isDefined(b) ? b : this.dimensions;
        return {width: a.width, height: a.height, left: a.x, top: a.y, depth: a.depth, image: c}
    }, createButtonImage: function (a) {
        var d = this, b = document.createElement("canvas"), c;
        b.width = d.dimensions.width;
        b.height = d.dimensions.height;
        c = b.getContext("2d");
        c.fillStyle = a;
        c.fillRect(0, 0, d.dimensions.width, d.dimensions.height);
        return b
    }
};
Interface.utils.CanvasButton = Sys.extend(Interface.AbstractButton, Interface.utils.CanvasButton, "Interface.utils.CanvasButton");
Sys.ns("Interface.utils");
Interface.utils.CanvasStepSlider = {
    DEFAULT_CANVAS_ELEMENT_ID: "canvasAnimationManager", constructor: function (a) {
        var b = this;
        b.canvasElement = Sys.isDefined(a.canvasElement) ? a.canvasElement : document.getElementById(b.DEFAULT_CANVAS_ELEMENT_ID);
        b.dimensions = a.dimensions;
        b.depth = a.depth;
        b.images = a.images;
        b.valueArray = a.values;
        b.sliderInputOffsets = a.sliderInputOffsets || {
            start: {width: 0, height: 0},
            move: {width: 0, height: 0},
            end: {width: 0, height: 0}
        };
        if (Sys.isDefined(a.collisionDimensions)) {
            b.collisionDimensions = a.collisionDimensions
        } else {
            b.collisionDimensions = a.dimensions.background
        }
        b.stepWidth = b.dimensions.fill.width / b.valueArray.length;
        b.currentIndex = 0;
        Interface.utils.CanvasStepSlider.superclass.constructor.apply(b, arguments)
    }, setUpAnimations: function () {
        var a = this;
        a.animationList = new Animation.List({});
        a.backgroundAnimation = a.createItem(a.images.background.enabled, a.dimensions.background, a.depth.background);
        a.fillAnimation = a.createItem(a.images.fill.enabled, a.dimensions.fill, a.depth.fill);
        a.animationList.add(a.backgroundAnimation);
        a.animationList.add(a.fillAnimation);
        a.animationList.play();
        a.update()
    }, getContainer: function () {
        return this.animationList
    }, createItem: function (b, a, c) {
        return new Animation.CanvasAnimationItem({
            width: a.width,
            height: a.height,
            top: a.y,
            left: a.x,
            depth: c,
            image: b
        })
    }, setUpContent: function (a) {
        this.setUpAnimations(a)
    }, localCoordinates: function (a) {
        return Sys.UserInputUtils.getCoordinatesRelativeToElement(a, Game.stage.getGameContainer())
    }, relativeCoordinates: function (c) {
        var a = this, b = a.localCoordinates(c);
        return {x: b.x - a.collisionDimensions.x, y: b.y - a.collisionDimensions.y}
    }, isInputTarget: function (f, e) {
        var b = this, d = b.localCoordinates(f), a = e || {width: 0, height: 0}, c = {
            x: b.collisionDimensions.x - a.width / 2,
            y: b.collisionDimensions.y - a.height / 2,
            width: b.collisionDimensions.width + a.width,
            height: b.collisionDimensions.height + a.height
        };
        return Sys.UserInputUtils.isUserInputInSegment(d, c) && Sys.UserInputUtils.isCoordinateTarget(b.canvasElement, f)
    }, userInputStart: function (b) {
        var a = this;
        a.wasInitialInputTarget = a.isInputTarget(b, a.sliderInputOffsets.start);
        a.on({"notify:userInputManager.userInputMove": a.userInputMove})
    }, userInputMove: function (b) {
        var a = this;
        if (a.wasInitialInputTarget) {
            if (a.isInputTarget(b, a.sliderInputOffsets.move)) {
                a.movedTo(b)
            } else {
                a.removeListener("notify:userInputManager.userInputMove")
            }
        }
    }, userInputEnd: function (b) {
        var a = this;
        if (a.wasInitialInputTarget && a.isInputTarget(b, a.sliderInputOffsets.end)) {
            a.clickedAt(b)
        }
    }, update: function () {
        var a = this;
        a.fillAnimation.prop.width = a.stepWidth + (a.stepWidth * a.currentIndex);
        if (!a.hasProperty("hidden")) {
            if (a.hasProperty("disabled")) {
                a.backgroundAnimation.prop.image = a.images.background.disabled;
                a.fillAnimation.prop.image = a.images.fill.disabled
            } else {
                a.backgroundAnimation.prop.image = a.images.background.enabled;
                a.fillAnimation.prop.image = a.images.fill.enabled
            }
        }
    }, setValue: function (d, a) {
        var c = this, b = c.valueArray.indexOf(d);
        if (b >= 0 && Sys.isDefined(c.valueArray[b])) {
            c.currentIndex = b;
            c.update();
            if (!a) {
                c.sendValueUpdate()
            }
        }
    }, getValue: function () {
        var a = this;
        return a.valueArray[a.currentIndex]
    }, sendValueUpdate: function () {
        var a = this, b = a.getValue();
        a.callback(b)
    }, updateFromCoordinates: function (d) {
        var c = this, a = Math.floor(d.x / c.stepWidth), b = c.valueArray.length - 1;
        if (a < 0) {
            a = 0
        } else {
            if (a > b) {
                a = b
            }
        }
        if (a !== c.currentIndex) {
            c.currentIndex = a;
            c.update();
            c.sendValueUpdate()
        }
    }, clickedAt: function (c) {
        var a = this, b = a.relativeCoordinates(c);
        a.updateFromCoordinates(b)
    }, movedTo: function (c) {
        var a = this, b = a.relativeCoordinates(c);
        a.updateFromCoordinates(b)
    }
};
Interface.utils.CanvasStepSlider = Sys.extend(Interface.utils.AbstractSlider, Interface.utils.CanvasStepSlider, "Interface.utils.CanvasStepSlider");
Sys.ns("Interface.utils");
Interface.utils.DOMControlList = {
    constructor: function (a) {
        Interface.utils.DOMControlList.superclass.constructor.apply(this, arguments);
        this.callback = a.callback
    }, setUpContent: function (c) {
        var f = this, d, b = c.controls, a, g, e;
        f.container = new Sys.Element({id: c.id, tag: "ul", cls: "", renderTo: "gameWrapper"});
        for (d = 0; d < b.length; d++) {
            a = b[d];
            e = f.container.add(new Sys.Element({id: c.id + "_" + a.id, tag: "li"}));
            if (!Sys.isDefined(f.controls[a.id])) {
                f.controls[a.id] = []
            }
            if (a.type === "checkbox") {
                if (Sys.isDefined(a.withInput)) {
                    g = f.setupCheckBoxWithInput(a.id, a.label, a.withInput);
                    f.controls[a.id].push(g);
                    e.add(g.getContainer())
                } else {
                    g = f.setupCheckBox(a.id, a.label);
                    f.controls[a.id].push(g);
                    e.add(g.getContainer())
                }
                f.model.storeData(a.id, false)
            }
        }
    }, setupCheckBoxWithInput: function (d, a, c) {
        var b = this;
        return new Interface.utils.DOMCheckBoxWithInput({
            id: d,
            label: b.getTranslatedText(a),
            inputConfig: c,
            callback: b.onControlChanged.bind(b)
        })
    }, onControlChanged: function (b, a) {
        this.model.storeData(b, a);
        this.callback(b, a)
    }, setupCheckBox: function (c, a) {
        var b = this;
        return new Interface.utils.DOMCheckBox({
            id: c,
            title: b.getTranslatedText(a),
            enabled: true,
            callback: b.onControlChanged.bind(b, c)
        })
    }, getContainer: function () {
        return this.container
    }, update: function (c, b) {
        var a = this.controls[c];
        this.model.storeData(c, b);
        if (Sys.isDefined(a)) {
            Sys.each(a, function (d) {
                d.setValue(b)
            })
        }
    }, hide: function (b) {
        var a = this.controls[b];
        if (Sys.isDefined(a)) {
            Sys.each(a, function (c) {
                c.getContainer().el.parentElement.style.display = "none"
            })
        }
    }, show: function (b) {
        var a = this.controls[b];
        if (Sys.isDefined(a)) {
            Sys.each(a, function (c) {
                c.getContainer().el.parentElement.style.display = ""
            })
        }
    }, disable: function (b) {
        var a = this.controls[b];
        if (Sys.isDefined(a)) {
            Sys.each(a, function (c) {
                c.disable()
            })
        }
    }, enable: function (b) {
        var a = this.controls[b];
        if (Sys.isDefined(a)) {
            Sys.each(a, function (c) {
                c.enable()
            })
        }
    }, getTranslatedText: function (a) {
        return Services.languageManager.hasText(a) ? Services.languageManager.getText(a) : a
    }
};
Interface.utils.DOMControlList = Sys.extend(Interface.utils.AbstractControlList, Interface.utils.DOMControlList, "Interface.utils.DOMControlList");
Sys.ns("Interface.utils");
Interface.utils.DOMCheckBoxWithInput = {
    DEFAULT_INPUT_TYPE: "money",
    DEFAULT_INPUT_FILTER: /[^\d]/g,
    DEFAULT_CLEAR_ON_FOCUS: false,
    DEFAULT_CHECKBOX_VALUE: false,
    DEFAULT_INPUT_VALUE: "",
    NOT_CHECKED_VALUE: false,
    NOT_DEFINED_INPUT_VALUE: "",
    constructor: function (a) {
        var b = this;
        b.checkBox = undefined;
        b.input = undefined;
        Interface.utils.DOMCheckBoxWithInput.superclass.constructor.apply(b, arguments);
        b.setupEvents()
    },
    setupEvents: function () {
        var a = this;
        a.on({
            "notify:userInputManager.userInputStarted": a.onUserInputStart,
            "notify:userInputManager.userInputEnded": a.onUserInputEnd
        })
    },
    setUpContent: function (a) {
        var b = this;
        b.id = a.id;
        b.checkBoxId = b.id + "CheckBox";
        b.inputId = b.id + "Input";
        b.container = new Sys.Element({id: b.id, tag: "div", cls: ""});
        b.checkBox = b.setUpCheckBox(a.label);
        b.input = b.setUpInput(a.inputConfig);
        b.container.add(b.checkBox.getContainer());
        b.container.add(b.input.getContainer())
    },
    getContainer: function () {
        return this.container
    },
    setValue: function (d) {
        var c = this, b, a;
        if (d === false) {
            b = false;
            a = ""
        } else {
            b = true;
            a = d
        }
        c.setCheckBoxValue(b);
        c.setInputValue(a)
    },
    getValue: function () {
        var c = this, b = c.model.readData(c.checkBoxId), a = c.model.readData(c.inputId), d;
        if (b && a !== c.NOT_DEFINED_INPUT_VALUE) {
            d = a
        } else {
            d = c.NOT_CHECKED_VALUE
        }
        return d
    },
    enable: function () {
        this.checkBox.enable();
        this.input.enable()
    },
    disable: function () {
        this.checkBox.disable();
        this.input.disable()
    },
    setUpCheckBox: function (a) {
        var b = this, c = b.checkBoxId;
        b.model.storeData(c, b.DEFAULT_CHECKBOX_VALUE);
        return new Interface.utils.DOMCheckBox({
            id: c,
            enabled: true,
            title: a,
            listensToInput: false,
            callback: b.onCheckBoxToggled.bind(b)
        })
    },
    setUpInput: function (a) {
        var c = this, d = c.inputId, b = Sys.isDefined(a.type) ? a.type : c.DEFAULT_INPUT_TYPE;
        c.model.storeData(d, c.DEFAULT_INPUT_VALUE);
        return new Interface.utils.DOMInputField({
            id: d,
            enabled: true,
            listensToInput: false,
            label: Sys.isDefined(a.label) ? a.label : "",
            callback: c.onInputFieldEdited.bind(c, b),
            clearOnFocus: Sys.isDefined(a.clearOnFocus) ? a.clearOnFocus : c.DEFAULT_CLEAR_ON_FOCUS,
            inputFilter: Sys.isDefined(a.inputFilter) ? a.inputFilter : c.DEFAULT_INPUT_FILTER,
            blurCallback: function () {
                if (c.model.readData(d).length <= 0) {
                    c.setCheckBoxValue(false)
                }
            }
        })
    },
    onCheckBoxToggled: function (b) {
        var a = this, c = a.checkBoxId;
        a.model.storeData(c, b);
        if (b) {
            a.input.setActive(true)
        }
        a.sendValueUpdate()
    },
    onInputFieldEdited: function (b, d) {
        var c = this, e = c.inputId, a;
        if (d === "") {
            a = c.NOT_DEFINED_INPUT_VALUE
        } else {
            if (b === "money") {
                a = Math.floor(Number(d) * 100);
                a = isNaN(a) ? c.NOT_DEFINED_INPUT_VALUE : a
            } else {
                a = d
            }
        }
        if (a !== c.NOT_DEFINED_INPUT_VALUE) {
            c.setCheckBoxValue(true)
        }
        c.model.storeData(e, a);
        c.sendValueUpdate();
        c.setCheckBoxValue(c.model.readData(e) > 0)
    },
    sendValueUpdate: function () {
        var a = this, b = a.getValue();
        a.callback(a.id, b)
    },
    setCheckBoxValue: function (b) {
        var a = this;
        a.checkBox.setValue(b);
        a.model.storeData(a.checkBoxId, b)
    },
    setInputValue: function (b) {
        var a = this;
        a.input.setValue(b);
        a.model.storeData(a.inputId, b)
    },
    onUserInputStart: function (a) {
        this.initialInputTarget = this.getSelectedElement(a)
    },
    onUserInputEnd: function (b) {
        var a = this, c = this.getSelectedElement(b);
        if (a.initialInputTarget === c) {
            if (c instanceof Interface.utils.ToggleSwitch) {
                c.toggle()
            } else {
                if (c instanceof Interface.utils.DOMInputField) {
                    c.setActive(true)
                }
            }
        }
        a.initialInputTarget = null
    },
    getSelectedElement: function (a) {
        var b = null;
        [this.checkBox, this.input].forEach(function (c) {
            if (Sys.UserInputUtils.isCoordinateTarget(c.getContainer().el, a) && c.enabled) {
                b = c;
                return
            }
        });
        return b
    }
};
Interface.utils.DOMCheckBoxWithInput = Sys.extend(Interface.utils.AbstractCheckBoxWithInput, Interface.utils.DOMCheckBoxWithInput, "Interface.utils.DOMControlList");
Sys.ns("Interface.utils");
Interface.utils.DOMCheckBox = {
    CSS: {
        base: "interface-checkBox_base",
        disabled: "disabled",
        label: "interface-checkBox_label",
        button_wrapper: "interface-checkBox_box",
        button_background: "interface-checkBox_background",
        button_handle: "interface-checkBox_handle",
        loadAnimation: ""
    }, constructor: function () {
        Interface.utils.DOMCheckBox.superclass.constructor.apply(this, arguments)
    }
};
Interface.utils.DOMCheckBox = Sys.extend(Interface.utils.ToggleSwitch, Interface.utils.DOMCheckBox, "Interface.utils.DOMCheckBox");
Sys.ns("Interface.utils");
Interface.utils.DOMInputField = {
    CSS: {
        base: "interface-inputField_base",
        label: "interface-inputField_label",
        input: "interface-inputField_input"
    }, constructor: function () {
        Interface.utils.DOMInputField.superclass.constructor.apply(this, arguments)
    }, onUserInputStart: function (a) {
        this.wasInitialInputTarget = Sys.UserInputUtils.isCoordinateTarget(this.container.el, a)
    }, onUserInputEnd: function (b) {
        var a = this.wasInitialInputTarget && Sys.UserInputUtils.isCoordinateTarget(this.container.el, b);
        this.setActive(a)
    }, enable: function () {
        Interface.utils.DOMInputField.superclass.enable.apply(this, arguments);
        this.container.removeCls("disabled");
        this.input.el.disabled = false
    }, disable: function () {
        Interface.utils.DOMInputField.superclass.enable.apply(this, arguments);
        this.container.addCls("disabled");
        this.input.el.disabled = true
    }, getContainer: function () {
        return this.container
    }, init: function (a) {
        this.setUpDOMStructure(a);
        Interface.utils.DOMInputField.superclass.init.apply(this, arguments);
        this.clearOnFocus = a.clearOnFocus
    }, setUpDOMStructure: function (b) {
        var c = this, a;
        if (Sys.isDefined(b.CSS)) {
            a = Sys.applyPropertiesIf(Sys.applyProperties({}, b.CSS), c.CSS)
        } else {
            a = c.CSS
        }
        c.container = new Sys.Element({id: b.id, tag: "div", cls: a.base});
        if (Sys.isDefined(b.label)) {
            c.label = c.container.add(new Sys.Element({
                id: b.id + "_label",
                tag: "span",
                cls: a.label,
                textContent: b.label
            }))
        }
        c.input = c.container.add(new Sys.Element({id: b.id + "_input", tag: "input", cls: a.input}));
        c.id = Sys.isDefined(b.id) ? b.id : "DOMInputField";
        c.input.el.onkeyup = c.onKeyUp.bind(c, b.inputFilter);
        c.input.el.onfocus = c.onFocusChanged.bind(c, true);
        c.input.el.onblur = c.onFocusChanged.bind(c, false);
        if (Sys.isDefined(b.blurCallback)) {
            c.blurCallback = b.blurCallback
        } else {
            c.blurCallback = function () {
            }
        }
    }, setActive: function (b) {
        var a = this;
        a.active = b;
        if (b && a.enabled) {
            a.container.addCls("active");
            a.input.el.focus();
            if (a.clearOnFocus) {
                a.input.el.value = "";
                a.onKeyUp()
            }
        } else {
            a.container.removeCls("active");
            a.input.el.blur()
        }
    }, getValue: function (a) {
        if (a) {
            return this.input.el.value.replace(a, "")
        }
        return this.input.el.value
    }, setValue: function (b) {
        var a = this;
        if (a.input.el.value !== b) {
            a.input.el.value = b
        }
    }, onFocusChanged: function (b) {
        var a = this;
        if (b) {
            a.fireEvent("request:keyboardManager.addProperty", "disabled", a.id)
        } else {
            a.fireEvent("request:keyboardManager.removeProperty", "disabled", a.id);
            a.blurCallback()
        }
    }
};
Interface.utils.DOMInputField = Sys.extend(Interface.utils.AbstractInputField, Interface.utils.DOMInputField, "Interface.utils.DOMInputField");
Sys.ns("Interface.utils");
Interface.utils.DOMOptionScroller = {
    CSS: {
        base: "interface-DOMOptionScroller_base",
        buttonBase: "interface-DOMOptionScroller_buttonBase",
        buttonUp: "interface-DOMOptionScroller_buttonUp interface-DOMOptionScroller_buttonUp_uri",
        buttonDown: "interface-DOMOptionScroller_buttonDown interface-DOMOptionScroller_buttonDown_uri",
        valuesHolder: "interface-DOMOptionScroller_valuesHolder",
        value: "interface-DOMOptionScroller_value interface-DOMOptionScroller_value_uri",
        wrapper: "interface-DOMOptionScroller_valueWrapper"
    }, PIXEL_FACTOR: 0.01, constructor: function () {
        Interface.utils.DOMOptionScroller.superclass.constructor.apply(this, arguments)
    }, onUserInputStart: function () {
    }, onUserInputEnd: function () {
    }, enable: function () {
        Interface.utils.DOMOptionScroller.superclass.enable.apply(this, arguments);
        this.container.removeCls("disabled")
    }, disable: function () {
        Interface.utils.DOMOptionScroller.superclass.enable.apply(this, arguments);
        this.container.addCls("disabled")
    }, getContainer: function () {
        return this.container
    }, init: function (a) {
        this.setUpDOMStructure(a);
        Interface.utils.DOMOptionScroller.superclass.init.apply(this, arguments)
    }, setUpDOMStructure: function (b) {
        var d = this, a = Sys.applyIf(Sys.apply({}, b.CSS), d.CSS), c;
        d.id = b.id || "DOMOptionScroller";
        d.valueChilds = [];
        d.valueButtons = [];
        d.wrapperChilds = [];
        d.avg = 0;
        d.container = new Sys.Element({id: d.id, tag: "div", cls: a.base});
        d.downButton = new Interface.utils.DOMButton({
            id: d.id + "_downButton",
            baseCSS: a.buttonBase + " " + a.buttonDown,
            clickCallback: function () {
                d.scroll("down")
            }
        });
        d.downButton.disable("lowerBoundReached");
        d.container.add(d.downButton.getContainer());
        d.values = d.container.add(new Sys.Element({id: d.id + "_values", tag: "div", cls: a.valuesHolder}));
        d.valuesScroller = d.values.add(new Sys.Element({
            id: d.id + "_valuesScroller",
            tag: "div",
            style: "position:absolute; height:100%;white-space: nowrap;"
        }));
        d.valuesScroller.el.style[Sys.utils.pollyFill("transition")] = "transform 100ms";
        Sys.each(b.values, function (h, e) {
            var f, g = false;
            if (Sys.isDefined(b.replaceTextByIndex)) {
                Sys.each(b.replaceTextByIndex, function (i) {
                    if (e === i.index) {
                        f = i.text;
                        if (i.skip) {
                            g = true
                        }
                    }
                })
            }
            if (!g) {
                c = new Interface.utils.DOMButton({
                    id: "value" + h,
                    baseCSS: a.value,
                    textContent: (Sys.isDefined(f) ? f : h),
                    clickCallback: function () {
                        d.callback(h)
                    }
                });
                d.valuesScroller.add(c.getContainer());
                d.valueChilds.push(c.getContainer());
                d.valueButtons.push(c)
            }
        });
        d.upButton = new Interface.utils.DOMButton({
            id: d.id + "_upButton",
            baseCSS: a.buttonBase + " " + a.buttonUp,
            clickCallback: function () {
                d.scroll("up")
            }
        });
        d.container.add(d.upButton.getContainer());
        d.calculateOffsetValues();
        d.valueWidth = b.valueWidth;
        d.scrollOffsetModifier = b.scrollOffsetModifier;
        d.scrollOffset = d.scrollOffsetModifier * b.valueWidth;
        d.currentScrollOffset = 0;
        d.maxScrollOffset = 0;
        d.minScrollOffset = -(((b.values.length - 1) * d.valueWidth) - d.scrollOffset);
        if (d.minScrollOffset >= d.currentScrollOffset) {
            d.upButton.disable("upperBoundReached")
        }
    }, calculateOffsetValues: function () {
        var b = this, a = 0;
        Sys.each(b.valueChilds, function (c) {
            if (c.el.clientWidth > 0) {
                a += c.el.clientWidth
            }
        });
        if (a > 0) {
            b.scrollOffset = (a / b.valueChilds.length) * b.scrollOffsetModifier
        }
        b.totalValueWidth = a
    }, scroll: function (b) {
        var a = this, c = b === "up" ? -1 : 1;
        if (!Sys.isDefined(a.totalValueWidth) || a.tot === 0) {
            a.calculateOffsetValues()
        }
        a.currentScrollOffset = Math.max(Math.min(a.currentScrollOffset + c * a.scrollOffset, a.maxScrollOffset), a.minScrollOffset);
        a.valuesScroller.el.style[Sys.utils.pollyFill("transform")] = "translate3d(" + a.currentScrollOffset * a.PIXEL_FACTOR + "rem,0,0)";
        if (a.currentScrollOffset === a.minScrollOffset) {
            a.upButton.disable("upperBoundReached")
        } else {
            a.upButton.enable("upperBoundReached")
        }
        if (a.currentScrollOffset === 0) {
            a.downButton.disable("lowerBoundReached")
        } else {
            a.downButton.enable("lowerBoundReached")
        }
    }
};
Interface.utils.DOMOptionScroller = Sys.extend(Interface.utils.AbstractOptionScroller, Interface.utils.DOMOptionScroller, "Interface.utils.DOMOptionScroller");
Sys.ns("Interface.utils");
Interface.utils.DOMButton = {
    BASE_CSS: "DOMButton",
    textContent: "",
    container: undefined,
    renderTo: undefined,
    constructor: function () {
        Interface.utils.DOMButton.superclass.constructor.apply(this, arguments)
    },
    init: function (a) {
        var b = this;
        b.id = a.id;
        b.BASE_CSS = a.baseCSS || b.BASE_CSS;
        b.textContent = a.textContent || b.textContent;
        b.tagType = a.tag || "div";
        b.renderTo = a.renderTo;
        b.setupContainer();
        Interface.utils.DOMButton.superclass.init.apply(b, arguments)
    },
    up: function () {
        Interface.utils.DOMButton.superclass.up.apply(this, arguments);
        this.update()
    },
    down: function () {
        Interface.utils.DOMButton.superclass.down.apply(this, arguments);
        this.update()
    },
    hover: function () {
        Interface.utils.DOMButton.superclass.hover.apply(this, arguments);
        this.update()
    },
    getContainer: function () {
        return this.container
    },
    setupContainer: function () {
        var a = this;
        a.container = new Sys.Element({
            id: a.id,
            tag: a.tagType,
            cls: a.BASE_CSS,
            textContent: a.textContent,
            renderTo: a.renderTo
        })
    },
    isInputTarget: function (a) {
        return Sys.UserInputUtils.isCoordinateTarget(this.container.el, a)
    },
    update: function () {
        var b = this, a = b.container;
        a.removeCSSClass("hidden");
        a.removeCSSClass("disabled");
        a.removeCSSClass("active");
        a.removeCSSClass("hover");
        a.removeCSSClass("down");
        if (b.hasProperty("hidden")) {
            a.addCSSClass("hidden")
        }
        if (b.hasProperty("disabled")) {
            a.addCSSClass("disabled")
        } else {
            if (b.hasProperty("active")) {
                a.addCSSClass("active")
            } else {
                if (b.state === "hover") {
                    a.addCSSClass("hover")
                } else {
                    if (b.state === "down") {
                        a.addCSSClass("down")
                    }
                }
            }
        }
    }
};
Interface.utils.DOMButton = Sys.extend(Interface.AbstractButton, Interface.utils.DOMButton, "Interface.utils.DOMButton");
Sys.ns("Interface.utils");
Interface.utils.DOMScrollableContent = {
    constructor: function (a) {
        Interface.utils.DOMScrollableContent.superclass.constructor.apply(this, arguments)
    }, setupContainer: function (b) {
        var c = this, a = b.snap;
        c.content = b.content;
        c.model = new Core.Model({});
        c.container = new Sys.Element({id: c.id + "_container", tag: "div", cls: c.CSS.base});
        c.container.add(c.content);
        c._scroller = new Scroller(c.onScroll.bind(c), {
            scrollingX: false,
            snapping: Sys.isObj(a),
            speedMultiplier: 1.5 / Number(Environment.getScale()),
            scrollingComplete: c.onScrollComplete.bind(c, b.scrollCompleteCallback)
        });
        if (Sys.isObj(a)) {
            c._scroller.setSnapSize(a.width, a.height)
        }
    }, onScroll: function (c, b) {
        var a = this;
        a.content.el.style[Sys.utils.pollyFill("transform")] = "translate3d(0," + (-b) + "px,0)";
        if (Sys.isDefined(a.scrollBar)) {
            a.moveScrollIndicator(b)
        }
    }, onScrollComplete: function (c) {
        var b = this, a = b._scroller, d = a.getValues().top;
        if (!b.model.isState("scrollingByProxy")) {
            a.scrollTo(0, d, false)
        }
        if (Sys.isDefined(c)) {
            c(d)
        }
    }, show: function () {
        var a = this;
        a.container.el.style.display = "block";
        a.updateScrollerDimensions();
        if (a.isScrollBarVisible) {
            a.showScrollBar()
        }
    }, hide: function () {
        this.container.el.style.display = "none";
        this.hideScrollBar()
    }, enable: function () {
        Interface.utils.DOMScrollableContent.superclass.enable.apply(this, arguments);
        this.updateScrollerDimensions()
    }, onUserInputStart: function (d) {
        var c = this, a = c.model, b = c.contentIsScrollable();
        if (b) {
            if (Sys.isDefined(c.scrollBar) && Sys.UserInputUtils.isCoordinateTarget(c.scrollBar.el, d)) {
                a.setState("scrollingByProxy");
                c.onBarIndicatorMove(d)
            } else {
                if (Sys.UserInputUtils.isCoordinateTarget(c.content.el, d)) {
                    a.setState("scrolling");
                    c._scroller.doTouchStart([{pageX: d.x, pageY: d.y}], Date.now())
                }
            }
            if ((a.isState("scrolling") || a.isState("scrollingByProxy")) && !a.readData("hasSetDimensions")) {
                c.updateScrollerDimensions();
                a.storeData("hasSetDimensions", true)
            }
        }
    }, contentIsScrollable: function () {
        var b = this, c = b.container.el.clientHeight, a = b.content.el.scrollHeight;
        return c < a + 20
    }, updateScrollerDimensions: function () {
        var d = this, e, c, f, b, a;
        e = d.container.el.clientHeight;
        c = d.content.el.scrollHeight;
        d._scroller.setDimensions(d.container.el.clientWidth, e + 20, d.content.el.scrollWidth, c + 60);
        b = d.container.el.getBoundingClientRect();
        d._scroller.setPosition(b.left + d.container.clientLeft, b.top + d.container.clientTop);
        if (e > 0 && c > 0) {
            a = (e < c + 20)
        }
        if (a) {
            if (!Sys.isDefined(d.scrollBar)) {
                d.addScrollBar()
            }
            d.isScrollBarVisible = true;
            d.showScrollBar();
            f = d.scrollBar.el.clientHeight;
            d.scrollIndicatorHeight = d.scrollIndicator.el.clientHeight;
            d.maxScroll = d._scroller.getScrollMax().top;
            d.scrollBarHeight = f - d.scrollIndicatorHeight
        } else {
            if (Sys.isDefined(d.scrollBar)) {
                d.isScrollBarVisible = false;
                d.hideScrollBar()
            }
        }
    }, onUserInputMove: function (c) {
        var b = this, a = b.contentIsScrollable();
        if (a) {
            if (b.model.isState("scrolling")) {
                b._scroller.doTouchMove([{pageX: c.x, pageY: c.y}], Date.now())
            } else {
                if (b.model.isState("scrollingByProxy")) {
                    b.onBarIndicatorMove(c)
                }
            }
        }
    }, onUserInputEnd: function () {
        var b = this, a = b.model, c = a.isState("scrolling") || a.isState("scrollingByProxy");
        a.setState("idle");
        if (c) {
            b._scroller.doTouchEnd(Date.now())
        }
    }, onUserInputScroll: function (g, c) {
        var e = this, a = e.model, d = Sys.UserInputUtils.isCoordinateTarget(e.content.el, g),
            f = Sys.isDefined(e.scrollBar) && Sys.UserInputUtils.isCoordinateTarget(e.scrollBar.el, g),
            b = (d || f) && e.contentIsScrollable();
        if (b) {
            a.setState("scrollingByProxy");
            e._scroller.scrollBy(0, c.deltaY || c.detail * 30, false);
            if (!a.readData("hasSetDimensions")) {
                e.updateScrollerDimensions();
                a.storeData("hasSetDimensions", true)
            }
        }
    }, moveScrollIndicator: function (d) {
        var c = this, b = c.maxScroll, a = Math.round(c.scrollIndicatorHeight / 2);
        if (d < 0) {
            d = 0
        } else {
            if (d > b) {
                d = b
            }
        }
        c.scrollIndicator.el.style.top = Math.round(c.scrollBarHeight * (d / b) + a) + "px"
    }, onBarIndicatorMove: function (f) {
        var b = this, e = Sys.UserInputUtils.getCoordinatesRelativeToElement(f, b.scrollBar.el), c = e.y,
            d = b.scrollBarHeight, a;
        if (c < 0) {
            c = 0
        } else {
            if (c > d) {
                c = d
            }
        }
        a = Math.round(b.maxScroll * (c / d));
        b._scroller.scrollTo(0, a, true)
    }, addScrollBar: function () {
        var a = this;
        if (!Sys.isDefined(a.container)) {
            return
        }
        a.maxScroll = 0;
        a.scrollBar = a.container.add(new Sys.Element({
            tag: "div",
            id: a.id + "_scrollbar",
            "class": "interface-scrollableContent_scrollBar"
        }));
        a.scrollBarBackground = a.scrollBar.add(new Sys.Element({
            tag: "div",
            "class": "interface-scrollableContent_scrollBarBackground utils_horizontal_center"
        }));
        a.scrollIndicator = a.scrollBar.add(new Sys.Element({
            tag: "div",
            "class": "interface-scrollableContent_scrollBarHandle utils_center"
        }))
    }, showScrollBar: function () {
        if (Sys.isDefined(this.scrollBar)) {
            this.scrollBar.el.style.display = "block"
        }
    }, hideScrollBar: function () {
        if (Sys.isDefined(this.scrollBar)) {
            this.scrollBar.el.style.display = "none"
        }
    }, startListeningToUserInput: function () {
        Interface.utils.DOMScrollableContent.superclass.startListeningToUserInput.apply(this, arguments);
        this.addListener("notify:userInputManager.userInputScroll", this.onUserInputScroll)
    }, stopListeningToUserInput: function () {
        Interface.utils.DOMScrollableContent.superclass.stopListeningToUserInput.apply(this, arguments);
        this.removeListener("notify:userInputManager.userInputScroll")
    }, scrollTo: function (b) {
        var a = this._scroller;
        a.scrollTo(0, b, false);
        a.options.scrollingComplete(a.getValues().top)
    }
};
Interface.utils.DOMScrollableContent = Sys.extend(Interface.utils.UserInputBase, Interface.utils.DOMScrollableContent, "Interface.utils.DOMScrollableContent");
Sys.ns("Interface");
Interface.SettingsSection = {
    constructor: function () {
        Interface.SettingsSection.superclass.constructor.apply(this, arguments)
    }, getMixinDependencies: function () {
        return ["userInput", "orientation"]
    }, getDefaultMVCClasses: function () {
        return {model: Core.Model, view: Interface.SettingsSectionView, controller: Interface.SettingsSectionController}
    }
};
Interface.SettingsSection = Sys.extend(Core.Module, Interface.SettingsSection, "Interface.SettingsSection");
Sys.ns("Interface");
Interface.SettingsSectionController = {
    constructor: function () {
        Interface.SettingsSectionController.superclass.constructor.apply(this, arguments);
        this.setUpContent()
    }, setupEvents: function () {
        var a = this, b = {
            "view:addToContainer": a.addViewToContainer,
            "view:removeFromContainer": a.removeViewFromContainer,
            "view:addToNavigator": a.addOptionToNavigator,
            "view:userAction": a.onUserAction,
            "view:disableSetting": a.disableSetting,
            "view:showRequest": a.onShowRequest,
            "view:hideRequest": a.onHideRequest,
            "notify:stateHandler.enteringIdleState": a.onEnteringIdleState,
            "notify:stateHandler.leavingIdleState": a.onLeavingIdleState,
            "request:enableBasicGamePanel": a.onEnableBasicGamePanel,
            "request:disableBasicGamePanel": a.onDisableBasicGamePanel,
            "notify:featureSplash.showing": a.onFeatureSplashShowing,
            "notify:featureSplash.closed": a.onFeatureSplashClosed
        };
        b["request:" + a.MODULE_NAME + ".show"] = a.onShowRequest;
        b["request:" + a.MODULE_NAME + ".hide"] = a.onHideRequest;
        b["request:" + a.MODULE_NAME + ".enable"] = a.enable;
        b["request:" + a.MODULE_NAME + ".disable"] = a.disable;
        a.on(b)
    }, setUpContent: function () {
        this.view.setUpContent()
    }, onShowRequest: function (b) {
        var c = this, a = c.model.readData("currentContainer");
        if (!c.model.readData("showing")) {
            if (Sys.isDefined(a)) {
                c.fireEvent("request:" + a + ".openChild", c.MODULE_NAME, b)
            } else {
                c.show(b)
            }
        }
        Services.storage.storeData(c.MODULE_NAME + ".showing", true)
    }, onHideRequest: function () {
        var b = this, a = b.model.readData("currentContainer");
        if (b.model.readData("showing")) {
            if (Sys.isDefined(a)) {
                b.fireEvent("request:" + a + ".closeChild", b.MODULE_NAME)
            } else {
                b.hide()
            }
        }
        Services.storage.storeData(b.MODULE_NAME + ".showing", false)
    }, addViewToContainer: function (a, c) {
        var d = this, b = this.model.readData("currentContainer");
        if (b) {
            d.removeViewFromContainer(b)
        }
        d.model.storeData("currentContainer", a);
        d.addListener("notify:" + a + ".openedChild", d.containerOpenedChild);
        d.addListener("notify:" + a + ".closedChild", d.containerClosedChild);
        d.fireEvent("request:" + a + ".addChild", d.MODULE_NAME, c)
    }, containerOpenedChild: function (b, a) {
        if (b === this.MODULE_NAME) {
            this.show(a)
        }
    }, containerClosedChild: function (a) {
        if (a === this.MODULE_NAME) {
            this.hide()
        }
    }, show: function (a) {
        var b = this;
        if (!b.model.readData("showing")) {
            b.model.storeData("showing", true);
            Services.storage.storeData(b.MODULE_NAME + ".showing", true);
            b.fireEvent("notify:" + b.MODULE_NAME + ".shown");
            b.view.show(a);
            b.startListeningToUserInput()
        }
    }, hide: function () {
        var a = this;
        if (a.model.readData("showing")) {
            a.model.storeData("showing", false);
            Services.storage.storeData(a.MODULE_NAME + ".showing", false);
            a.fireEvent("notify:" + a.MODULE_NAME + ".hidden");
            a.stopListeningToUserInput();
            a.view.hide()
        }
    }, removeViewFromContainer: function (a, b) {
        var c = this;
        c.removeListener("notify:" + a + ".openedChild");
        c.removeListener("notify:" + a + ".closedChild");
        c.fireEvent("request:" + a + ".removeChild", c.MODULE_NAME, b)
    }, addOptionToNavigator: function (a, b) {
        this.fireEvent("request:" + a + ".addChild", this.MODULE_NAME, b)
    }, onUserAction: function () {
    }, onUserInputStart: function () {
        this.view.onUserInputStart.apply(this.view, arguments)
    }, onUserInputMove: function () {
        this.view.onUserInputMove.apply(this.view, arguments)
    }, onUserInputEnd: function () {
        this.view.onUserInputEnd.apply(this.view, arguments)
    }, onUserInputScroll: function () {
        this.view.onUserInputScroll.apply(this.view, arguments)
    }, enable: function (a) {
        this.model.storeData("disabled", false);
        this.view.enable(a)
    }, disable: function (a) {
        this.model.storeData("disabled", true);
        this.view.disable(a)
    }, onPortrait: function () {
        this.model.storeData("hasSetDimensions", false);
        Mixins.orientation.controller.methods.onPortrait.apply(this, arguments)
    }, onLandscape: function () {
        this.model.storeData("hasSetDimensions", false);
        Mixins.orientation.controller.methods.onLandscape.apply(this, arguments)
    }, onLeavingIdleState: function () {
        var a = this;
        if (Sys.isDefined(a.view.onLeavingIdleState)) {
            a.view.onLeavingIdleState()
        }
    }, onEnteringIdleState: function () {
        var a = this;
        if (Sys.isDefined(a.view.onEnteringIdleState)) {
            a.view.onEnteringIdleState()
        }
    }, onEnableBasicGamePanel: function (b) {
        var a = this;
        if (Sys.isDefined(a.view.onEnableBasicGamePanel)) {
            a.view.onEnableBasicGamePanel(b)
        }
    }, onDisableBasicGamePanel: function (b) {
        var a = this;
        if (Sys.isDefined(a.view.onDisableBasicGamePanel)) {
            a.view.onDisableBasicGamePanel(b)
        }
    }, onFeatureSplashShowing: function () {
        var a = this;
        if (Sys.isDefined(a.view.onFeatureSplashShowing)) {
            a.view.onFeatureSplashShowing()
        }
    }, onFeatureSplashClosed: function () {
        var a = this;
        if (Sys.isDefined(a.view.onFeatureSplashClosed)) {
            a.view.onFeatureSplashClosed()
        }
    }, disableSetting: function (a) {
        this.fireEvent("request:settingsManager.disableSetting", a)
    }
};
Interface.SettingsSectionController = Sys.extend(Core.Controller, Interface.SettingsSectionController, "Interface.SettingsSectionController");
Sys.ns("Interface");
Interface.SettingsSectionModel = {
    constructor: function () {
        Interface.SettingsSectionModel.superclass.constructor.apply(this, arguments)
    }, initData: function (b) {
        var c = this, d = b.defaultValue, a = Sys.isDefined(b.silent) ? b.silent : true;
        if (b.settingsManager) {
            if (b.localStorage && !b.ignoreLocalStorageValue && Services.localStorageManager.hasData(b.key)) {
                d = Sys.utils.parseValue(Services.localStorageManager.readData(b.key))
            }
            Services.settingsManager.storeSetting(b.key, d, b.localStorage, a)
        }
        c.storeData(b.key, d)
    }, setupData: function () {
        Services.storage.storeData(this.MODULE_NAME + ".showing", false)
    }
};
Interface.SettingsSectionModel = Sys.extend(Core.Model, Interface.SettingsSectionModel, "Interface.SettingsSectionModel");
Sys.ns("Interface");
Interface.SettingsSectionView = {
    SCROLL_BAR_CSS: "interface-settingsSection_scrollBar",
    SCROLL_INDICATOR_CSS: "interface-settingsSection_scrollIndicator utils_center",
    DISABLE_BUTTON_DURING_SPIN: true,
    ENABLED_ONLY_IN_BASIC_GAME: false,
    DISABLE_BUTTON_DURING_FEATURE_SPLASH: true,
    constructor: function () {
        Interface.SettingsSectionView.superclass.constructor.apply(this, arguments)
    },
    setUpContent: function () {
        this.container = new Sys.Element({tag: "div"})
    },
    addContainerToSettings: function () {
    },
    addScrolling: function () {
        var a = this;
        if (Sys.isDefined(a.container) && Sys.isDefined(a.container.parent)) {
            a._wrapper = a.container.parent
        } else {
            return
        }
        a._scroller = new Scroller(a.onScroll.bind(a), {
            scrollingX: false,
            speedMultiplier: 1.5 / Number(Environment.getScale())
        })
    },
    onScroll: function (c, b) {
        var a = this;
        a.container.el.style[Sys.utils.pollyFill("transform")] = "translate3d(0," + (-b) + "px,0)";
        if (Sys.isDefined(a.scrollBar)) {
            a.moveScrollIndicator(b)
        }
    },
    show: function () {
        var a = this;
        a.container.el.style.display = "block";
        a.updateScrollerDimensions();
        if (a.isScrollBarVisible) {
            a.showScrollBar()
        }
        if (!a.model.readData("disabled")) {
            a.callFunctionOnSubComponents("startListeningToUserInput")
        }
    },
    hide: function () {
        this.container.el.style.display = "none";
        this.hideScrollBar();
        this.callFunctionOnSubComponents("stopListeningToUserInput")
    },
    enable: function () {
    },
    disable: function () {
    },
    adaptToOrientation: function () {
        var a = this;
        Mixins.orientation.view.methods.adaptToOrientation.apply(this, arguments);
        clearTimeout(a.orientationAdaptationTimeout);
        a.orientationAdaptationTimeout = setTimeout(function () {
            a.updateScrollerDimensions()
        }, 50)
    },
    onUserInputStart: function (d) {
        var c = this, a = c.model, b = c.contentIsScrollable() && !c.userInputOnSubControl(d);
        if (b) {
            if (Sys.isDefined(c.scrollBar) && Sys.UserInputUtils.isCoordinateTarget(c.scrollBar.el, d)) {
                a.setState("scrollingByProxy");
                c.onBarIndicatorMove(d)
            } else {
                if (Sys.UserInputUtils.isCoordinateTarget(c.container.el, d)) {
                    a.setState("scrolling");
                    c._scroller.doTouchStart([{pageX: d.x, pageY: d.y}], Date.now())
                }
            }
            if ((a.isState("scrolling") || a.isState("scrollingByProxy")) && !a.readData("hasSetDimensions")) {
                c.updateScrollerDimensions();
                a.storeData("hasSetDimensions", true)
            }
        }
    },
    userInputOnSubControl: function (d) {
        var b = this, a = b.container.el.querySelectorAll("[data-input]"), c = false;
        Sys.each(a, function (e) {
            if (Sys.UserInputUtils.isCoordinateTarget(e, d)) {
                c = true
            }
        });
        return c
    },
    contentIsScrollable: function () {
        var b = this, c = b._wrapper.el.clientHeight, a = b.container.el.scrollHeight;
        return c + 40 < a
    },
    updateScrollerDimensions: function () {
        var d = this, e, c, f, b, a;
        if (!Sys.isDefined(d._wrapper)) {
            return
        }
        e = d._wrapper.el.clientHeight;
        c = d.container.el.scrollHeight;
        d._scroller.setDimensions(d._wrapper.el.clientWidth, e + 20, d.container.el.scrollWidth, c + 40);
        b = d._wrapper.el.getBoundingClientRect();
        d._scroller.setPosition(b.left + d._wrapper.clientLeft, b.top + d._wrapper.clientTop);
        if (e > 0 && c > 0) {
            a = (e + 40 < c)
        }
        if (a) {
            if (!Sys.isDefined(d.scrollBar)) {
                d.addScrollBar()
            }
            d.isScrollBarVisible = true;
            d.showScrollBar();
            f = d.scrollBar.el.clientHeight;
            d.scrollIndicatorHeight = d.scrollIndicator.el.clientHeight;
            d.maxScroll = d._scroller.getScrollMax().top;
            d.scrollBarHeight = f - d.scrollIndicatorHeight
        } else {
            if (Sys.isDefined(d.scrollBar)) {
                d.isScrollBarVisible = false;
                d.hideScrollBar()
            }
        }
    },
    onUserInputMove: function (b) {
        var a = this;
        if (a.model.isState("scrolling")) {
            a._scroller.doTouchMove([{pageX: b.x, pageY: b.y}], Date.now())
        } else {
            if (a.model.isState("scrollingByProxy")) {
                a.onBarIndicatorMove(b)
            }
        }
    },
    onUserInputEnd: function () {
        if (this.model.isState("scrolling")) {
            this._scroller.doTouchEnd(Date.now())
        }
        this.model.setState("idle")
    },
    onUserInputScroll: function (g, c) {
        var e = this, a = e.model, d = Sys.UserInputUtils.isCoordinateTarget(e.container.el, g),
            f = Sys.isDefined(e.scrollBar) && Sys.UserInputUtils.isCoordinateTarget(e.scrollBar.el, g),
            b = (d || f) && e.contentIsScrollable();
        if (b) {
            a.setState("scrollingByProxy");
            e._scroller.scrollBy(0, c.deltaY || c.detail * 30, false);
            if (!a.readData("hasSetDimensions")) {
                e.updateScrollerDimensions();
                a.storeData("hasSetDimensions", true)
            }
        }
    },
    callFunctionOnSubComponents: function (c, a) {
        var b = this;
        if (!b.model.readData("disabled")) {
            Sys.each(b.subComponents, function (d) {
                d[c].apply(d, a)
            })
        }
    },
    moveScrollIndicator: function (d) {
        var c = this, b = c.maxScroll, a = Math.round(c.scrollIndicatorHeight / 2);
        if (d < 0) {
            d = 0
        } else {
            if (d > b) {
                d = b
            }
        }
        c.scrollIndicator.el.style.top = Math.round(c.scrollBarHeight * (d / b) + a) + "px"
    },
    onBarIndicatorMove: function (e) {
        var b = this, f = Sys.UserInputUtils.getCoordinatesRelativeToElement(e, b.scrollBar.el), c = f.y,
            d = b.scrollBarHeight, a;
        if (c < 0) {
            c = 0
        } else {
            if (c > d) {
                c = d
            }
        }
        a = Math.round(b.maxScroll * (c / d));
        b._scroller.scrollTo(0, a, true)
    },
    addScrollBar: function () {
        var a = this;
        if (!Sys.isDefined(a._wrapper)) {
            return
        }
        a.maxScroll = 0;
        a.scrollBar = a._wrapper.add(new Sys.Element({
            tag: "div",
            id: a.MODULE_NAME + "_scrollbar",
            "class": a.SCROLL_BAR_CSS
        }));
        a.scrollBarBackground = a.scrollBar.add(new Sys.Element({
            tag: "div",
            "class": "interface-settingsSection_scrollBarBackground utils_horizontal_center"
        }));
        a.scrollIndicator = a.scrollBar.add(new Sys.Element({tag: "div", "class": a.SCROLL_INDICATOR_CSS}))
    },
    showScrollBar: function () {
        if (Sys.isDefined(this.scrollBar)) {
            this.scrollBar.el.style.display = "block"
        }
    },
    hideScrollBar: function () {
        if (Sys.isDefined(this.scrollBar)) {
            this.scrollBar.el.style.display = "none"
        }
    },
    onEnteringIdleState: function () {
        var a = this;
        if (Sys.isDefined(a.menuButton) && a.DISABLE_BUTTON_DURING_SPIN) {
            a.menuButton.removeCls("disabled");
            a.abstractButton.enable("notInIdleState")
        }
    },
    onLeavingIdleState: function () {
        var a = this;
        if (Sys.isDefined(a.menuButton) && a.DISABLE_BUTTON_DURING_SPIN) {
            a.menuButton.addCls("disabled");
            a.abstractButton.disable("notInIdleState")
        }
    },
    onEnableBasicGamePanel: function (b) {
        var a = this;
        if (Sys.isDefined(a.menuButton) && a.ENABLED_ONLY_IN_BASIC_GAME) {
            a.abstractButton.enable(b);
            if (!a.abstractButton.hasProperty("disabled") && !a.abstractButton.hasProperty("hidden")) {
                a.menuButton.removeCls("disabled")
            }
        }
    },
    onDisableBasicGamePanel: function (b) {
        var a = this;
        if (Sys.isDefined(a.menuButton) && a.ENABLED_ONLY_IN_BASIC_GAME) {
            a.menuButton.addCls("disabled");
            a.abstractButton.disable(b)
        }
    },
    onFeatureSplashShowing: function () {
        var a = this;
        if (Sys.isDefined(a.menuButton) && a.DISABLE_BUTTON_DURING_FEATURE_SPLASH) {
            a.menuButton.addCls("disabled");
            a.abstractButton.disable("featureSplashShowing")
        }
    },
    onFeatureSplashClosed: function () {
        var a = this;
        if (Sys.isDefined(a.menuButton) && a.DISABLE_BUTTON_DURING_FEATURE_SPLASH) {
            a.menuButton.removeCls("disabled");
            a.abstractButton.enable("featureSplashShowing")
        }
    }
};
Interface.SettingsSectionView = Sys.extend(Core.View, Interface.SettingsSectionView, "Interface.SettingsSectionView");
Sys.ns("Interface");
Interface.StandAloneSettingsSectionView = {
    BASE_CSS: "interface-standAloneSettingsSection",
    BACKGROUND_CSS: {
        top: "interface-standAloneSettingsSection_backgroundTop interface-standAloneSettingsSectionTop_uri",
        title: "interface-standAloneSettingsSection_title",
        bottom: "interface-standAloneSettingsSection_backgroundBottom interface-standAloneSettingsSectionBottom_uri",
        arrow: "interface-standAloneSettingsSection_backgroundArrow interface-standAloneSettingsSectionArrow_uri",
        middle: "interface-standAloneSettingsSectionMiddle interface-standAloneSettingsSectionMiddle_uri"
    },
    ARROW_LEFT_VALUE: "0.00rem",
    DIVIDER_CSS: "interface-standAloneSettingsSection_divider interface-standAloneSettingsSectionDivider_uri",
    CLOSE_BUTTON_CSS: "interface-standAloneSettingsSection_closeButton",
    MENU_BUTTON_CSS: "interface-desktopSettingsMenu_button",
    CHECKBOX_CSS: {
        base: "interface-standAloneSettingsSectionContainer_checkBox",
        disabled: "interface-standAloneSettingsSectionContainer_checkBox_disabled",
        label: "interface-standAloneSettingsSectionContainer_checkBox_label",
        button_wrapper: "interface-standAloneSettingsSectionContainer_checkBox_wrapper",
        button_background: "interface-standAloneSettingsSectionContainer_checkBox_default",
        button_handle: "interface-standAloneSettingsSectionContainer_checkBox_checked"
    },
    RENDER_TARGET: "gameWrapper",
    TITLE: "Placeholder Header",
    ORDER: -1,
    constructor: function () {
        Interface.SettingsSectionView.superclass.constructor.apply(this, arguments)
    },
    getDivider: function () {
        return new Sys.Element({tag: "div", cls: this.DIVIDER_CSS})
    },
    setUpContent: function () {
        var a = this;
        a.wrapper = new Sys.Element({
            id: a.MODULE_NAME,
            tag: "div",
            cls: a.BASE_CSS,
            renderTo: a.RENDER_TARGET,
            style: "display:none;"
        });
        a.container = new Sys.Element({
            id: a.MODULE_NAME,
            tag: "div",
            cls: a.BASE_CSS,
            renderTo: a.RENDER_TARGET,
            style: "display:none;"
        });
        a.setupBackground();
        a.setupCloseButton();
        a.setUpMenuButton()
    },
    setupBackground: function () {
        var c = this, d = c.wrapper.add(new Sys.Element({id: "backgroundTop", tag: "div", cls: c.BACKGROUND_CSS.top})),
            a = c.wrapper.add(new Sys.Element({id: "backgroundMiddle", tag: "div", cls: c.BACKGROUND_CSS.middle})),
            b = c.wrapper.add(new Sys.Element({id: "backgroundBottom", tag: "div", cls: c.BACKGROUND_CSS.bottom}));
        d.add(new Sys.Element({id: "title", tag: "span", cls: c.BACKGROUND_CSS.title, textContent: c.getTitle()}));
        c.top = d;
        b.add(new Sys.Element({
            id: "backgroundArrow",
            tag: "div",
            cls: c.BACKGROUND_CSS.arrow,
            style: "left:" + c.ARROW_LEFT_VALUE + ";"
        }));
        c.container = a
    },
    getTitle: function () {
        return Services.languageManager.getText(this.TITLE)
    },
    setupCloseButton: function () {
        var a = this;
        a.closeButton = new Interface.utils.DOMButton({
            id: "closeButton",
            baseCSS: a.CLOSE_BUTTON_CSS,
            clickCallback: a.fireEvent.bind(a, "view:hideRequest"),
            hoverCallback: function () {
                a.top.addCls("hover")
            },
            upCallback: function () {
                a.top.removeCls("hover")
            }
        });
        a.container.add(a.closeButton.getContainer())
    },
    setUpMenuButton: function () {
        var a = this;
        a.menuButton = new Interface.utils.DOMButton({
            id: a.MODULE_NAME + "SettingsButton",
            baseCSS: a.MENU_BUTTON_CSS,
            clickCallback: a.onButtonClick.bind(a)
        });
        a.fireEvent("view:addToNavigator", "desktopSettingsMenu", {
            order: a.ORDER,
            element: a.menuButton.getContainer()
        })
    },
    onButtonClick: function () {
        var a = this.model.readData("showing") ? "hide" : "show";
        this.fireEvent("view:" + a + "Request")
    },
    show: function () {
        this.wrapper.el.style.display = "block";
        this.menuButton.addProperty("active", "sectionShowing")
    },
    hide: function () {
        this.wrapper.el.style.display = "none";
        this.menuButton.removeProperty("active", "sectionShowing")
    },
    enable: function (a) {
        this.menuButton.enable(a)
    },
    disable: function (a) {
        this.menuButton.disable(a)
    },
    onUserInputStart: function () {
    },
    onUserInputEnd: function () {
    },
    onEnteringIdleState: function () {
        var a = this;
        if (Sys.isDefined(a.menuButton) && a.DISABLE_BUTTON_DURING_SPIN) {
            a.menuButton.enable("notInIdleState")
        }
    },
    onLeavingIdleState: function () {
        var a = this;
        if (Sys.isDefined(a.menuButton) && a.DISABLE_BUTTON_DURING_SPIN) {
            a.menuButton.disable("notInIdleState")
        }
    },
    onEnableBasicGamePanel: function (b) {
        var a = this;
        if (Sys.isDefined(a.menuButton) && a.ENABLED_ONLY_IN_BASIC_GAME) {
            a.menuButton.enable(b)
        }
    },
    onDisableBasicGamePanel: function (b) {
        var a = this;
        if (Sys.isDefined(a.menuButton) && a.ENABLED_ONLY_IN_BASIC_GAME) {
            a.menuButton.disable(b)
        }
    },
    onFeatureSplashShowing: function () {
        var a = this;
        if (Sys.isDefined(a.menuButton) && a.DISABLE_BUTTON_DURING_FEATURE_SPLASH) {
            a.menuButton.disable("featureSplashShowing")
        }
    },
    onFeatureSplashClosed: function () {
        var a = this;
        if (Sys.isDefined(a.menuButton) && a.DISABLE_BUTTON_DURING_FEATURE_SPLASH) {
            a.menuButton.enable("featureSplashShowing")
        }
    }
};
Interface.StandAloneSettingsSectionView = Sys.extend(Interface.SettingsSectionView, Interface.StandAloneSettingsSectionView, "Interface.StandAloneSettingsSectionView");
Sys.ns("Interface");
Interface.CashField = {
    constructor: function () {
        Interface.CashField.superclass.constructor.apply(this, arguments)
    }, getMixinDependencies: function () {
        return {fallback: ["serverResponse", "orientation"], desktop: ["serverResponse", "animation"]}
    }, getDefaultMVCClasses: function () {
        return {
            model: Interface.CashFieldModel,
            controller: Interface.CashFieldController,
            view: Interface.CashFieldBaseView
        }
    }
};
Interface.CashField = Sys.extend(Core.Module, Interface.CashField, "Interface.CashField");
Sys.ns("Interface");
Interface.CashFieldModel = {
    constructor: function () {
        Interface.CashFieldModel.superclass.constructor.apply(this, arguments)
    }, setupData: function () {
        var b = this, a = Resources.readData("gameServerInitResponse");
        if (a.playforfun) {
            b.storeData("funPlay", true)
        } else {
            b.storeData("funPlay", false)
        }
    }, processServerResponse: function (a) {
        var b = this;
        b.checkAndSetState(a);
        b.storeWins(a)
    }, checkAndSetState: function (a) {
        var b = this;
        if (Sys.isDefined(a.freeRoundsLeft)) {
            if (!b.isState("freerounds")) {
                b.setState("freerounds")
            }
        } else {
            if ((a.nextaction === "freespin" && a.clientaction !== "init")) {
                if (!b.isState("freespin")) {
                    b.setState("freespin")
                }
            } else {
                if (a.clientaction === "init" && Sys.isDefined(a.freespins)) {
                    if (!b.isState("freespinRestore")) {
                        b.setState("freespinRestore")
                    }
                } else {
                    if (a.nextaction === "respin" && a.clientaction !== "init") {
                        if (!b.isState("respin")) {
                            b.setState("respin")
                        }
                    } else {
                        if (a.clientaction === "respin" && a.nextaction === "spin") {
                            if (!b.isState("respinLast")) {
                                b.setState("respinLast")
                            }
                        } else {
                            if (a.clientaction === "init" && a.nextaction === "respin" && !Sys.isDefined(a.freespins)) {
                                if (!b.isState("respinRestore")) {
                                    b.setState("respinRestore")
                                }
                            } else {
                                if (a.clientaction === "freespin" || (a.clientaction === "freespin") && a.nextaction === "spin") {
                                    if (!b.isState("freespinLast")) {
                                        b.setState("freespinLast")
                                    }
                                } else {
                                    if (!b.isState("basic")) {
                                        b.setState("basic")
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }, resetWins: function () {
        this.storeData("basicWinValues", {cents: 0, centsTotal: 0});
        this.storeData("freespinWinValues", {totalWinCents: 0})
    }, storeWins: function (a) {
        var b = this;
        if (Sys.isDefined(a.wins)) {
            b.storeData("basicWinValues", {cents: a.wins.cents || 0, centsTotal: a.wins.centsTotal || 0});
            Services.storage.storeData("cashField.winInCents", a.wins.centsTotal)
        }
        if (Sys.isDefined(a.wins)) {
            b.storeData("freespinWinValues", {totalWinCents: a.wins.centsTotal || 0})
        }
        if (Sys.isDefined(a.freeRoundsLeft)) {
            b.storeData("freeroundValues", {left: a.freeRoundsLeft, totalWin: a.freeRoundsWinTot})
        }
    }, setBetValues: function (a) {
        this.storeData("betValues", a)
    }, setBalanceValues: function (a) {
        this.storeData("balanceValues", a)
    }
};
Interface.CashFieldModel = Sys.extend(Core.Model, Interface.CashFieldModel, "Interface.CashFieldModel");
Sys.ns("Interface");
Interface.CashFieldController = {
    TOGGLE_SEQUENCE: [{action: "creditBetWin", displayDuration: 10000}, {
        action: "funPlay",
        displayDuration: 3000
    }], constructor: function () {
        Interface.CashFieldController.superclass.constructor.apply(this, arguments);
        this.dispatchAppendToRequest()
    }, init: function () {
        Interface.CashFieldController.superclass.init.apply(this, arguments)
    }, setupEvents: function () {
        var a = this;
        a.on({
            "notify:stateHandler.enteringIdleState": a.updateAllAndStartToggling.bind(a, "idle"),
            "notify:stateHandler.enteringSpinningState": a.onSpinningState,
            "notify:stateHandler.enteringBeforeLoaderCloseState": a.updateAllAndStartToggling.bind(a, "beforeLoaderClose"),
            "notify:settingsWindow.open": a.onSettingsWindowOpened,
            "notify:settingsWindow.closed": a.startToggling,
            "notify:serverManager.serverErrorReceived": a.onServerErrorReceived,
            "notify:responseParser.gameConfigurationParsed": a.model.storeWins.bind(a.model),
            "notify:moneyManager.betChanged": a.onBetChanged,
            "notify:moneyManager.balanceChanged": a.onBalanceChanged,
            "notify:standardWin.presentationComplete": a.updateCreditAndWin.bind(a, "idle"),
            "request:cashField.showWin": a.updateCreditAndWin.bind(a, "winPresentation"),
            "request:cashField.showBasicCashValues": a.setSpecifiedStateAndToggle.bind(a, "basic"),
            "notify:freeRounds.ended": a.onFreeRoundsEnded,
            "notify:freeRounds.reInitResponseReceived": a.onFreeRoundsReInit
        })
    }, dispatchAppendToRequest: function () {
        this.fireEvent("request:balanceDisplay.appendChild", this.view.getCashDisplayConfig())
    }, onBetChanged: function (a) {
        var b = this;
        b.model.setBetValues(a);
        b.view.updateValue("bet", b.model.readData("betValues").playerBetFormatted)
    }, onBalanceChanged: function (a) {
        this.model.setBalanceValues(a);
        this.view.updateValue("credit", a.playerBalanceFormatted);
        this.notifyBalanceChanged(a.playerBalanceCents)
    }, onFreeRoundsEnded: function () {
        this.setSpecifiedStateAndToggle("basic")
    }, setSpecifiedStateAndToggle: function (a) {
        if (Sys.isString(a)) {
            this.model.setState(a);
            this.updateAllAndStartToggling(a)
        }
    }, onFreeRoundsReInit: function (a) {
        this.model.processServerResponse(a);
        this.updateAllAndStartToggling("freerounds")
    }, onSpinningState: function () {
        this[this.model.getState() + "UpdateCreditValue"]();
        this.resetWinValue()
    }, onServerErrorReceived: function () {
        var b = this, a = b.model.getState();
        b.model.resetWins();
        b[a + "UpdateWinValues"](a)
    }, updateCreditAndWin: function (a) {
        var b = this, d = b.model.getState(), c = Services.moneyManager.getBalanceCents();
        b[d + "UpdateCreditValue"](c);
        b[d + "UpdateWinValues"](a);
        b.notifyBalanceChanged(c)
    }, notifyBalanceChanged: function (a) {
        this.fireEvent("notify:cashField.update", a)
    }, updateAllAndStartToggling: function (a) {
        this.updateCreditAndWin(a);
        this.startToggling()
    }, onFreespinOutro: function () {
        var a = this.model.getState();
        this[a + "UpdateCreditValue"](Services.moneyManager.getBalanceCents());
        this[a + "UpdateWinValues"]("freespinOutro")
    }, basicUpdateWinValues: function () {
        this.updateBasicWinValue();
        this.view.showSubComponent("creditBetWin")
    }, freespinUpdateWinValues: function () {
        this.updateFreespinWinValue()
    }, freespinRestoreUpdateWinValues: function () {
        this.updateFreespinWinValue()
    }, freespinLastUpdateWinValues: function () {
        this.updateFreespinWinValue()
    }, respinUpdateWinValues: function () {
        this.updateRespinWinValue()
    }, respinUpdateCreditValue: function () {
    }, respinLastUpdateWinValues: function () {
        this.updateRespinWinValue()
    }, respinLastUpdateCreditValue: function (a) {
        this.basicUpdateCreditValue(a)
    }, freeroundsUpdateCreditValue: function () {
        this.view.showSubComponent("freeRounds")
    }, freeroundsUpdateWinValues: function (b) {
        var c = this, d = c.model.readData("freeroundValues").left, a = c.model.readData("freeroundValues").totalWin;
        c.view.updateValue("freeRoundTotalWin", a);
        if (b !== "winPresentation") {
            c.view.updateValue("freeRoundLeft", d.toString())
        }
        this.view.showSubComponent("freeRounds")
    }, freespinUpdateCreditValue: function () {
    }, freespinRestoreUpdateCreditValue: function (b) {
        var a = this;
        if (!Sys.isDefined(b)) {
            b = a.model.readData("balanceValues").playerBalanceFormatted
        }
        a.view.updateValue("credit", b);
        a.view.showSubComponent("creditBetWin")
    }, respinRestoreUpdateCreditValue: function (b) {
        var a = this;
        if (!Sys.isDefined(b)) {
            b = a.model.readData("balanceValues").playerBalanceFormatted
        }
        a.view.updateValue("credit", b);
        a.view.showSubComponent("creditBetWin")
    }, respinRestoreUpdateWinValues: function () {
        this.updateRespinWinValue()
    }, freespinLastUpdateCreditValue: function (a) {
        this.basicUpdateCreditValue(a)
    }, basicUpdateCreditValue: function (b) {
        var a = this;
        if (!Sys.isDefined(b)) {
            b = a.model.readData("balanceValues").playerBalanceFormatted
        }
        a.view.updateValue("credit", b);
        a.view.showSubComponent("creditBetWin")
    }, updateBasicWinValue: function () {
        var a = this.model.readData("basicWinValues");
        if (a.cents) {
            this.view.updateWinValue(a.cents)
        }
    }, updateFreespinWinValue: function () {
        var a = this.model.readData("freespinWinValues");
        if (a.totalWinCents) {
            this.view.updateWinValue(a.totalWinCents)
        }
    }, updateRespinWinValue: function () {
        var a = this.model.readData("basicWinValues");
        if (a.centsTotal) {
            this.view.updateWinValue(a.centsTotal)
        }
    }, resetWinValue: function () {
        if (this.model.isState("basic") || this.model.isState("respinLast") || this.model.isState("freespinLast")) {
            this.view.updateWinValue(0)
        }
    }, onSettingsWindowOpened: function () {
        var a = this;
        clearTimeout(a.toggleTimeout);
        if (a.model.isState("freerounds")) {
            a.view.showSubComponent("freeRounds")
        } else {
            a.view.showSubComponent("creditBetWin", true)
        }
    }, startToggling: function () {
        var a = this;
        if (a.model.readData("funPlay") === true) {
            clearTimeout(a.toggleTimeout);
            a.model.storeData("nextToggleIndex", 0);
            a.showNextInToggleSequence()
        }
    }, showNextInToggleSequence: function () {
        var c = this, b = c.TOGGLE_SEQUENCE, d = c.model.readData("nextToggleIndex"), a = b[d];
        c.model.storeData("nextToggleIndex", (d + 1) % b.length);
        c.view.showSubComponent(a.action, true);
        c.toggleTimeout = setTimeout(c.showNextInToggleSequence.bind(c), a.displayDuration)
    }
};
Interface.CashFieldController = Sys.extend(Core.Controller, Interface.CashFieldController, "Interface.CashFieldController");
Sys.ns("Interface");
Interface.CashFieldBaseView = {
    CSS_CLASSES: {
        BASE: "interface-cashField_base",
        PORTRAIT: "interface-cashField_portrait",
        LANDSCAPE: "interface-cashField_landscape",
        SUB_COMPONENT: "interface-cashField_subComponent"
    },
    RESOLUTION: Environment.getResolution(),
    SCREEN_SIZE: Environment.getScreenSize(),
    FIRST_CHILD: false,
    constructor: function () {
        Interface.CashFieldBaseView.superclass.constructor.apply(this, arguments)
    },
    init: function () {
        var a = this;
        Interface.CashFieldBaseView.superclass.init.apply(a, arguments);
        a.displays = a.getDisplayConfig();
        a.getLocalText = function (b) {
            return Services.languageManager.getText(b)
        };
        a.getFormattedCentsValue = function (b, c) {
            return Services.moneyManager.formatMoneyCurrencySign(b, c)
        };
        a.constructDOMElements()
    },
    showSubComponent: function (b, d) {
        var c = this, a = c.model.readData("currentlyShowingElement");
        if ((!c.model.readData("funPlay") && a !== c[b]) || (a !== c[b] && c.model.readData("funPlay") && d)) {
            if (Sys.isDefined(a)) {
                c.hideElement(a)
            }
            c.showElement(c[b]);
            c.model.storeData("currentlyShowingElement", c[b])
        }
    },
    hideElement: function (a) {
        a.el.style.visibility = "hidden"
    },
    showElement: function (a) {
        a.el.style.visibility = "visible"
    },
    getDisplayConfig: function () {
        var a = this;
        return {
            credit: {
                wrapper: a.creditWrapper,
                displayID: "credit",
                textID: Language.Keys.cashColonVar,
                display: {},
                stringValue: "",
                valueElement: {}
            },
            bet: {
                wrapper: a.betWrapper,
                displayID: "bet",
                textID: Language.Keys.betColonVar,
                display: {},
                stringValue: "",
                valueElement: {}
            },
            win: {
                wrapper: a.winWrapper,
                displayID: "win",
                textID: Language.Keys.winColonVar,
                display: {},
                stringValue: "",
                valueElement: {}
            },
            funPlay: {
                wrapper: a.funPlayWrapper,
                displayID: "funPlay",
                textID: Language.Keys.playingForFun,
                display: {}
            },
            freeRoundLeft: {
                wrapper: a.freeRoundLeftWrapper,
                displayID: "freeRoundLeft",
                textID: Language.Keys.freeRoundsLeftColon,
                display: {},
                stringValue: "",
                valueElement: {}
            },
            freeRoundTotalWin: {
                wrapper: a.freeRoundTotalWinWrapper,
                displayID: "freeRoundTotalWin",
                textID: Language.Keys.totalWinColonVar,
                display: {},
                stringValue: "",
                valueElement: {}
            }
        }
    },
    getCashDisplayConfig: function () {
        return this.cashDisplay
    },
    constructDOMElements: function () {
        var b = this, a = b.displays;
        b.cashDisplay = new Sys.Element({tag: "div", cls: b.CSS_CLASSES.BASE});
        b.creditBetWin = new Sys.Element({tag: "div", cls: b.CSS_CLASSES.SUB_COMPONENT, style: "visibility:hidden;"});
        b.freeRounds = new Sys.Element({tag: "div", cls: b.CSS_CLASSES.SUB_COMPONENT, style: "visibility:hidden;"});
        b.funPlay = new Sys.Element({tag: "div", cls: b.CSS_CLASSES.SUB_COMPONENT, style: "visibility:hidden;"});
        b.constructElement(a.credit);
        b.constructElement(a.bet);
        b.constructElement(a.win);
        b.constructElement(a.funPlay);
        b.constructElement(a.freeRoundLeft);
        b.constructElement(a.freeRoundTotalWin);
        b.creditBetWin.add(a.credit.wrapper);
        b.creditBetWin.add(a.bet.wrapper);
        b.creditBetWin.add(a.win.wrapper);
        b.updateWinValue(0);
        b.cashDisplay.add(b.creditBetWin);
        b.freeRounds.add(a.freeRoundLeft.wrapper);
        b.freeRounds.add(a.freeRoundTotalWin.wrapper);
        b.cashDisplay.add(b.freeRounds);
        b.funPlay.add(a.funPlay.wrapper);
        b.cashDisplay.add(b.funPlay)
    },
    constructTextElement: function (b, f, g) {
        var d = this, e = [], c, a;
        if (b.contains("{0}")) {
            a = d.getTextStringOrder(b);
            Sys.each(a, function (h) {
                if (Sys.isString(h)) {
                    e.push(c = new Sys.Element({tag: "span", cls: "text"}));
                    c.el.textContent = h
                } else {
                    if (Sys.isNumber(h)) {
                        e.push(c = new Sys.Element({tag: "span", cls: "text value"}));
                        c.el.textContent = f || "";
                        g.valueElement = c
                    }
                }
            })
        } else {
            e.push(c = new Sys.Element({tag: "span", cls: "text"}));
            c.el.textContent = b
        }
        return e
    },
    constructTextValueWrapper: function () {
        var b = "margin-right:2%;", a = "margin-left:2%;";
        return new Sys.Element({tag: "div", cls: "wrapper", style: b + a})
    },
    constructElement: function (f) {
        var e = this, d, c = (!e.debug) ? e.getLocalText(f.textID) : e.worstCaseSpec[f.displayID].text,
            a = (!e.debug) ? f.value : e.worstCaseSpec[f.displayID].value, b = e.constructTextValueWrapper();
        f.wrapper = new Sys.Element({tag: "span"});
        f.wrapper.addCls("inline");
        f.wrapper.addCls("field");
        f.wrapper.addCls(f.displayID);
        d = e.constructTextElement(c, a, f);
        Sys.each(d, function (g) {
            b.add(g)
        });
        f.wrapper.add(b)
    },
    updateValue: function (b, a) {
        a = (Sys.isNumber(a)) ? this.getFormattedCentsValue(a) : a;
        if (this.displays[b].valueElement.el) {
            this.displays[b].valueElement.el.textContent = a
        }
    },
    updateWinValue: function (a) {
        var b = this;
        if (a >= 0) {
            a = b.getFormattedCentsValue(a)
        } else {
        }
        if (b.displays.win.valueElement.el) {
            b.displays.win.valueElement.el.textContent = a
        }
    },
    onPortrait: function () {
        var b = this, a = b.CSS_CLASSES, c = b.cashDisplay;
        c.addCls(a.PORTRAIT);
        c.removeCls(a.LANDSCAPE)
    },
    onLandscape: function () {
        var b = this, a = b.CSS_CLASSES, c = b.cashDisplay;
        c.addCls(a.LANDSCAPE);
        c.removeCls(a.PORTRAIT)
    },
    getTextStringOrder: function (e) {
        var b = [], d = /(\{\d+\})/g, a = e.split(d), c;
        Sys.each(a, function (f) {
            if (f.match(/\{\d+\}/)) {
                c = f.substring(1, f.length - 1);
                b.push(Sys.utils.toInt(c))
            } else {
                if (e.length > 0) {
                    b.push(f)
                }
            }
        });
        return b
    }
};
Interface.CashFieldBaseView = Sys.extend(Core.View, Interface.CashFieldBaseView, "Interface.CashFieldBaseView");
Sys.ns("Interface");
Interface.CashFieldMobileView = {
    CSS_CLASSES: {
        BASE: "interface-cashField_base interface-cashField_mobile",
        PORTRAIT: "interface-cashField_portrait_mobile",
        LANDSCAPE: "interface-cashField_landscape",
        SUB_COMPONENT: "interface-cashField_subComponent"
    }, constructor: function () {
        Interface.CashFieldMobileView.superclass.constructor.apply(this, arguments)
    }
};
Interface.CashFieldMobileView = Sys.extend(Interface.CashFieldBaseView, Interface.CashFieldMobileView, "Interface.CashFieldMobileView");
Sys.ns("Interface");
Interface.CashFieldTabletView = {
    CSS_CLASSES: {
        BASE: "interface-cashField_base interface-cashField_tablet",
        PORTRAIT: "interface-cashField_portrait interface-cashField_portrait interface-cashField_tablet",
        LANDSCAPE: "interface-cashField_landscape interface-cashField_landscape interface-cashField_tablet",
        SUB_COMPONENT: "interface-cashField_subComponent"
    }, constructor: function () {
        Interface.CashFieldTabletView.superclass.constructor.apply(this, arguments)
    }
};
Interface.CashFieldTabletView = Sys.extend(Interface.CashFieldBaseView, Interface.CashFieldTabletView, "Interface.CashFieldTabletView");
Sys.ns("Interface");
Interface.CashFieldDesktopView = {
    CSS_CLASSES: {
        BASE: "interface-cashField_base interface-cashField_desktop interface-cashField_desktop_uri",
        PORTRAIT: "",
        LANDSCAPE: "",
        SUB_COMPONENT: "interface-cashField_subComponent"
    }, constructor: function () {
        Interface.CashFieldDesktopView.superclass.constructor.apply(this, arguments)
    }
};
Interface.CashFieldDesktopView = Sys.extend(Interface.CashFieldBaseView, Interface.CashFieldDesktopView, "Interface.CashFieldDesktopView");
Sys.ns("Interface.Slots");
Interface.Slots.CoinsField = {
    constructor: function () {
        Interface.Slots.CoinsField.superclass.constructor.apply(this, arguments)
    }, getMixinDependencies: function () {
        return {fallback: ["serverResponse", "orientation"], desktop: ["serverResponse", "animation"]}
    }, getDefaultMVCClasses: function () {
        return {
            model: Interface.Slots.CoinsFieldModel,
            controller: Interface.Slots.CoinsFieldController,
            view: Interface.Slots.CoinsFieldBaseView
        }
    }
};
Interface.Slots.CoinsField = Sys.extend(Core.Module, Interface.Slots.CoinsField, "Interface.Slots.CoinsField");
Sys.ns("Interface.Slots");
Interface.Slots.CoinsFieldModel = {
    WIN_UP_TO: "[MAX COIN WIN]", constructor: function () {
        Interface.Slots.CoinsFieldModel.superclass.constructor.apply(this, arguments)
    }, setupData: function () {
        this.storeData("gameMode", "BASIC")
    }, processServerResponse: function (b) {
        var a = this;
        if (Sys.isDefined(b.wins)) {
            if (Sys.isDefined(b.wins.coinsTotal)) {
                a.storeData("totalWin", b.wins.coinsTotal)
            } else {
                a.storeData("totalWin", "")
            }
            if (Sys.isDefined(b.wins.coins)) {
                a.storeData("win", b.wins.coins)
            } else {
                a.storeData("win", 0)
            }
            if (Sys.isDefined(b.wins.freespins)) {
                a.storeData("additionalFreeSpins", b.wins.freespins)
            } else {
                a.storeData("additionalFreeSpins", 0)
            }
        }
        if (Sys.isDefined(b.freespins) && Sys.isDefined(b.freespins.left)) {
            a.storeData("freeSpinsLeft", b.freespins.left)
        } else {
            a.storeData("freeSpinsLeft", 0)
        }
    }, setWinToTotalWin: function () {
        this.storeData("win", this.readData("totalWin"))
    }, getBetText: function () {
        return Services.moneyManager.getBetCoins()
    }, getBalanceText: function () {
        return Services.moneyManager.getBalanceCoins()
    }, getWinText: function () {
        var a = this.readData("win");
        return a === 0 ? "" : a
    }, getProgressiveWinText: function () {
        return this.readData("win")
    }, getTotalWinText: function () {
        return this.readData("totalWin")
    }, getTotalWinCountUpValues: function () {
        var b = this.readData("win"), a = this.readData("totalWin");
        return {from: a - b, to: a}
    }, getFreeSpinsLeftText: function () {
        return this.readData("freeSpinsLeft")
    }, getAdditionalFreeSpinsWonText: function () {
        return this.readData("additionalFreeSpins")
    }, getWinUpToText: function () {
        return this.WIN_UP_TO
    }
};
Interface.Slots.CoinsFieldModel = Sys.extend(Core.Model, Interface.Slots.CoinsFieldModel, "Interface.Slots.CoinsFieldModel");
Sys.ns("Interface.Slots");
Interface.Slots.CoinsFieldController = {
    TOGGLE_SEQUENCE: [{
        action: "showWin",
        displayDuration: 3000
    }, {action: "showBalanceAndBet", displayDuration: 3000}, {
        action: "showWinUpTo",
        displayDuration: 3000
    }, {action: "showBalanceAndBet", displayDuration: 3000}], constructor: function () {
        Interface.Slots.CoinsFieldController.superclass.constructor.apply(this, arguments);
        this.view.setupView()
    }, setupEvents: function () {
        var a = this;
        a.on({
            "notify:stateHandler.enteringBeforeLoaderCloseState": a.onBeforeLoaderClose,
            "notify:stateHandler.enteringIdleState": a.onEnteringIdleState,
            "notify:stateHandler.enteringFreeSpinIntroState": a.onEnteringFreeSpinIntroState,
            "notify:stateHandler.enteringSpinningState": a.onEnteringSpinningState,
            "notify:moneyManager.betChanged": a.onInfoChanged,
            "notify:settingsWindow.open": a.onSettingsWindowOpened,
            "notify:settingsWindow.closed": a.onSettingsWindowClosed,
            "request:coinsField.showWin": a.onShowWinRequest,
            "request:coinsField.showNormalWin": a.onShowNormalWinRequest,
            "request:coinsField.showProgressiveWin": a.onShowProgressiveWinRequest,
            "request:coinsField.showFreeSpinsLeft": a.showFreeSpinsLeft,
            "request:coinsField.showAdditionalFreeSpinsWon": a.showAdditionalFreeSpinsWon,
            "request:coinsField.countUp": a.view.countUpProgressiveWin.bind(a.view),
            "notify:gameModeChanged": a.onGameModeChanged,
            "view:appendToGameFooter": a.fireEvent.bind(a, "request:balanceDisplay.appendChild"),
            "view:setCountUpCallback": a.fireEvent.bind(a, "request:coinsFieldCountUp.setCallback"),
            "view:startCountUp": a.fireEvent.bind(a, "request:coinsFieldCountUp.start"),
            "view:stopCountUp": a.fireEvent.bind(a, "request:coinsFieldCountUp.stop"),
            "view:countUpComplete": a.fireEvent.bind(a, "notify:coinsField.countUpComplete")
        })
    }, onBeforeLoaderClose: function () {
        this.showBalanceAndBet()
    }, onEnteringIdleState: function () {
        var a = this;
        if (a.model.readData("showProgressiveWinDisplay")) {
            a.model.storeData("showProgressiveWinDisplay", false);
            a.model.setWinToTotalWin()
        }
        if (a.model.readData("hasPlayedInitialRound")) {
            a.startToggling()
        } else {
            a.showBalanceAndBet()
        }
    }, onEnteringSpinningState: function () {
        var a = this;
        clearTimeout(a.toggleTimeout);
        a.model.storeData("hasPlayedInitialRound", true);
        a.model.storeData("win", "");
        if (a.model.readData("showProgressiveWinDisplay")) {
            a.showProgressiveWin()
        } else {
            a.showBalanceAndBet()
        }
    }, onEnteringFreeSpinIntroState: function () {
        this.view.onEnteringFreeSpinIntroState()
    }, onInfoChanged: function () {
        this.view.showBalanceAndBet()
    }, onSettingsWindowOpened: function () {
        clearTimeout(this.toggleTimeout);
        this.showBalanceAndBet()
    }, onShowWinRequest: function () {
        if (this.model.readData("showProgressiveWinDisplay")) {
            this.showProgressiveWin()
        } else {
            this.showWin()
        }
    }, onShowNormalWinRequest: function () {
        var a = this.model;
        if (a.readData("showProgressiveWinDisplay")) {
            a.storeData("showProgressiveWinDisplay", false);
            a.setWinToTotalWin()
        }
        this.showWin()
    }, onShowProgressiveWinRequest: function (a) {
        this.model.storeData("showProgressiveWinDisplay", true);
        this.showProgressiveWin(a)
    }, showBalanceAndBet: function () {
        this.view.showBalanceAndBet()
    }, showWin: function () {
        this.view.showWin()
    }, showProgressiveWin: function (a) {
        if (a) {
            this.model.storeData("win", "")
        }
        this.view.showProgressiveWin()
    }, showFreeSpinsLeft: function () {
        this.view.showFreeSpinsLeft()
    }, showAdditionalFreeSpinsWon: function () {
        this.view.showAdditionalFreeSpinsWon()
    }, startToggling: function () {
        this.model.storeData("nextToggleIndex", 0);
        this.showNextInToggleSequence()
    }, showNextInToggleSequence: function () {
        var c = this, b = c.TOGGLE_SEQUENCE, d = c.model.readData("nextToggleIndex"), a = b[d];
        c.model.storeData("nextToggleIndex", (d + 1) % b.length);
        c.view[a.action]();
        c.toggleTimeout = setTimeout(c.showNextInToggleSequence.bind(c), a.displayDuration)
    }, onGameModeChanged: function (a) {
        this.model.storeData("gameMode", a);
        this.view.onGameModeChanged(a)
    }
};
Interface.Slots.CoinsFieldController = Sys.extend(Core.Controller, Interface.Slots.CoinsFieldController, "Interface.Slots.CoinsFieldController");
Sys.ns("Interface.Slots");
Interface.Slots.CoinsFieldBaseView = {
    BASE_CSS: "interface-coinsField_base",
    BACKGROUND_URI: "interface-coinsField_uri",
    PORTRAIT_CSS: "interface-coinsField_portrait",
    LANDSCAPE_CSS: "interface-coinsField_landscape",
    SUB_COMPONENT_CSS: "interface-coinsField_subComponent",
    constructor: function () {
        Interface.Slots.CoinsFieldBaseView.superclass.constructor.apply(this, arguments)
    },
    setupView: function () {
        var d = this, g = 0, f = "<span class='number'></span>",
            e = "<div class='number' style='display: inline-block; text-align: left; min-width: 3em;'></div>",
            b = "<span class='number'>" + d.model.getWinUpToText() + "</span>", c = "margin-right:2%;",
            a = "margin-left:2%;";
        d.container = new Sys.Element({id: "coinsField", tag: "div", cls: d.BASE_CSS + " " + d.BACKGROUND_URI});
        d.betAndBalance = d.container.add(new Sys.Element({
            id: "coinsField_betAndBalance",
            tag: "div",
            cls: d.SUB_COMPONENT_CSS,
            style: "visibility:hidden; z-index:" + (g++) + ";"
        }));
        d.balanceDisplay = d.betAndBalance.add(new Sys.Element({
            id: "coinsField_betAndBalance_balanceDisplay",
            tag: "span",
            innerHTML: Services.languageManager.getText(Language.Keys.coinsColonVar).replace("{0}", f),
            style: c
        }));
        d.betDisplay = d.betAndBalance.add(new Sys.Element({
            id: "coinsField_betAndBalance_betDisplay",
            tag: "span",
            innerHTML: Services.languageManager.getText(Language.Keys.betColonVar).replace("{0}", f),
            style: a
        }));
        d.balanceCoinsElement = d.balanceDisplay.el.getElementsByTagName("span")[0] || document.createElement("span");
        d.betCoinsElement = d.betDisplay.el.getElementsByTagName("span")[0] || document.createElement("span");
        d.win = d.container.add(new Sys.Element({
            id: "coinsField_win",
            tag: "div",
            cls: d.SUB_COMPONENT_CSS,
            innerHTML: Services.languageManager.getText(Language.Keys.winColonVar).replace("{0}", f),
            style: "visibility:hidden; z-index:" + (g++) + ";"
        }));
        d.winCoinsElement = d.win.el.getElementsByTagName("span")[0] || document.createElement("span");
        d.youWon = d.container.add(new Sys.Element({
            id: "coinsField_youWon",
            tag: "div",
            cls: d.SUB_COMPONENT_CSS,
            innerHTML: Services.languageManager.getText(Language.Keys.youWonCoins).replace("{0}", f),
            style: "visibility:hidden; z-index:" + (g++) + ";"
        }));
        d.youWonCoinsElement = d.youWon.el.getElementsByTagName("span")[0] || document.createElement("span");
        d.progressiveWin = d.container.add(new Sys.Element({
            id: "coinsField_progressiveWin",
            tag: "div",
            cls: d.SUB_COMPONENT_CSS,
            style: "visibility:hidden; z-index:" + (g++) + ";"
        }));
        d.progressiveWinDisplay = d.progressiveWin.add(new Sys.Element({
            id: "coinsField_progressiveWin_winDisplay",
            tag: "span",
            innerHTML: Services.languageManager.getText(Language.Keys.winColonVar).replace("{0}", e),
            style: c
        }));
        d.totalWinDisplay = d.progressiveWin.add(new Sys.Element({
            id: "coinsField_progressiveWin_totalWinDisplay",
            tag: "span",
            innerHTML: Services.languageManager.getText(Language.Keys.totalWinColonVar).replace("{0}", e),
            style: a
        }));
        d.progressiveWinCoinsElement = d.progressiveWinDisplay.el.getElementsByTagName("div")[0] || document.createElement("div");
        d.totalWinCoinsElement = d.totalWinDisplay.el.getElementsByTagName("div")[0] || document.createElement("div");
        d.freeSpinsLeft = d.container.add(new Sys.Element({
            id: "coinsField_freeSpinsLeft",
            tag: "div",
            cls: d.SUB_COMPONENT_CSS,
            innerHTML: Services.languageManager.getText(Language.Keys.freeSpinsLeftColonVar).replace("{0}", f),
            style: "visibility:hidden; z-index:" + (g++) + ";"
        }));
        d.freeSpinsLeftNumberElement = d.freeSpinsLeft.el.getElementsByTagName("span")[0] || document.createElement("span");
        d.additionalFreeSpinsWon = d.container.add(new Sys.Element({
            id: "coinsField_additionalFreeSpinsWon",
            tag: "div",
            cls: d.SUB_COMPONENT_CSS,
            innerHTML: Services.languageManager.getText(Language.Keys.additonalFreeSpinsWon).replace("{0}", f),
            style: "visibility:hidden; z-index:" + (g++) + ";"
        }));
        d.additionalFreeSpinsNumberElement = d.additionalFreeSpinsWon.el.getElementsByTagName("span")[0] || document.createElement("span");
        d.winUpTo = d.container.add(new Sys.Element({
            id: "coinsField_winUpTo",
            tag: "div",
            cls: d.SUB_COMPONENT_CSS,
            innerHTML: Services.languageManager.getText(Language.Keys.winUpTo).replace("{0}", b),
            style: "visibility:hidden; z-index:" + g + ";"
        }));
        d.fireEvent("view:appendToGameFooter", d.container)
    },
    showBalanceAndBet: function () {
        var a = this;
        a.betCoinsElement.textContent = a.model.getBetText();
        a.balanceCoinsElement.textContent = a.model.getBalanceText();
        a.show(a.betAndBalance)
    },
    showWin: function () {
        var a = this, b = a.model.getWinText();
        if (b > 0) {
            a.youWonCoinsElement.textContent = b;
            a.show(a.youWon)
        } else {
            a.winCoinsElement.textContent = b;
            a.show(a.win)
        }
    },
    showProgressiveWin: function () {
        var a = this;
        a.fireEvent("view:stopCountUp");
        a.progressiveWinCoinsElement.textContent = a.model.getProgressiveWinText();
        a.totalWinCoinsElement.textContent = a.model.getTotalWinText();
        a.show(a.progressiveWin)
    },
    countUpCallback: function (a) {
        this.totalWinCoinsElement.textContent = a
    },
    countUpProgressiveWin: function (c) {
        var b = this, a = b.model.getTotalWinCountUpValues();
        if (!b.model.readData("hasRegisteredCallback")) {
            b.fireEvent("view:setCountUpCallback", b.countUpCallback.bind(b));
            b.model.storeData("hasRegisteredCallback", true)
        }
        a.duration = c;
        a.fireEventsOnValue = [{value: a.to, event: "view:countUpComplete", scope: b}];
        b.progressiveWinCoinsElement.textContent = b.model.getProgressiveWinText();
        b.fireEvent("view:startCountUp", a)
    },
    showFreeSpinsLeft: function () {
        var a = this;
        a.freeSpinsLeftNumberElement.textContent = a.model.getFreeSpinsLeftText();
        a.show(a.freeSpinsLeft)
    },
    showAdditionalFreeSpinsWon: function () {
        var a = this;
        a.additionalFreeSpinsNumberElement.textContent = a.model.getAdditionalFreeSpinsWonText();
        a.show(a.additionalFreeSpinsWon)
    },
    showWinUpTo: function () {
        this.show(this.winUpTo)
    },
    show: function (b) {
        var c = this, a = c.model.readData("currentlyShowingElement");
        if (a !== b) {
            if (Sys.isDefined(a)) {
                c.hideElement(a)
            }
            c.showElement(b);
            c.model.storeData("currentlyShowingElement", b)
        }
    },
    hideElement: function (a) {
        a.el.style.visibility = "hidden"
    },
    showElement: function (a) {
        a.el.style.visibility = "visible"
    },
    onEnteringFreeSpinIntroState: function () {
    },
    onGameModeChanged: function () {
    }
};
Interface.Slots.CoinsFieldBaseView = Sys.extend(Core.View, Interface.Slots.CoinsFieldBaseView, "Interface.Slots.CoinsFieldBaseView");
Sys.ns("interface.Slots");
Interface.Slots.CoinsFieldMobileView = {
    BASE_CSS: "interface-coinsField_base interface-coinsField_mobile",
    PORTRAIT_CSS: "interface-coinsField_portrait_mobile",
    LANDSCAPE_CSS: "interface-coinsField_landscape_mobile",
    constructor: function () {
        Interface.Slots.CoinsFieldMobileView.superclass.constructor.apply(this, arguments)
    }
};
Interface.Slots.CoinsFieldMobileView = Sys.extend(Interface.Slots.CoinsFieldBaseView, Interface.Slots.CoinsFieldMobileView, "Interface.Slots.CoinsFieldMobileView");
Sys.ns("Interface.Slots");
Interface.Slots.CoinsFieldDesktopView = {
    GAME_MODES: ["BASIC", "FREESPIN"],
    BASIC_BET_LABEL: {
        font: "10px Verdana",
        fillstyle: "rgba( 255, 255, 255, 1 )",
        position: {x: 160, y: 615, width: 267, height: 133},
        alignment: {horizontal: "left", vertical: false}
    },
    BASIC_BET_VALUE: {
        font: "10px Verdana",
        fillstyle: "rgba( 255, 255, 255, 1 )",
        position: {x: 160, y: 643, width: 267, height: 133},
        alignment: {horizontal: "left", vertical: false}
    },
    BASIC_BALANCE_LABEL: {
        font: "10px Verdana",
        fillstyle: "rgba( 255, 255, 255, 1 )",
        position: {x: 1071, y: 615, width: 267, height: 133},
        alignment: {horizontal: "left", vertical: false}
    },
    BASIC_BALANCE_VALUE: {
        font: "10px Verdana",
        fillstyle: "rgba( 255, 255, 255, 1 )",
        position: {x: 1071, y: 643, width: 267, height: 133},
        alignment: {horizontal: "left", vertical: false}
    },
    BASIC_BACKGROUND: {image: "keypadBackground", position: {x: 7, y: 606, width: 1265, height: 84}},
    FREESPIN_BET_LABEL: {
        font: "10px Verdana",
        fillstyle: "rgba( 255, 255, 255, 1 )",
        position: {x: 25, y: 656, width: 100, height: 20},
        alignment: {horizontal: "right", vertical: false}
    },
    FREESPIN_BET_VALUE: {
        font: "10px Verdana",
        fillstyle: "rgba( 255, 255, 255, 1 )",
        position: {x: 133, y: 656, width: 267, height: 20},
        alignment: {horizontal: "left", vertical: false}
    },
    FREESPIN_BALANCE_LABEL: {
        font: "10px Verdana",
        fillstyle: "rgba( 255, 255, 255, 1 )",
        position: {x: 1000, y: 656, width: 100, height: 20},
        alignment: {horizontal: "right", vertical: false}
    },
    FREESPIN_BALANCE_VALUE: {
        font: "10px Verdana",
        fillstyle: "rgba( 255, 255, 255, 1 )",
        position: {x: 1107, y: 656, width: 267, height: 20},
        alignment: {horizontal: "left", vertical: false}
    },
    FREESPIN_WIN_LABEL: {
        font: "15px Verdana",
        fillstyle: "rgba( 255, 255, 255, 1 )",
        position: {x: 530, y: 580, width: 120, height: 40},
        alignment: {horizontal: "right", vertical: true}
    },
    FREESPIN_WIN_VALUE: {
        font: "22px Verdana",
        fillstyle: "rgba( 255, 255, 255, 1 )",
        position: {x: 663, y: 580, width: 150, height: 40},
        alignment: {horizontal: "left", vertical: true}
    },
    FREESPIN_TOTAL_WIN_LABEL: {
        font: "15px Verdana",
        fillstyle: "rgba( 255, 255, 255, 1 )",
        position: {x: 530, y: 623, width: 120, height: 40},
        alignment: {horizontal: "right", vertical: true}
    },
    FREESPIN_TOTAL_WIN_VALUE: {
        font: "22px Verdana",
        fillstyle: "rgba( 255, 255, 255, 1 )",
        position: {x: 663, y: 623, width: 150, height: 40},
        alignment: {horizontal: "left", vertical: true}
    },
    FREESPIN_BACKGROUND: {image: "keypadFreeSpinBackground", position: {x: 429, y: 567, width: 421, height: 114}},
    constructor: function () {
        Interface.Slots.CoinsFieldDesktopView.superclass.constructor.apply(this, arguments)
    },
    initAnimations: function () {
        var a = this;
        a.initBackground();
        a.initTexts();
        a.onGameModeChanged("BASIC")
    },
    initBackground: function () {
        var h = this, c = h.getKeypadLayering(), g = new Animation.List({}), a = {}, b = h.GAME_MODES, e, d, f, j;
        for (d = -1, f = b.length; ++d < f;) {
            e = b[d];
            j = h[e + "_BACKGROUND"].position;
            a[b[d]] = new Animation.Item({
                top: j.y,
                left: j.x,
                width: j.width,
                height: j.height,
                depth: c["background_" + e.toLowerCase()],
                image: h[e + "_BACKGROUND"].image
            });
            g.add(a[b[d]])
        }
        Game.stage.view.addToRenderLoop(g);
        h.backgroundItems = a
    },
    getKeypadLayering: function () {
        return Layering.Game.Slots.Keypad
    },
    getMainTypes: function () {
        var a = this;
        return {
            BET: {
                LABEL: {
                    defaultMode: "FREESPIN", content: function () {
                        return Services.languageManager.getText(Language.Keys.machinetext_bet)
                    }
                }, VALUE: {
                    defaultMode: "FREESPIN", content: function () {
                        return a.model.getBetText()
                    }
                }
            }, BALANCE: {
                LABEL: {
                    defaultMode: "FREESPIN", content: function () {
                        return Services.languageManager.getText(Language.Keys.machinetext_coins)
                    }
                }, VALUE: {
                    defaultMode: "FREESPIN", content: function () {
                        return a.model.getBalanceText()
                    }
                }
            }, WIN: {
                LABEL: {
                    modes: ["FREESPIN"], defaultMode: "FREESPIN", content: function () {
                        return Services.languageManager.getText(Language.Keys.winColon_uc)
                    }
                }, VALUE: {
                    modes: ["FREESPIN"], defaultMode: "FREESPIN", content: function () {
                        return a.model.getWinText()
                    }
                }
            }, TOTAL_WIN: {
                LABEL: {
                    modes: ["FREESPIN"], defaultMode: "FREESPIN", content: function () {
                        return Services.languageManager.getText(Language.Keys.totalWinColon_uc)
                    }
                }, VALUE: {
                    modes: ["FREESPIN"], defaultMode: "FREESPIN", content: function () {
                        return a.model.getTotalWinText()
                    }
                }
            }
        }
    },
    initTexts: function () {
        var f = this, g = new Animation.List({}), d = f.GAME_MODES, a = d.length, e = {}, c, b;
        for (b = -1; ++b < a;) {
            c = d[b];
            e[c] = f.getTextsForGameMode(c, g)
        }
        f.textItems = e;
        f.updateTexts();
        Game.stage.view.addToRenderLoop(g)
    },
    getTextsForGameMode: function (k, f) {
        var h = this, b = h.getKeypadLayering(), g = h.getMainTypes(), j = Object.keys(g), d = j.length, a = {}, e, c;
        for (c = -1; ++c < d;) {
            e = j[c];
            a[e] = h.createTextItems(e, g[e], b[e.toLowerCase()], f, k)
        }
        return a
    },
    createTextItems: function (j, f, s, o, k) {
        var q = this, c = {}, l, b, a, g, h, t = Object.keys(f), n = t.length, e, r, p, d, m;
        for (m = -1; ++m < n;) {
            e = t[m];
            l = f[e];
            b = Sys.isDefined(l.defaultMode) ? l.defaultMode : false;
            a = k + "_" + j + "_" + e;
            g = b + "_" + j + "_" + e;
            r = Sys.isDefined(q[a]) ? q[a].position : q[g].position;
            h = q.getAlignment(a, g);
            if (Sys.isObj(l) && Sys.isArray(l.modes)) {
                if (l.modes.contains(k)) {
                    l = l.content
                } else {
                    continue
                }
            }
            p = this.initTextItem(r.width, r.height, r.x, r.y, s, b, h);
            d = (typeof l === "function") ? l : l.content;
            c[e] = {item: p, valueFunction: d};
            o.add(p);
            p.stop()
        }
        return c
    },
    updateTexts: function () {
        var d = this, c = d.GAME_MODES, e = d.model.readData("gameMode"), a = c.length, b;
        if (Sys.isDefined(d.textItems)) {
            for (b = -1; ++b < a;) {
                d.updateMainTypesTexts(d.textItems[c[b]], e, (c[b] === e))
            }
        }
    },
    updateMainTypesTexts: function (a, d, b) {
        var g = Object.keys(a), f = g.length, e, c;
        for (c = -1; ++c < f;) {
            e = g[c];
            this.updateSubTypeTexts(a[e], d, b, e)
        }
    },
    updateSubTypeTexts: function (h, j, f, e) {
        var n = this, k = Object.keys(h), r = k.length, p, m, q, b, g, a, d, c, o, l;
        for (g = -1; ++g < r;) {
            p = k[g];
            m = h[p];
            q = m.item;
            b = q.prop;
            a = j + "_" + e + "_" + p;
            d = b.customProps.defaultMainType + "_" + e + "_" + p;
            c = (Sys.isDefined(n[a]) ? n[a].font : n[d].font);
            o = (Sys.isDefined(n[a]) ? n[a].fillstyle : n[d].fillstyle);
            l = n.getAlignment(a, d);
            if (f) {
                n.updateTextItem(q, m.valueFunction.call(n), c, o, l);
                if (!q.prop.running) {
                    q.play()
                }
            } else {
                q.stop()
            }
        }
    },
    initTextItem: function (a, i, g, f, c, h, d) {
        var e = this, b = e.getInMemoryCanvas(a, i);
        if (Sys.isDefined(d)) {
            b.ctx.textAlign = d.horizontal
        }
        return new Animation.Item({
            top: f,
            left: g,
            width: a,
            height: i,
            depth: c,
            image: b.canvas,
            customProps: {inMemCanvas: b, defaultMainType: h, alignment: d}
        })
    },
    updateTextItem: function (l, b, c, k, e, i) {
        var a = l.prop, h = Sys.isDefined(e) ? e : {horizontal: "left", vertical: false},
            g = h.horizontal === "right" ? a.width : 0, d = a.customProps.inMemCanvas,
            f = Animation.utils.text.measureText(b.toString(), c, 0, d.ctx).height / 2, j = Sys.isDefined(i) ? i : 20;
        d.ctx.clearRect(0, 0, d.canvas.width, d.canvas.height);
        Animation.utils.text.wrapCanvasText(b.toString(), c, g, f, a.width, j, [{
            fillStyle: k,
            drawType: "fill"
        }], d.ctx, h.vertical)
    },
    getInMemoryCanvas: function (d, a) {
        var c = document.createElement("canvas"), b = c.getContext("2d");
        c.width = d;
        c.height = a;
        return {canvas: c, ctx: b}
    },
    showBalanceAndBet: function () {
        this.updateTexts()
    },
    showWin: function () {
        this.updateTexts()
    },
    onGameModeChanged: function (g) {
        var f = this, b = f.backgroundItems, d = f.GAME_MODES, c, e, a;
        for (c = -1, a = d.length; ++c < a;) {
            e = b[d[c]];
            if (d[c] === g) {
                e.play()
            } else {
                e.stop()
            }
        }
        this.updateTexts()
    },
    showProgressiveWin: function () {
        this.updateTexts()
    },
    getAlignment: function (b, a) {
        var c = this;
        return Sys.isDefined(c[b]) ? c[b].alignment : c[a].alignment
    },
    countUpCallback: function () {
    },
    countUpProgressiveWin: function () {
        this.fireEvent("view:countUpComplete")
    },
    showFreeSpinsLeft: function () {
    },
    showAdditionalFreeSpinsWon: function () {
    },
    showWinUpTo: function () {
    },
    show: function () {
    },
    hideElement: function () {
    },
    showElement: function () {
    },
    setupView: function () {
    }
};
Interface.Slots.CoinsFieldDesktopView = Sys.extend(Interface.Slots.CoinsFieldBaseView, Interface.Slots.CoinsFieldDesktopView, "Interface.Slots.CoinsFieldDesktopView");
Sys.ns("Interface");
Interface.SettingsWindow = {
    constructor: function () {
        Interface.SettingsWindow.superclass.constructor.apply(this, arguments)
    }, getDefaultMVCClasses: function () {
        return {
            controller: Interface.SettingsWindowController,
            model: Interface.SettingsWindowModel,
            view: Interface.SettingsWindowBaseView
        }
    }, getMixinDependencies: function () {
        return ["orientation"]
    }
};
Interface.SettingsWindow = Sys.extend(Core.Module, Interface.SettingsWindow, "Interface.SettingsWindow");
Sys.ns("Interface");
Interface.SettingsWindowController = {
    constructor: function () {
        Interface.SettingsWindowController.superclass.constructor.apply(this, arguments)
    }, setupEvents: function () {
        var a = this;
        a.on({
            "view:opened": a.opened,
            "view:close": a.onCloseRequest,
            "view:closed": a.closed,
            "request:settingsWindow.open": a.onOpenRequest,
            "request:settingsWindow.close": a.onCloseRequest,
            "request:settingsWindow.openChild": a.onOpenChildRequest,
            "request:settingsWindow.closeChild": a.onCloseChildRequest,
            "request:settingsWindow.addChild": a.addChild,
            "request:settingsWindow.removeChild": a.removeChild,
            "request:settingsWindow.activateChild": a.activateChild,
            "request:settingsWindow.deactivateChild": a.deactivateChild
        })
    }, onOpenRequest: function () {
        var a = this;
        if (!a.model.readData("open")) {
            a.open(this.model.readData("currentlyShowingChild"))
        }
    }, onOpenChildRequest: function (d, a) {
        var b = this, c = b.model.isActiveChild(d);
        if (c) {
            if (!b.model.readData("open")) {
                b.open(d, a)
            } else {
                b.openChild(d, a)
            }
        }
    }, onCloseRequest: function () {
        var a = this;
        if (a.model.readData("open")) {
            a.close()
        }
    }, onCloseChildRequest: function (b) {
        var a = this;
        if (b === a.model.readData("currentlyShowingChild")) {
            a.close()
        }
    }, open: function (c, a) {
        var b = this;
        b.model.storeData("open", true);
        b.view.open();
        if (Sys.isDefined(c)) {
            b.openChild(c, a)
        }
    }, openChild: function (a, c) {
        var d = this, b = d.model.readData("currentlyShowingChild");
        if (b !== a) {
            d.model.storeData("currentlyShowingChild", a);
            d.closeChild(b)
        }
        d.fireEvent("notify:settingsWindow.openedChild", a, c);
        d.view.showChild(a)
    }, close: function () {
        var a = this;
        a.model.storeData("open", false);
        a.closeChild(a.model.readData("currentlyShowingChild"));
        a.view.close()
    }, closeChild: function (a) {
        this.fireEvent("notify:settingsWindow.closedChild", a)
    }, opened: function () {
        this.fireEvent("notify:settingsWindow.open")
    }, closed: function () {
        this.fireEvent("notify:settingsWindow.closed")
    }, addChild: function (b, a) {
        this.model.addChild(b, a);
        this.view.addChild(a)
    }, removeChild: function (a) {
        this.view.removeChild(a);
        this.model.removeChild(a)
    }, activateChild: function (a) {
        this.model.activateChild(a)
    }, deactivateChild: function (a) {
        this.model.deactivateChild(a)
    }
};
Interface.SettingsWindowController = Sys.extend(Core.Controller, Interface.SettingsWindowController, "Interface.SettingsWindowController");
Sys.ns("Interface");
Interface.SettingsWindowModel = {
    constructor: function () {
        Interface.SettingsWindowModel.superclass.constructor.apply(this, arguments)
    }, addChild: function (c, a) {
        var b = this.readData("children");
        if (!Sys.isDefined(b[c])) {
            b[c] = {active: true, config: a}
        }
    }, removeChild: function (a) {
        delete this.readData("children")[a]
    }, isActiveChild: function (a) {
        var b = this.readData("children")[a];
        return Sys.isDefined(b) && b.active
    }, getChildConfig: function (a) {
        return this.readData("children")[a].config
    }, activateChild: function (a) {
        var b = this.readData("children")[a];
        if (!Sys.isDefined(b)) {
            b.active = true
        }
    }, deactivateChild: function (a) {
        var b = this.readData("children")[a];
        if (!Sys.isDefined(b)) {
            b.active = false
        }
    }, setupData: function () {
        this.storeData("children", {});
        this.storeData("open", false)
    }
};
Interface.SettingsWindowModel = Sys.extend(Core.Model, Interface.SettingsWindowModel, "Interface.SettingsWindowModel");
Sys.ns("Interface");
Interface.SettingsWindowBaseView = {
    BASE_CSS: "interface-settingsWindow_base",
    PORTRAIT_CSS: "interface-settingsWindow_portrait",
    LANDSCAPE_CSS: "interface-settingsWindow_landscape",
    HEADER_CSS: "interface-settingsWindow_header interface-settingsSection_subSection_uri",
    CONTENT_CSS: "interface-settingsWindow_content",
    RENDER_TARGET: "gameWrapper",
    constructor: function () {
        Interface.SettingsWindowBaseView.superclass.constructor.apply(this, arguments)
    },
    open: function () {
        this.container.el.style.display = "block";
        this.fireEvent("view:opened")
    },
    close: function () {
        this.container.el.style.display = "none";
        this.fireEvent("view:closed")
    },
    adaptToOrientation: function (a) {
        this.setStyle(a)
    },
    addChild: function (a) {
        this.content.add(a.content)
    },
    removeChild: function (a) {
        this.content.remove(this.model.getChildConfig(a).content)
    },
    showChild: function (a) {
        if (Environment.orientation() === "portrait") {
            this.open()
        }
        this.setTitle(this.model.getChildConfig(a).title)
    },
    init: function () {
        var a = this;
        Interface.SettingsWindowBaseView.superclass.init.apply(a, arguments);
        a.closeAnimation = {};
        a.openAnimation = {};
        a.setupDOMStructure()
    },
    setupDOMStructure: function () {
        var a = this;
        a.container = new Sys.Element({id: "settingsWindow", tag: "div", cls: a.BASE_CSS, renderTo: a.RENDER_TARGET});
        a.header = a.container.add(new Sys.Element({id: "settingsWindowHeader", tag: "div", cls: a.HEADER_CSS}));
        a.content = a.container.add(new Sys.Element({id: "settingsWindowContent", tag: "div", cls: a.CONTENT_CSS}))
    },
    setupEvents: function () {
        var a = this;
        a.on({"model:childAdded": a.addChild, "model:childRemoved": a.removeChild, "model:showChild": a.showChild})
    },
    removeAnimations: function () {
        var a = this;
        if (Sys.isDefined(a.openAnimation.LANDSCAPE)) {
            a.openAnimation.LANDSCAPE.removeAnimation(a.container.el)
        }
        if (Sys.isDefined(a.openAnimation.PORTRAIT)) {
            a.openAnimation.PORTRAIT.removeAnimation(a.container.el)
        }
    },
    setTitle: function (a) {
        this.header.el.textContent = a
    }
};
Interface.SettingsWindowBaseView = Sys.extend(Core.View, Interface.SettingsWindowBaseView, "Interface.SettingsWindowBaseView");
Sys.ns("Interface");
Interface.SettingsWindowMobileView = {
    PORTRAIT_CSS: "interface-settingsWindow_portrait_mobile",
    LANDSCAPE_CSS: "interface-settingsWindow_landscape_mobile",
    constructor: function () {
        Interface.SettingsWindowMobileView.superclass.constructor.apply(this, arguments)
    },
    adaptToOrientation: function (a) {
        Interface.SettingsWindowMobileView.superclass.adaptToOrientation.call(this, a);
        this.setHeight(a)
    },
    setHeight: function (a) {
        if (a === "PORTRAIT") {
            this.container.el.style.height = (Environment.getGameHeight() + Environment.getSpaceBelowGame()) + "px"
        } else {
            this.container.el.style.height = ""
        }
    }
};
Interface.SettingsWindowMobileView = Sys.extend(Interface.SettingsWindowBaseView, Interface.SettingsWindowMobileView, "Interface.SettingsWindowMobileView");
Sys.ns("Interface");
Interface.SettingsWindowDesktopView = {
    BASE_CSS: "interface-settingsWindow_base",
    LANDSCAPE_CSS: "interface-settingsWindow_landscape_desktop",
    CLOSE_BUTTON_CSS: "interface-settingsWindow_desktop_closeButton interface-settingsWindow_closeButton_uri",
    constructor: function () {
        Interface.SettingsWindowDesktopView.superclass.constructor.apply(this, arguments)
    },
    setupDOMStructure: function () {
        var a = this;
        Interface.SettingsWindowDesktopView.superclass.setupDOMStructure.apply(a, arguments);
        a.closeButton = new Interface.utils.DOMButton({
            id: "settingsWindowCloseButton",
            baseCSS: a.CLOSE_BUTTON_CSS,
            clickCallback: a.fireEvent.bind(a, "view:close"),
            enabled: false
        });
        a.container.add(a.closeButton.getContainer())
    },
    open: function () {
        Interface.SettingsWindowDesktopView.superclass.open.apply(this, arguments);
        this.closeButton.enable("sectionClosed")
    },
    close: function () {
        Interface.SettingsWindowDesktopView.superclass.close.apply(this, arguments);
        this.closeButton.disable("sectionClosed")
    }
};
Interface.SettingsWindowDesktopView = Sys.extend(Interface.SettingsWindowBaseView, Interface.SettingsWindowDesktopView, "Interface.SettingsWindowDesktopView");
Sys.ns("Interface");
Interface.SettingsMenu = {
    constructor: function () {
        Interface.SettingsMenu.superclass.constructor.apply(this, arguments)
    }, getDefaultMVCClasses: function () {
        return {
            controller: Interface.SettingsMenuController,
            model: Interface.SettingsMenuModel,
            view: Interface.SettingsMenuBaseView
        }
    }, getMixinDependencies: function () {
        return ["userInput", "orientation"]
    }
};
Interface.SettingsMenu = Sys.extend(Core.Module, Interface.SettingsMenu, "Interface.SettingsMenu");
Sys.ns("Interface");
Interface.SettingsMenuController = {
    constructor: function () {
        Interface.SettingsMenuController.superclass.constructor.apply(this, arguments);
        this.deactivatedAtSpinStart = true
    }, setupEvents: function () {
        var a = this;
        a.on({
            "request:settingsMenu.open": a.onOpenRequest,
            "request:settingsMenu.close": a.onCloseRequest,
            "request:settingsMenu.addChild": a.addChild,
            "request:settingsMenu.removeChild": a.removeChild,
            "request:settingsMenu.activateChild": a.activateChild,
            "request:settingsMenu.deactivateChild": a.deactivateChild,
            "notify:stateHandler.enteringIdleState": a.activateChildrenAfterSpin,
            "notify:stateHandler.leavingIdleState": a.deactivateChildrenDuringSpin,
            "notify:moduleLoader.finishedLoadingModules": a.onModulesFinishedLoading,
            "notify:stateHandler.leavingBeforeLoaderCloseState": a.onBeforeLoaderFinished,
            "view:contentChanged": a.onContentChangedInView,
            "view:contentClosed": a.onContentClosedInView
        })
    }, onBeforeLoaderFinished: function () {
        var a = this;
        a.model.storeData("loaderFinished", true);
        if (!a.model.readData("determinedChildSize")) {
            a.view.onBeforeLoaderFinished()
        }
    }, onModulesFinishedLoading: function () {
        if (this.model.readData("alwaysOpen") === true) {
            this.open()
        }
    }, onOpenRequest: function (a) {
        var e = this, b = e.model.readData("open"), d = e.view.canOpenWithoutSelection(),
            c = e.model.readData("lastSelectedChild"), f = Sys.isDefined(c);
        if (!f) {
            c = e.model.readData("defaultChild");
            f = Sys.isDefined(c)
        }
        if (!b && (d || (a && f))) {
            e.open();
            if (a && f) {
                e.select(c)
            }
        }
    }, onCloseRequest: function () {
        var a = this;
        if (a.model.readData("open")) {
            a.close();
            a.deselectCurrentChild()
        }
    }, open: function () {
        var a = this;
        a.startListeningToUserInput();
        a.model.storeData("open", true);
        a.view.open();
        a.fireEvent("notify:settingsMenu.open")
    }, close: function () {
        var a = this;
        a.stopListeningToUserInput();
        a.view.close();
        a.model.storeData("open", false);
        a.fireEvent("notify:settingsMenu.closed")
    }, select: function (a) {
        this.view.selectChildByName(a)
    }, deselectCurrentChild: function () {
        this.view.deselectCurrentChild()
    }, addChild: function (c, a) {
        var b = this;
        b.addListener("notify:" + c + ".shown", b.onChildOpened.bind(b, c));
        b.addListener("notify:" + c + ".hidden", b.onChildClosed.bind(b, c));
        b.model.addChild(c, a);
        b.view.addChild(c)
    }, onChildOpened: function (a) {
        if (!this.model.readData("open")) {
            this.open()
        }
        this.select(a)
    }, onChildClosed: function (a) {
        if (this.model.readData("currentlySelectedChild") === a) {
            this.deselectCurrentChild()
        }
    }, removeChild: function (b) {
        var a = this;
        a.removeListener("notify:" + b + ".shown");
        a.removeListener("notify:" + b + ".hidden");
        a.view.removeChild(b);
        a.model.removeChild(b)
    }, activateChild: function (a) {
        this.model.activateChild(a)
    }, deactivateChild: function (a) {
        this.model.deactivateChild(a)
    }, activateChildrenAfterSpin: function () {
        this.model.storeData("inIdleState", true);
        if (this.deactivatedAtSpinStart) {
            this.deactivatedAtSpinStart = false;
            this.toggleChildrenDuringSpin(true)
        }
    }, deactivateChildrenDuringSpin: function () {
        this.model.storeData("inIdleState", false);
        this.deactivatedAtSpinStart = true;
        this.toggleChildrenDuringSpin(false)
    }, toggleChildrenDuringSpin: function (e) {
        var a = this.model.getChildrenDisabledDuringSpins(), d = a.length,
            c = (e) ? "activateChild" : "deactivateChild", b;
        for (b = -1; ++b < d;) {
            a[b].active = (e && a[b].active);
            this.view[c](a[b])
        }
    }, onPortrait: function () {
        this.view.onPortrait()
    }, onLandscape: function () {
        this.view.onLandscape()
    }, onUserInputStart: function (a) {
        if (this.model.readData("open")) {
            this.view.onUserInputStart(a)
        }
    }, onUserInputMove: function (a) {
        if (this.model.readData("open")) {
            this.view.onUserInputMove(a)
        }
    }, onUserInputEnd: function (a) {
        if (this.model.readData("open")) {
            this.view.onUserInputEnd(a)
        }
    }, onContentChangedInView: function (a) {
        this.model.storeData("currentlySelectedChild", a);
        if (Sys.isString(a)) {
            this.fireEvent("request:" + a + ".show")
        }
    }, onContentClosedInView: function (c) {
        var b = this, a = b.model;
        a.storeData("lastSelectedChild", c);
        if (a.readData("currentlySelectedChild") === c) {
            a.storeData("currentlySelectedChild", undefined);
            if (!b.view.canOpenWithoutSelection()) {
                b.close()
            }
        }
        if (Sys.isString(c)) {
            b.fireEvent("request:" + c + ".hide")
        }
    }
};
Interface.SettingsMenuController = Sys.extend(Core.Controller, Interface.SettingsMenuController, "Interface.SettingsMenuController");
Sys.ns("Interface");
Interface.SettingsMenuModel = {
    constructor: function () {
        Interface.SettingsMenuModel.superclass.constructor.apply(this, arguments)
    }, addChild: function (f, c) {
        var e = this, d = e.readData("children"), b = e.readData("disableDuringSpin"), a = Sys.isDefined(c) ? c : {};
        if (!Sys.isDefined(d[f])) {
            d[f] = {
                name: f,
                active: false,
                order: a.order,
                accessibleDuringSpins: a.accessibleDuringSpins,
                toggleOnSelection: (a.toggleOnSelection === true)
            };
            if (Sys.isDefined(a.isDefault) && a.isDefault) {
                e.storeData("defaultChild", f)
            }
            if (!Sys.isDefined(a.accessibleDuringSpins) || !a.accessibleDuringSpins) {
                b.push(d[f])
            }
        }
    }, removeChild: function (e) {
        var d = this.readData("children"), c = d[e], a = this.readData("disableDuringSpin"), b = a.indexOf(c);
        if (!Sys.isDefined(c)) {
            if (b >= 0) {
                a.splice(b, 1)
            }
            delete (d[e])
        }
    }, activateChild: function (d) {
        var b = this, a = b.readData("children")[d], c = b.getChildrenDisabledDuringSpins();
        if (Sys.isDefined(a)) {
            if (c.contains(a)) {
                a.accessibleDuringSpins = true;
                c = c.splice(c.indexOf(a), 1);
                b.storeData("disableDuringSpin", c)
            }
            a.active = true;
            b.fireEvent("model:childActivated", a)
        }
    }, deactivateChild: function (d) {
        var b = this, a = b.readData("children")[d], c = b.getChildrenDisabledDuringSpins();
        if (Sys.isDefined(a)) {
            if (!c.contains(a)) {
                a.accessibleDuringSpins = false;
                c.push(a);
                b.storeData("disableDuringSpin", c)
            }
            a.active = false;
            b.fireEvent("model:childDeactivated", a)
        }
    }, getChildrenDisabledDuringSpins: function () {
        return this.readData("disableDuringSpin")
    }, setupData: function () {
        var a = this;
        a.storeData("children", {});
        a.storeData("disableDuringSpin", []);
        a.storeData("status", "closed");
        if (Environment.getCurrentPlatform() === "desktop") {
            a.storeData("alwaysOpen", true)
        }
    }
};
Interface.SettingsMenuModel = Sys.extend(Core.Model, Interface.SettingsMenuModel, "Interface.SettingsMenuModel");
Sys.ns("Interface");
Interface.SettingsMenuBaseView = {
    BASE_CSS: "interface-settingsMenu_base",
    PORTRAIT_CSS: "interface-settingsMenu_portrait",
    LANDSCAPE_CSS: "interface-settingsMenu_landscape",
    CHILDREN_CSS: "interface-settingsMenu_children",
    CHILD_CSS: "interface-settingsMenu_child_base",
    RENDER_TARGET: "gameWrapper",
    START_INDEX: 2,
    CAN_OPEN_WITHOUT_SELECTION: false,
    constructor: function () {
        Interface.SettingsMenuBaseView.superclass.constructor.apply(this, arguments)
    },
    open: function () {
        var c = this, b = c.childElements.getChildren().length, a = Environment.orientation();
        c.container.el.style.display = "block";
        if (b > 0 && c.totalChildWidth === 0) {
            c.adaptToOrientation(a)
        }
    },
    canOpenWithoutSelection: function () {
        return this.CAN_OPEN_WITHOUT_SELECTION
    },
    close: function () {
        this.container.el.style.display = "none"
    },
    onUserInputStart: function (c) {
        var b = this, a = Sys.UserInputUtils.isCoordinateTarget(b.container.el, c);
        if (a) {
            b.distanceSinceUserInputStart = 0;
            b.prevX = c.x;
            b.scroller.doTouchStart([{pageX: c.x, pageY: c.y}], Date.now())
        }
        b.wasInitialInputTarget = a;
        if (a && !b.shouldScroll) {
            b.onUserInputEnd(c)
        }
    },
    onUserInputMove: function (b) {
        var a = this;
        if (a.wasInitialInputTarget) {
            a.distanceSinceUserInputStart += Math.abs(a.prevX - b.x);
            a.prevX = b.x;
            a.scroller.doTouchMove([{pageX: b.x, pageY: b.y}], Date.now())
        }
    },
    onUserInputEnd: function (d) {
        var c = this, e, b, a;
        if (c.wasInitialInputTarget) {
            c.scroller.doTouchEnd(Date.now());
            if (c.distanceSinceUserInputStart < 10) {
                a = Sys.UserInputUtils.getCoordinatesRelativeToElement(d, c.childElements.el).x;
                b = c.getIndexFromPosition(a);
                e = c.getChildFromElement(c.childElements.getChildren()[b]);
                if (Sys.isDefined(e) && e.name === c.model.readData("currentlySelectedChild")) {
                    if (e.toggleOnSelection) {
                        c.deselectCurrentChild()
                    }
                    c.snapToIndex(b)
                } else {
                    c.selectChild(e, b)
                }
            }
        }
        c.wasInitialInputTarget = false
    },
    selectChildByName: function (a) {
        var b = this, c = b.model.readData("children")[a];
        if (a !== b.model.readData("currentlySelectedChild") && Sys.isDefined(c)) {
            b.selectChild(c, b.getChildIndex(c))
        }
    },
    deselectCurrentChild: function () {
        var b = this, a = b.model.readData("children"), c = a[b.model.readData("currentlySelectedChild")];
        if (Sys.isDefined(c)) {
            b.deselectChild(c)
        }
    },
    adaptToOrientation: function (c) {
        var f = this, d, g, b, e, a;
        f.setStyle(c);
        d = f.model.readData("children");
        g = d[f.model.readData("currentlySelectedChild")];
        b = f.getChildIndex(g);
        e = f.scrollerWrapper.el.clientWidth;
        f.determineChildSize();
        if (Object.keys(d).length > 0 && f.totalChildWidth === 0) {
            return
        }
        f.menuWidth = e;
        f.scroller.setPosition(Math.round(Math.abs(e - f.totalChildWidth)), 0);
        f.scroller.setDimensions(e, 10, f.totalChildWidth + e - f.childWidth, 10);
        if (f.totalChildWidth > e) {
            a = b >= 0 ? b * f.childWidth : f.START_INDEX * f.childWidth;
            f.toggleFade(true);
            f.padding = Math.round((e - f.childWidth) / 2);
            f.shouldScroll = true;
            f.useScrollOffset = true;
            f.childElements.el.style.left = 0;
            f.scroller.scrollTo(a, 0, false)
        } else {
            f.toggleFade(false);
            f.padding = 0;
            f.useScrollOffset = false;
            f.scroller.scrollTo(0, 0, false);
            f.childElements.el.style.left = Math.round((e - f.totalChildWidth) / 2) + "px";
            f.shouldScroll = false
        }
    },
    selectChild: function (d, a) {
        var c = this, b = c.model.readData("children")[c.model.readData("currentlySelectedChild")];
        d.element.addCls("selected");
        c.snapToIndex(a);
        c.fireEvent("view:contentChanged", d.name);
        if (Sys.isDefined(b)) {
            c.deselectChild(b)
        }
    },
    deselectChild: function (a) {
        a.element.removeCls("selected");
        this.fireEvent("view:contentClosed", a.name)
    },
    snapToIndex: function (a) {
        this.scroller.scrollTo(Math.round(a * this.childWidth), 0, true)
    },
    getIndexFromPosition: function (a) {
        var c = Math.floor(a / this.childWidth), b = this.childElements.getChildren().length;
        if (c < 0) {
            c = 0
        } else {
            if (c >= b) {
                c = b - 1
            }
        }
        return c
    },
    init: function () {
        var a = this;
        Interface.SettingsMenuBaseView.superclass.init.apply(a, arguments);
        a.childWidth = 0;
        a.totalChildWidth = 0;
        a.menuWidth = 0;
        a.distanceSinceUserInputStart = 0;
        a.closeAnimation = {};
        a.openAnimation = {};
        a.padding = 0;
        a.prevX = 0;
        a.x = 0;
        a.useScrollOffset = false;
        a.shouldScroll = true;
        a.setupDOMStructure()
    },
    setupEvents: function () {
        var a = this;
        a.on({"model:childActivated": a.activateChild, "model:childDeactivated": a.deactivateChild})
    },
    toggleFade: function (a) {
        var b = (a) ? "block" : "none";
        this.leftFade.el.style.display = b;
        this.rightFade.el.style.display = b
    },
    determineChildSize: function () {
        var c = this, e = c.childElements.getChildren(), d = e.length, a, b;
        if (d === 0) {
            return
        }
        b = Math.ceil(Math.ceil(e[0].getBoundingClientRect().width) * (1 / Environment.scale));
        a = b * d;
        if (c.totalChildWidth !== a) {
            c.childElements.el.style.width = a + "px"
        }
        c.totalChildWidth = a;
        c.childWidth = b
    },
    addChild: function (b) {
        var d = this, e = d.model.readData("children")[b], c = this.createChild(e.name), a = d.getNextClosestSibling(e);
        e.left = d.childWidth * e.order;
        e.element = c;
        if (Sys.isDefined(a)) {
            d.childElements.addBefore(c, a.element)
        } else {
            d.childElements.add(c)
        }
        d.determineChildSize()
    },
    removeChild: function (a) {
        var b = this, c = b.model.readData("children")[a];
        if (Sys.isDefined(c)) {
            b.childElements.remove(c.element);
            b.determineChildSize()
        }
    },
    activateChild: function (a) {
        a.element.removeCls("deactivated")
    },
    deactivateChild: function (a) {
        a.element.addCls("deactivated")
    },
    setupDOMStructure: function () {
        var a = this;
        a.container = new Sys.Element({tag: "div", cls: a.BASE_CSS, renderTo: a.RENDER_TARGET});
        a.touchArea = a.container.add(new Sys.Element({tag: "div", cls: "interface-settingsMenu_touchArea"}));
        a.leftFade = a.container.add(new Sys.Element({
            tag: "div",
            cls: "interface-settingsMenu_leftFade interface-settingsMenu_fade_uri"
        }));
        a.rightFade = a.container.add(new Sys.Element({
            tag: "div",
            cls: "interface-settingsMenu_rightFade interface-settingsMenu_fade_uri"
        }));
        a.scrollerWrapper = a.container.add(new Sys.Element({
            tag: "div",
            cls: "interface-settingsMenu_scrollerWrapper"
        }));
        a.childElements = a.scrollerWrapper.add(new Sys.Element({tag: "ul", cls: a.CHILDREN_CSS}));
        a.scroller = new Scroller(a.scrollCallback.bind(a), {
            scrollingY: false,
            speedMultiplier: 1.5 / Number(Environment.getScale())
        })
    },
    scrollCallback: function (d, c) {
        var a = this, b = (a.useScrollOffset) ? ((a.menuWidth - a.childWidth) / 2) : 0;
        if (a.shouldScroll) {
            a.childElements.el.style[Sys.utils.pollyFill("transform")] = "translate(" + Math.round(-d + b) + "px, " + (-c) + "px)";
            a.x = -d
        }
    },
    createChild: function (c) {
        var b = this, a = new Sys.Element({tag: "li", cls: b.CHILD_CSS});
        a.add(new Sys.Element({
            tag: "div",
            cls: "interface-settingsMenu_child_image interface-settingsMenu_child_" + c + "_uri"
        }));
        return a
    },
    onPortrait: function () {
        this.adaptToOrientation("PORTRAIT")
    },
    onLandscape: function () {
        this.adaptToOrientation("LANDSCAPE")
    },
    getChildIndex: function (a) {
        if (Sys.isDefined(a)) {
            return this.childElements.getChildren().indexOf(a.element.el)
        }
        return -1
    },
    getChildFromElement: function (b) {
        var a = this.model.readData("children"), c;
        Sys.iterate(a, function (d, e) {
            if (e.element.el === b) {
                c = e;
                return false
            }
            return undefined
        });
        return c
    },
    getNextClosestSibling: function (c) {
        var b = this.model.readData("children"), a;
        Sys.iterate(b, function (d, e) {
            if (e !== c && (e.order > c.order && (!Sys.isDefined(a) || e.order < a.order))) {
                a = e
            }
        });
        return a
    },
    onBeforeLoaderFinished: function () {
    }
};
Interface.SettingsMenuBaseView = Sys.extend(Core.View, Interface.SettingsMenuBaseView, "Interface.SettingsMenuBaseView");
Sys.ns("Interface");
Interface.SettingsMenuMobileView = {
    PORTRAIT_CSS: "interface-settingsMenu_portrait_mobile",
    LANDSCAPE_CSS: "interface-settingsMenu_landscape_mobile",
    constructor: function () {
        Interface.SettingsMenuMobileView.superclass.constructor.apply(this, arguments)
    }
};
Interface.SettingsMenuMobileView = Sys.extend(Interface.SettingsMenuBaseView, Interface.SettingsMenuMobileView, "Interface.SettingsMenuMobileView");
Sys.ns("Interface");
Interface.DesktopSettingsMenu = {
    constructor: function () {
        Interface.DesktopSettingsMenu.superclass.constructor.apply(this, arguments)
    }, getDefaultMVCClasses: function () {
        return {controller: Interface.DesktopSettingsMenuController, view: Interface.DesktopSettingsMenuView}
    }
};
Interface.DesktopSettingsMenu = Sys.extend(Core.Module, Interface.DesktopSettingsMenu, "Interface.DesktopSettingsMenu");
Sys.ns("Interface");
Interface.DesktopSettingsMenuController = {
    constructor: function () {
        Interface.DesktopSettingsMenuController.superclass.constructor.apply(this, arguments)
    }, setupEvents: function () {
        var a = this;
        a.on({
            "request:desktopSettingsMenu.addChild": a.view.addChild.bind(a.view),
            "request:desktopSettingsMenu.removeChild": a.view.removeChild.bind(a.view)
        })
    }
};
Interface.DesktopSettingsMenuController = Sys.extend(Core.Controller, Interface.DesktopSettingsMenuController, "Interface.DesktopSettingsMenuController");
Sys.ns("Interface");
Interface.DesktopSettingsMenuView = {
    BASE_CSS: "interface-desktopSettingsMenu_base",
    CHILDREN_CSS: "interface-settingsMenu_children",
    CHILD_CSS: "interface-settingsMenu_child_desktop",
    RENDER_TARGET: "gameWrapper",
    constructor: function () {
        Interface.DesktopSettingsMenuView.superclass.constructor.apply(this, arguments)
    },
    init: function () {
        var a = this;
        Interface.DesktopSettingsMenuView.superclass.init.apply(a, arguments);
        a.childWidth = 0;
        a.setupDOMStructure();
        a.children = {}
    },
    setupDOMStructure: function () {
        var a = this;
        a.container = new Sys.Element({tag: "div", cls: a.BASE_CSS, renderTo: a.RENDER_TARGET});
        a.childElements = a.container.add(new Sys.Element({tag: "ul", cls: a.CHILDREN_CSS}))
    },
    addChild: function (c, b) {
        var d = this, e = d.createListItem(b.element), a;
        b.element = e;
        a = d.getNextClosestSibling(b);
        d.children[c] = b;
        if (Sys.isDefined(a)) {
            d.childElements.addBefore(e, a.element)
        } else {
            d.childElements.add(e)
        }
    },
    createListItem: function (a) {
        var c = this, b = new Sys.Element({tag: "li", cls: c.CHILD_CSS});
        b.add(a);
        return b
    },
    getNextClosestSibling: function (b) {
        var c = this.children, a;
        Sys.iterate(c, function (d, e) {
            if (e !== b && (e.order > b.order && (!Sys.isDefined(a) || e.order < a.order))) {
                a = e
            }
        });
        return a
    },
    removeChild: function (a) {
        var b = this, c = b.children[a];
        if (Sys.isDefined(c)) {
            b.childElements.remove(c.element)
        }
    }
};
Interface.DesktopSettingsMenuView = Sys.extend(Core.View, Interface.DesktopSettingsMenuView, "Interface.DesktopSettingsMenuView");
Sys.ns("Interface");
Interface.SettingsButton = {
    constructor: function () {
        Interface.SettingsButton.superclass.constructor.apply(this, arguments)
    }, getDefaultMVCClasses: function () {
        return {
            controller: Interface.SettingsButtonController,
            model: Interface.SettingsButtonModel,
            view: Interface.SettingsButtonBaseView
        }
    }, getMixinDependencies: function () {
        return [{userInput: {listenToUserInput: true}}, "orientation", "properties"]
    }
};
Interface.SettingsButton = Sys.extend(Core.Module, Interface.SettingsButton, "Interface.SettingsButton");
Sys.ns("Interface");
Interface.SettingsButtonController = {
    TOGGLE_DELAY: 500, constructor: function () {
        Interface.SettingsButtonController.superclass.constructor.apply(this, arguments)
    }, init: function () {
        Interface.SettingsButtonController.superclass.init.apply(this, arguments)
    }, setupEvents: function () {
        var a = this;
        a.on({
            "request:settingsButton.enable": a.enable,
            "request:settingsButton.disable": a.disable,
            "notify:stateHandler.enteringIdleState": a.enable.bind(a, "notInIdleState"),
            "notify:stateHandler.leavingIdleState": a.disable.bind(a, "notInIdleState"),
            "notify:settingsMenu.open": a.onSettingsMenuOpened,
            "notify:settingsMenu.closed": a.onSettingsMenuClosed
        })
    }, enable: function (b) {
        var a = this;
        a.model.removeProperty("disabledByOtherModule", b);
        if (!a.model.hasProperty("disabledByOtherModule")) {
            a.view.enable();
            a.model.storeData("disabled", false)
        }
    }, disable: function (b) {
        var a = this;
        if (!a.model.hasProperty("disabledByOtherModule")) {
            a.view.disable();
            a.model.storeData("disabled", true);
            if (a.model.readData("status") === "open") {
                a.close()
            }
        }
        a.model.addProperty("disabledByOtherModule", b)
    }, open: function () {
        this.fireEvent("request:settingsMenu.open", true);
        this.model.storeData("status", "open");
        this.view.adaptToOrientation(Environment.orientation().toUpperCase())
    }, close: function () {
        this.fireEvent("request:settingsMenu.close");
        this.model.storeData("status", "closed");
        this.view.adaptToOrientation(Environment.orientation().toUpperCase())
    }, onSettingsMenuOpened: function () {
        this.model.storeData("status", "open");
        this.view.adaptToOrientation(Environment.orientation().toUpperCase())
    }, onSettingsMenuClosed: function () {
        this.model.storeData("status", "closed");
        this.view.adaptToOrientation(Environment.orientation().toUpperCase())
    }, onUserInputStart: function (a) {
        this.view.onUserInputStart(a)
    }, onUserInputEnd: function (c) {
        var b = this, a = Date.now();
        if (b.model.readData("disabled")) {
            return
        }
        if ((!Sys.isDefined(b.lastToggleOccured) || (a - b.lastToggleOccured > b.TOGGLE_DELAY)) && b.view.checkHit(c)) {
            if (b.model.readData("status") === "open") {
                b.close()
            } else {
                b.open()
            }
            b.lastToggleOccured = Date.now()
        }
    }
};
Interface.SettingsButtonController = Sys.extend(Core.Controller, Interface.SettingsButtonController, "Interface.SettingsButtonController");
Sys.ns("Interface");
Interface.SettingsButtonModel = {
    constructor: function () {
        Interface.SettingsButtonModel.superclass.constructor.apply(this, arguments)
    }, setupData: function () {
        this.storeData("status", "closed");
        this.storeData("disabled", true)
    }
};
Interface.SettingsButtonModel = Sys.extend(Core.Model, Interface.SettingsButtonModel, "Interface.SettingsButtonModel");
Sys.ns("Interface");
Interface.SettingsButtonBaseView = {
    BASE_BUTTON_CSS: "interface-settingsButton_baseButton",
    OPEN_URI: "interface-settingsButton_open_uri",
    CLOSED_URI: "interface-settingsButton_closed_uri",
    DISABLE_CSS: "interface-buttonDisable",
    PORTRAIT_CSS: "interface-settingsButton_portrait",
    LANDSCAPE_CSS: "interface-settingsButton_landscape",
    RENDER_TARGET: "gameWrapper",
    constructor: function () {
        Interface.SettingsButtonBaseView.superclass.constructor.apply(this, arguments)
    },
    adaptToOrientation: function (a) {
        this.setStyle(a)
    },
    enable: function () {
        this.container.removeCls(this.DISABLE_CSS)
    },
    disable: function () {
        this.container.addCls(this.DISABLE_CSS)
    },
    onUserInputStart: function (a) {
        this.wasInitialInputTarget = Sys.UserInputUtils.isCoordinateTarget(this.container.el, a)
    },
    checkHit: function (b) {
        var a = false;
        if (this.wasInitialInputTarget) {
            a = Sys.UserInputUtils.isCoordinateTarget(this.container.el, b)
        }
        this.wasInitialInputTarget = false;
        return a
    },
    init: function () {
        var a = this;
        Interface.SettingsWindowBaseView.superclass.init.apply(a, arguments);
        a.previousCSS = "";
        a.wasInitialInputTarget = false;
        a.setupDOMStructure()
    },
    setStyle: function (b) {
        var c = this, a = c.model.readData("status").toUpperCase();
        Mixins.orientation.view.methods.setStyle.apply(c, arguments);
        if (a === "OPEN") {
            c.container.replaceCSSClass(c.CLOSED_URI, c.OPEN_URI)
        } else {
            if (a === "CLOSED") {
                c.container.replaceCSSClass(c.OPEN_URI, c.CLOSED_URI)
            }
        }
    },
    setupDOMStructure: function () {
        var a = this;
        a.container = new Sys.Element({
            tag: "div",
            cls: a.BASE_BUTTON_CSS + " " + a.CLOSED_URI + " " + a.DISABLE_CSS,
            renderTo: a.RENDER_TARGET
        })
    }
};
Interface.SettingsButtonBaseView = Sys.extend(Core.View, Interface.SettingsButtonBaseView, "Interface.SettingsButtonBaseView");
Sys.ns("Interface");
Interface.SettingsButtonMobileView = {
    PORTRAIT_CSS: "interface-settingsButton_portrait_mobile",
    LANDSCAPE_CSS: "interface-settingsButton_landscape_mobile",
    BACKGROUND_CSS: "interface-settingsButton_background",
    constructor: function () {
        Interface.SettingsButtonMobileView.superclass.constructor.apply(this, arguments)
    },
    setStyle: function (a) {
        Interface.SettingsButtonMobileView.superclass.setStyle.apply(this, arguments);
        if (a === "PORTRAIT") {
            this.background.el.style.display = "block"
        } else {
            this.background.el.style.display = "none"
        }
    },
    setupDOMStructure: function () {
        var a = this;
        Interface.SettingsButtonMobileView.superclass.setupDOMStructure.apply(a, arguments);
        a.background = new Sys.Element({
            tag: "div",
            id: "settingsButtonBackground",
            "class": a.BACKGROUND_CSS,
            renderTo: a.RENDER_TARGET
        })
    }
};
Interface.SettingsButtonMobileView = Sys.extend(Interface.SettingsButtonBaseView, Interface.SettingsButtonMobileView, "Interface.SettingsButtonMobileView");
Sys.ns("Interface");
Interface.BetSettings = {
    constructor: function () {
        Interface.BetSettings.superclass.constructor.apply(this, arguments)
    }, getMixinDependencies: function () {
        return {fallback: ["userInput"], desktop: ["userInput", "animation", "properties"]}
    }, getDefaultMVCClasses: function () {
        return {
            controller: Interface.BetSettingsController,
            model: Interface.BetSettingsModel,
            view: Interface.BetSettingsBaseView
        }
    }
};
Interface.BetSettings = Sys.extend(Interface.SettingsSection, Interface.BetSettings, "Interface.BetSettings");
Sys.ns("Interface");
Interface.BetSettingsController = {
    constructor: function () {
        Interface.BetSettingsController.superclass.constructor.apply(this, arguments)
    }, setupEvents: function () {
        var a = this, b;
        Interface.BetSettingsController.superclass.setupEvents.apply(a, arguments);
        a.on({
            "notify:moneyManager.betChanged": a.view.update.bind(a.view),
            "notify:settingsManager.settingChanged": a.onSettingChanged,
            "notify:stateHandler.enteringIdleState": a.enable.bind(a, "notInIdleState"),
            "notify:stateHandler.leavingIdleState": a.disable.bind(a, "notInIdleState"),
            "notify:gameModeChanged": a.onGameModeChanged,
            "notify:stateHandler.enteringspinTypeRespinRestoreState": a.disable.bind(a, "notInIdleState"),
            "request:betSettings.hideCashDisplay": a.view.hideCashDisplay.bind(a.view),
            "request:betSettings.showCashDisplay": a.view.showCashDisplay.bind(a.view),
            "request:enableBasicGamePanel": a.enable,
            "request:disableBasicGamePanel": a.disable,
            "request:betSettings.enable": a.enable,
            "request:betSettings.disable": a.disable,
            "notify:freeRounds.ended": a.onFreeRoundsEnded,
            "notify:freeRounds.reInitResponseReceived": a.onFreeRoundsReInit
        });
        b = !a.model.readData("inFreerounds");
        a.fireEvent("request:settingsManager.storeData", "betLevel", a.model.readData("betLevel"), b);
        a.fireEvent("request:settingsManager.storeData", "denomination", a.model.readData("denomination"), b)
    }, onFreeRoundsEnded: function () {
        this.model.setupData();
        this.view.reInitSelectorBars();
        this.view.showCashDisplay()
    }, onFreeRoundsReInit: function () {
        this.model.setupData();
        this.view.reInitSelectorBars()
    }, onGameModeChanged: function (b) {
        var a = this;
        if (b === "BASIC") {
            a.view.showSelectors();
            a.view.hideFreespinLabels()
        } else {
            a.view.hideSelectors();
            a.view.showFreespinLabels()
        }
    }, onSettingChanged: function (a, b) {
        if (a === "betLevel" || a === "denomination") {
            this.model.storeData(a, b)
        }
    }, onUserAction: function (c, b) {
        var a, d = b;
        if (c === "betLevelChanged") {
            a = "betLevel"
        } else {
            if (c === "coinValueChanged") {
                a = "denomination";
                d = this.model.getDenomination(d)
            }
        }
        if (Sys.isDefined(a)) {
            this.fireEvent("request:settingsManager.storeData", a, d, !this.model.readData("inFreerounds"))
        }
    }, enable: function (a) {
        this.model.storeData("disabled", false);
        this.view.enable(a)
    }, disable: function (a) {
        this.model.storeData("disabled", true);
        this.view.disable(a)
    }
};
Interface.BetSettingsController = Sys.extend(Interface.SettingsSectionController, Interface.BetSettingsController, "Interface.BetSettingsController");
Sys.ns("Interface");
Interface.BetSettingsModel = {
    constructor: function () {
        Interface.BetSettingsModel.superclass.constructor.apply(this, arguments)
    }, setupData: function () {
        var k = this, b = Services.localStorageManager.readData("ignoreInitialBet") || false,
            h = Resources.readData("gameServerInitResponseObject"), g = h.betlevel.standard,
            a = h.denomination.standard, d = h.betlevel.all, j = h.denomination.all, l = [], o, n, f = false, m, e, c;
        Interface.BetSettingsModel.superclass.setupData.apply(k, arguments);
        if (!Sys.isArray(d)) {
            d = [d]
        }
        if (!Sys.isArray(j)) {
            j = [j]
        }
        k.storeData("inFreerounds", Sys.utils.toInt(h.freeRoundsLeft) > 0);
        if (!Sys.isArray(h.denomination.all)) {
            h.denomination.all = [h.denomination.all]
        }
        o = k.getCustomCoinValues(h.denomination.all);
        n = k.getInitialBetChanges(o, h.betlevel.all);
        if (!k.readData("inFreerounds") && o && n) {
            j = o;
            if (!b) {
                f = true;
                Services.localStorageManager.storeData("ignoreInitialBet", true.toString())
            }
        }
        for (e = 0; e < j.length; e++) {
            l.push(k.getCoinValue(j[e]))
        }
        if (Services.localStorageManager.hasData("betLevel")) {
            m = Number(Services.localStorageManager.readData("betLevel"))
        }
        if (Sys.isDefined(h.bet) && Sys.isDefined(h.bet.betlevel)) {
            g = h.bet.betlevel
        } else {
            if (f && n.defaultBetLevel) {
                g = n.defaultBetLevel
            } else {
                if (Sys.isNumber(m) && d.contains(m)) {
                    g = m
                }
            }
        }
        if (Services.localStorageManager.hasData("denomination")) {
            m = Number(Services.localStorageManager.readData("denomination"))
        }
        if (Sys.isDefined(h.bet) && Sys.isDefined(h.bet.denomination)) {
            a = h.bet.denomination
        } else {
            if (f && n.defaultCoinValue) {
                a = n.defaultCoinValue
            } else {
                if (Sys.isNumber(m) && j.contains(m)) {
                    a = m
                }
            }
        }
        c = [{
            key: "betLevels",
            defaultValue: d,
            settingsManager: false,
            localStorage: false
        }, {
            key: "updatableBetLevels",
            defaultValue: (d.length > 1),
            settingsManager: false,
            localStorage: false
        }, {
            key: "coinValues",
            defaultValue: l,
            settingsManager: false,
            localStorage: false
        }, {
            key: "updatableCoinValues",
            defaultValue: (l.length > 1),
            settingsManager: false,
            localStorage: false
        }, {
            key: "betLevel",
            defaultValue: g,
            settingsManager: true,
            ignoreLocalStorageValue: true,
            localStorage: !k.readData("inFreerounds"),
            silent: false
        }, {
            key: "denomination",
            defaultValue: a,
            settingsManager: true,
            ignoreLocalStorageValue: true,
            localStorage: !k.readData("inFreerounds"),
            silent: false
        }];
        c.forEach(k.initData, k)
    }, getCustomCoinValues: function (g) {
        var f = this, b = Resources.readData("queryData"), h, a, d, e = [], c;
        if (!Sys.isDefined(g) || !Sys.isDefined(b["customConfiguration.coinValues"])) {
            return null
        }
        a = f.decodeDataString(b["customConfiguration.coinValues"]);
        if (a.trim().length === 0) {
            return null
        }
        h = a.split(",");
        for (c = 0; c < h.length; c++) {
            d = parseInt(h[c], 10);
            if (g.indexOf(d) === -1) {
                return null
            }
            e.push(d)
        }
        return e.sort(function (j, i) {
            return j - i
        })
    }, getInitialBetChanges: function (b, e) {
        var a = Resources.readData("queryData"), d = parseInt(a["customConfiguration.defaultBetLevel"], 10),
            c = parseInt(a["customConfiguration.defaultCoinValue"], 10);
        if (!Sys.isArray(b) || !Sys.isArray(e) || e.indexOf(d) === -1 || b.indexOf(c) === -1) {
            return null
        }
        return {defaultBetLevel: d, defaultCoinValue: c}
    }, decodeDataString: function (a) {
        if (a.match(/%/)) {
            return decodeURIComponent(a)
        }
        return a
    }, storeData: function (a, b) {
        Interface.BetSettingsModel.superclass.storeData.call(this, a, b);
        if (a === "denomination") {
            Interface.BetSettingsModel.superclass.storeData.call(this, "coinValue", this.getCoinValue(b))
        }
    }, getDenomination: function (a) {
        return a * 100
    }, getCoinValue: function (a) {
        return a / 100
    }
};
Interface.BetSettingsModel = Sys.extend(Interface.SettingsSectionModel, Interface.BetSettingsModel, "Interface.BetSettingsModel");
Sys.ns("Interface");
Interface.BetSettingsBaseView = {
    BASE_CSS: "tab interface-betSettings_base",
    SECTION_CSS: "interface-settingsSection_subSection",
    PORTRAIT_CSS: "interface-betSettings_portrait",
    LANDSCAPE_CSS: "interface-betSettings_landscape",
    constructor: function () {
        Interface.BetSettingsBaseView.superclass.constructor.apply(this, arguments)
    },
    setUpContent: function () {
        var b = this, a = b.model;
        b.subComponents = [];
        b.container = new Sys.Element({id: "BetSettings", tag: "div", cls: b.BASE_CSS});
        b.betDisplays = b.container.add(new Sys.Element({tag: "ul", "class": "interface-betSettings_betDisplays"}));
        b.betInCashDisplay = b.betDisplays.add(new Sys.Element({
            tag: "li",
            "class": "interface-betSettings_betDisplays_size interface-betSettings_displayText",
            textContent: Services.languageManager.getText(Language.Keys.betInCash)
        }));
        b.betInCashValue = b.betInCashDisplay.add(new Sys.Element({
            tag: "div",
            textContent: "0",
            "class": "interface-betSettings_displayValue"
        }));
        b.betInCoinsDisplay = b.betDisplays.add(new Sys.Element({
            tag: "li",
            "class": "interface-betSettings_betDisplays_size interface-betSettings_displayText",
            textContent: Services.languageManager.getText(Language.Keys.betInCoins)
        }));
        b.betInCoinsValue = b.betInCoinsDisplay.add(new Sys.Element({
            tag: "div",
            textContent: "0",
            "class": "interface-betSettings_displayValue"
        }));
        b.settings = b.container.add(new Sys.Element({
            tag: "ul",
            "class": "interface-settingsSection_dynamicSliderPosition_container"
        }));
        b.betLevelText = b.settings.add(new Sys.Element({
            tag: "li",
            "class": "interface-settingsSection_dynamicSliderPosition_label",
            textContent: Services.languageManager.getText(Language.Keys.betLevel)
        }));
        if (!a.readData("updatableBetLevels")) {
            b.betLevelText.el.style.opacity = 0.5
        }
        b.betLevelSlider = b.createBetLevelSlider(a.readData("betLevels"));
        b.betLevelSliderContainer = new Sys.Element({
            tag: "li",
            "class": "interface-settingsSection_dynamicSliderPosition_slider"
        });
        b.settings.add(b.betLevelSliderContainer).add(b.betLevelSlider.getContainer());
        if (a.readData("updatableBetLevels")) {
            b.subComponents.push(b.betLevelSlider)
        }
        b.coinValueText = b.settings.add(new Sys.Element({
            tag: "li",
            "class": "interface-settingsSection_dynamicSliderPosition_label",
            textContent: Services.languageManager.getText(Language.Keys.coinValue)
        }));
        if (!a.readData("updatableCoinValues")) {
            b.coinValueText.el.style.opacity = 0.5
        }
        b.coinValueSlider = b.createCoinValueSlider(a.readData("coinValues"));
        b.coinValueSliderContainer = new Sys.Element({
            tag: "li",
            "class": "interface-settingsSection_dynamicSliderPosition_slider"
        });
        b.settings.add(b.coinValueSliderContainer).add(b.coinValueSlider.getContainer());
        if (a.readData("updatableCoinValues")) {
            b.subComponents.push(b.coinValueSlider)
        }
        b.portraitInformation = b.container.add(new Sys.Element({
            tag: "ul",
            "class": "interface-betSettings_portraitInfo"
        }));
        b.cashBalanceText = b.portraitInformation.add(new Sys.Element({
            tag: "li",
            "class": "interface-betSettings_portraitInfo_label",
            textContent: Services.languageManager.getText(Language.Keys.cashColon)
        }));
        b.cashBalanceValue = b.portraitInformation.add(new Sys.Element({
            tag: "li",
            "class": "interface-betSettings_portraitInfo_numbers"
        }));
        b.fireEvent("view:addToContainer", "settingsWindow", {
            title: Services.languageManager.getText(Language.Keys.betSettings_uc),
            content: b.container
        });
        b.fireEvent("view:addToNavigator", "settingsMenu", {order: 3, isDefault: true});
        b.addScrolling();
        if (!b.model.readData("disabled")) {
            b.enable()
        }
        b.update()
    },
    createBetLevelSlider: function (b) {
        var a = b;
        if (!this.model.readData("updatableBetLevels") && a.length === 1) {
            a = [b[0], ""]
        }
        return new Interface.utils.Slider({
            id: "betSettingsBetLevelSlider",
            values: a,
            callback: this.onSliderValueChange.bind(this, "betLevelChanged"),
            showLabels: true
        })
    },
    createCoinValueSlider: function (b) {
        var a = b;
        if (!this.model.readData("updatableCoinValues") && a.length === 1) {
            a = [b[0], ""]
        }
        return new Interface.utils.Slider({
            id: "betSettingsCoinValueSlider",
            values: a,
            callback: this.onSliderValueChange.bind(this, "coinValueChanged"),
            showLabels: true
        })
    },
    onSliderValueChange: function (b, a) {
        this.fireEvent("view:userAction", b, a)
    },
    enable: function () {
        var a = this;
        a.callFunctionOnSubComponents("enable");
        a.cashBalanceValue.el.textContent = Services.moneyManager.formatMoneyCurrencySign(Services.moneyManager.getBalanceCents())
    },
    disable: function () {
        this.callFunctionOnSubComponents("disable")
    },
    show: function () {
        Interface.BetSettingsBaseView.superclass.show.apply(this, arguments);
        this.cashBalanceValue.el.textContent = Services.moneyManager.formatMoneyCurrencySign(Services.moneyManager.getBalanceCents())
    },
    hideCashDisplay: function () {
        this.portraitInformation.el.style.display = "none"
    },
    showCashDisplay: function () {
        this.portraitInformation.el.style.display = "block"
    },
    update: function () {
        var c = this, a = c.model, b = Services.moneyManager;
        if (a.readData("updatableBetLevels")) {
            c.betLevelSlider.setValue(c.model.readData("betLevel"), true)
        }
        if (a.readData("updatableCoinValues")) {
            c.coinValueSlider.setValue(c.model.readData("coinValue"), true)
        }
        c.betInCashValue.el.textContent = b.formatMoneyCurrencySign(b.getBetCents());
        c.betInCoinsValue.el.textContent = b.getBetCoins();
        c.cashBalanceValue.el.textContent = b.formatMoneyCurrencySign(b.getBalanceCents())
    },
    hideSelectors: function () {
    },
    showSelectors: function () {
    },
    showFreespinLabels: function () {
    },
    hideFreespinLabels: function () {
    },
    removeSelectorFromContainer: function (a, b) {
        b.remove(a.getContainer())
    },
    addSelectorToContainer: function (a, b) {
        b.add(a.getContainer())
    },
    reInitSelectorBars: function () {
        var b = this.model.readData("betLevels"), a = this.model.readData("coinValues");
        this.removeSelectorFromContainer(this.betLevelSlider, this.betLevelSliderContainer);
        this.removeSelectorFromContainer(this.coinValueSlider, this.coinValueSliderContainer);
        this.betLevelSlider = this.createBetLevelSlider(b);
        this.coinValueSlider = this.createCoinValueSlider(a);
        if (this.model.readData("updatableBetLevels")) {
            this.betLevelText.el.style.opacity = 1;
            if (!Sys.contains(this.subComponents, this.betLevelSlider)) {
                this.subComponents.push(this.betLevelSlider)
            }
        }
        if (this.model.readData("updatableCoinValues")) {
            this.coinValueText.el.style.opacity = 1;
            if (!Sys.contains(this.subComponents, this.coinValueSlider)) {
                this.subComponents.push(this.coinValueSlider)
            }
        }
        this.addSelectorToContainer(this.betLevelSlider, this.betLevelSliderContainer);
        this.addSelectorToContainer(this.coinValueSlider, this.coinValueSliderContainer);
        this.update();
        if (!this.model.readData("disabled")) {
            this.enable()
        }
    }
};
Interface.BetSettingsBaseView = Sys.extend(Interface.SettingsSectionView, Interface.BetSettingsBaseView, "Interface.BetSettingsBaseView");
Sys.ns("Interface");
Interface.BetSettingsDesktopView = {
    GAME_MODES: ["BASIC", "FREESPIN"],
    BASIC_BETLEVEL_LABEL: {font: "17px Verdana", fillstyle: "rgb(218,218,171)"},
    BASIC_BETLEVEL_VALUE: {font: "17px Verdana", fillstyle: "rgb(238,239,206)"},
    BASIC_COINVALUE_LABEL: {font: "17px Verdana", fillstyle: "rgb(218,218,171)"},
    BASIC_COINVALUE_VALUE: {font: "17px Verdana", fillstyle: "rgb(238,239,206)"},
    FREESPIN_BETLEVEL_LABEL: {
        font: "17px Verdana",
        fillstyle: "rgb(218,218,171)",
        position: {x: 210, y: 641, width: 100, height: 20},
        alignment: {horizontal: "right", vertical: false}
    },
    FREESPIN_BETLEVEL_VALUE: {
        font: "17px Verdana",
        fillstyle: "rgb(238,239,206)",
        position: {x: 315, y: 641, width: 267, height: 20},
        alignment: {horizontal: "left", vertical: false}
    },
    FREESPIN_COINVALUE_LABEL: {
        font: "17px Verdana",
        fillstyle: "rgb(218,218,171)",
        position: {x: 877, y: 641, width: 100, height: 20},
        alignment: {horizontal: "right", vertical: false}
    },
    FREESPIN_COINVALUE_VALUE: {
        font: "17px Verdana",
        fillstyle: "rgb(238,239,206)",
        position: {x: 982, y: 641, width: 267, height: 20},
        alignment: {horizontal: "left", vertical: false}
    },
    BETLEVEL_VALUE_SELECTOR_BASE_POSITION: {x: 264, y: 629},
    COINVALUE_VALUE_SELECTOR_BASE_POSITION: {x: 889, y: 629},
    VALUE_SELECTOR_POSITION_OFFSET_LABEL: {x: 0, y: -18},
    VALUE_SELECTOR_POSITION_OFFSET_VALUE: {x: 0, y: 9},
    VALUE_SELECTOR_RIGHT_BUTTON_IMAGE: undefined,
    VALUE_SELECTOR_LEFT_BUTTON_IMAGE: undefined,
    VALUE_SELECTOR_HANDLE_POSITION_OFFSET: undefined,
    VALUE_SELECTOR_HANDLE_DIMENSIONS: undefined,
    VALUE_SELECTOR_HANDLE_COLLISION_BOX: {
        LEFT: {xOffset: 7, yOffset: 7, width: 28, height: 37},
        RIGHT: {xOffset: 9, yOffset: 7, width: 28, height: 37}
    },
    VALUE_SELECTOR_BAR_BACKGROUND: undefined,
    VALUE_SELECTOR_BAR_BACKGROUND_DISABLED: undefined,
    VALUE_SELECTOR_BAR_FILL: undefined,
    VALUE_SELECTOR_BAR_FILL_DISABLED: undefined,
    VALUE_SELECTOR_BAR_DIMENSIONS: undefined,
    VALUE_SELECTOR_BAR_POSITIONS_OFFSET: undefined,
    constructor: function () {
        Interface.BetSettingsDesktopView.superclass.constructor.apply(this, arguments)
    },
    initAnimations: function () {
        var a = this;
        a.betLevelLabel = Services.languageManager.getText(Language.Keys.level);
        a.coinValueLabel = Services.languageManager.getText(Language.Keys.machinetext_coinvalue);
        a.keyPadLayering = Layering.Game.Slots.Keypad;
        a.itemList = new Animation.List({});
        a.enabled = true;
        a.initSelectors();
        a.initFreespinItems();
        a.update()
    },
    updateValueItem: function (a, e, c) {
        var f = a.prop, b = f.customProps.inMemCanvas.ctx, d;
        b.clearRect(0, 0, f.width, f.height);
        d = Animation.utils.text.measureText(e, c.font, 0, b);
        Animation.utils.text.performOperations(e, c.font, 0, d.height / 2, [{
            fillStyle: c.fillstyle,
            drawType: "fill"
        }], b)
    },
    initSelectors: function () {
        var c = this, b = c.keyPadLayering, a;
        a = c.model.readData("coinValues").map(function (d) {
            return Sys.utils.numberToFixedDigits(d, 3)
        });
        c.selectors = {
            betLevelSelector: new Interface.utils.CanvasValueSelector({
                id: "betLevelSelector",
                x: c.BETLEVEL_VALUE_SELECTOR_BASE_POSITION.x,
                y: c.BETLEVEL_VALUE_SELECTOR_BASE_POSITION.y,
                depth: b.betLevelSelector,
                values: c.model.readData("betLevels"),
                callback: c.onValueChange.bind(c, "betLevelChanged"),
                disabled: !c.model.readData("updatableBetLevels"),
                label: Services.languageManager.getText(Language.Keys.level),
                fontLabel: c.BASIC_BETLEVEL_LABEL.font,
                fontValue: c.BASIC_BETLEVEL_VALUE.font,
                fillstyleLabel: c.BASIC_BETLEVEL_LABEL.fillstyle,
                fillstyleValue: c.BASIC_BETLEVEL_VALUE.fillstyle,
                positionOffsetLabel: c.VALUE_SELECTOR_POSITION_OFFSET_LABEL,
                positionOffsetValue: c.VALUE_SELECTOR_POSITION_OFFSET_VALUE,
                rightButtonImage: c.VALUE_SELECTOR_RIGHT_BUTTON_IMAGE,
                leftButtonImage: c.VALUE_SELECTOR_LEFT_BUTTON_IMAGE,
                handlePositionOffset: c.VALUE_SELECTOR_HANDLE_POSITION_OFFSET,
                handleDimensions: c.VALUE_SELECTOR_HANDLE_DIMENSIONS,
                handleCollisionBox: c.VALUE_SELECTOR_HANDLE_COLLISION_BOX,
                barBackground: c.VALUE_SELECTOR_BAR_BACKGROUND,
                barBackgroundDisabled: c.VALUE_SELECTOR_BAR_BACKGROUND_DISABLED,
                barFill: c.VALUE_SELECTOR_BAR_FILL,
                barFillDisabled: c.VALUE_SELECTOR_BAR_FILL_DISABLED,
                barDimensions: c.VALUE_SELECTOR_BAR_DIMENSIONS,
                barPositionOffset: c.VALUE_SELECTOR_BAR_POSITIONS_OFFSET
            }),
            coinValueSelector: new Interface.utils.CanvasValueSelector({
                id: "coinValueSelector",
                x: c.COINVALUE_VALUE_SELECTOR_BASE_POSITION.x,
                y: c.COINVALUE_VALUE_SELECTOR_BASE_POSITION.y,
                depth: b.betLevelSelector,
                values: c.model.readData("coinValues"),
                valueNames: a,
                callback: c.onValueChange.bind(c, "coinValueChanged"),
                disabled: !c.model.readData("updatableCoinValues"),
                label: Services.languageManager.getText(Language.Keys.machinetext_coinvalue),
                fontLabel: c.BASIC_COINVALUE_LABEL.font,
                fontValue: c.BASIC_COINVALUE_VALUE.font,
                fillstyleLabel: c.BASIC_COINVALUE_LABEL.fillstyle,
                fillstyleValue: c.BASIC_COINVALUE_VALUE.fillstyle,
                positionOffsetLabel: c.VALUE_SELECTOR_POSITION_OFFSET_LABEL,
                positionOffsetValue: c.VALUE_SELECTOR_POSITION_OFFSET_VALUE,
                rightButtonImage: c.VALUE_SELECTOR_RIGHT_BUTTON_IMAGE,
                leftButtonImage: c.VALUE_SELECTOR_LEFT_BUTTON_IMAGE,
                handlePositionOffset: c.VALUE_SELECTOR_HANDLE_POSITION_OFFSET,
                handleDimensions: c.VALUE_SELECTOR_HANDLE_DIMENSIONS,
                handleCollisionBox: c.VALUE_SELECTOR_HANDLE_COLLISION_BOX,
                barBackground: c.VALUE_SELECTOR_BAR_BACKGROUND,
                barBackgroundDisabled: c.VALUE_SELECTOR_BAR_BACKGROUND_DISABLED,
                barFill: c.VALUE_SELECTOR_BAR_FILL,
                barFillDisabled: c.VALUE_SELECTOR_BAR_FILL_DISABLED,
                barDimensions: c.VALUE_SELECTOR_BAR_DIMENSIONS,
                barPositionOffset: c.VALUE_SELECTOR_BAR_POSITIONS_OFFSET
            })
        }
    },
    reInitSelectorBars: function () {
        Sys.iterate(this.selectors, function (b, a) {
            a.destroy()
        });
        this.initSelectors();
        this.update()
    },
    initFreespinItems: function () {
        var a = this;
        a.betLevelLabelItem = a.initTextItem(a.betLevelLabel, a.FREESPIN_BETLEVEL_LABEL, a.keyPadLayering.betLevelSelector);
        a.betLevelValueItem = a.initTextItem(a.model.readData("betLevel"), a.FREESPIN_BETLEVEL_VALUE, a.keyPadLayering.betLevelSelector);
        a.coinValueLabelItem = a.initTextItem(a.coinValueLabel, a.FREESPIN_COINVALUE_LABEL, a.keyPadLayering.betLevelSelector);
        a.coinValueValueItem = a.initTextItem(a.model.readData("coinValue"), a.FREESPIN_COINVALUE_VALUE, a.keyPadLayering.betLevelSelector);
        a.itemList.addItems([a.betLevelLabelItem, a.betLevelValueItem, a.coinValueLabelItem, a.coinValueValueItem]);
        Game.stage.view.addToRenderLoop(a.itemList);
        a.itemList.stop()
    },
    initTextItem: function (h, c, g) {
        var d = this, b = c.position, f = d.getInMemoryCanvas(b.width, b.height),
            a = c.alignment.horizontal === "right" ? c.position.width : 0, e;
        if (Sys.isDefined(c.alignment)) {
            f.ctx.textAlign = c.alignment.horizontal
        }
        e = Animation.utils.text.measureText(h, c.font, 0, f.ctx);
        Animation.utils.text.performOperations(h, c.font, a, e.height / 2, [{
            fillStyle: c.fillstyle,
            drawType: "fill"
        }], f.ctx);
        return new Animation.Item({
            top: b.y,
            left: b.x,
            width: b.width,
            height: b.height,
            depth: g,
            image: f.canvas,
            customProps: {inMemCanvas: f}
        })
    },
    getInMemoryCanvas: function (d, a) {
        var c = document.createElement("canvas"), b = c.getContext("2d");
        c.width = d;
        c.height = a;
        return {canvas: c, ctx: b}
    },
    onValueChange: function (b, a) {
        this.fireEvent("view:userAction", b, a)
    },
    setUpContent: function () {
    },
    onSliderValueChange: function (b, a) {
    },
    enable: function (d) {
        var c = this, b = c.model.readData("updatableBetLevels"), a = c.model.readData("updatableCoinValues");
        c.enabled = true;
        Sys.iterate(c.selectors, function (e) {
            if ((e === "betLevelSelector" && b) || (e === "coinValueSelector" && a)) {
                c.selectors[e].enable(d)
            }
        });
        c.update()
    },
    disable: function (d) {
        var c = this, b = c.model.readData("updatableBetLevels"), a = c.model.readData("updatableCoinValues");
        c.enabled = false;
        Sys.iterate(c.selectors, function (e) {
            if ((e === "betLevelSelector" && b) || (e === "coinValueSelector" && a)) {
                c.selectors[e].disable(d)
            }
        })
    },
    hideSelectors: function () {
        this.disable("BetSettings");
        Sys.iterate(this.selectors, function (b, a) {
            a.hide("BetSettings")
        })
    },
    showSelectors: function () {
        this.enable("BetSettings");
        Sys.iterate(this.selectors, function (b, a) {
            a.show("BetSettings")
        })
    },
    showFreespinLabels: function () {
        this.itemList.play()
    },
    hideFreespinLabels: function () {
        this.itemList.stop()
    },
    update: function () {
        var b = this, a = b.model;
        if (Sys.isDefined(b.selectors) && this.enabled) {
            if (a.readData("updatableBetLevels")) {
                b.selectors.betLevelSelector.update(b.model.readData("betLevel"));
                b.updateValueItem(b.betLevelValueItem, b.model.readData("betLevel"), b.FREESPIN_BETLEVEL_VALUE)
            }
            if (a.readData("updatableCoinValues")) {
                b.selectors.coinValueSelector.update(b.model.readData("coinValue"));
                b.updateValueItem(b.coinValueValueItem, b.model.readData("coinValue"), b.FREESPIN_COINVALUE_VALUE)
            }
        }
        if (Sys.isDefined(b.coinValueValueItem && b.betLevelValueItem)) {
            if (a.readData("updatableBetLevels")) {
                b.updateValueItem(b.betLevelValueItem, b.model.readData("betLevel"), b.FREESPIN_BETLEVEL_VALUE)
            }
            if (a.readData("updatableCoinValues")) {
                b.updateValueItem(b.coinValueValueItem, b.model.readData("coinValue"), b.FREESPIN_COINVALUE_VALUE)
            }
        }
    },
    hideCashDisplay: function () {
    },
    showCashDisplay: function () {
    }
};
Interface.BetSettingsDesktopView = Sys.extend(Interface.BetSettingsBaseView, Interface.BetSettingsDesktopView, "Interface.BetSettingsDesktopView");
Sys.ns("Interface");
Interface.GameHistory = {
    constructor: function () {
        Interface.GameHistory.superclass.constructor.apply(this, arguments)
    }, getDefaultMVCClasses: function () {
        return {
            controller: Interface.GameHistoryController,
            model: Interface.GameHistoryModel,
            view: Interface.GameHistoryBaseView
        }
    }
};
Interface.GameHistory = Sys.extend(Interface.SettingsSection, Interface.GameHistory, "Interface.GameHistory");
Sys.ns("Interface");
Interface.GameHistoryController = {
    constructor: function () {
        Interface.GameHistoryController.superclass.constructor.apply(this, arguments)
    }, onUserAction: function (a) {
        if (a === "goToHistory") {
            Environment.goTo(Resources.readData("historyUrl"))
        }
    }
};
Interface.GameHistoryController = Sys.extend(Interface.SettingsSectionController, Interface.GameHistoryController, "Interface.GameHistoryController");
Sys.ns("Interface");
Interface.GameHistoryModel = {
    constructor: function () {
        Interface.GameHistoryModel.superclass.constructor.apply(this, arguments)
    }, setupData: function () {
        var a = Resources.readData("gameServerInitResponse");
        Interface.GameHistoryModel.superclass.setupData.apply(this, arguments);
        if (a.playforfun) {
            this.storeData("disabled", true)
        } else {
            if (Sys.isDefined(a.historybutton) && !a.historybutton) {
                this.storeData("removed", true)
            }
        }
    }
};
Interface.GameHistoryModel = Sys.extend(Core.Model, Interface.GameHistoryModel, "Interface.GameHistoryModel");
Sys.ns("Interface");
Interface.GameHistoryBaseView = {
    BASE_CSS: "tab interface-gameHistory_base",
    PORTRAIT_CSS: "interface-gameHistory_portrait",
    LANDSCAPE_CSS: "interface-gameHistory_landscape",
    BUTTON_BASE_CSS: "button interface-gameHistory_button",
    BUTTON_DISABLED_CSS: "interface-gameHistory_buttonDisabled",
    BUTTON_PRESSED_CSS: "interface-gameHistory_buttonPressed",
    constructor: function () {
        Interface.GameHistoryBaseView.superclass.constructor.apply(this, arguments)
    },
    setUpContent: function () {
        var a = this;
        a.container = new Sys.Element({id: "gameHistory", tag: "div", cls: a.BASE_CSS});
        a.text = a.container.add(new Sys.Element({
            id: "gameHistoryDisabledText",
            tag: "div",
            style: "margin-top: 10%;"
        }));
        a.text.el.textContent = Services.languageManager.getText(Language.Keys.newHistoryWindow);
        a.button = new Interface.utils.Button({
            id: "gameHistoryButton",
            CSS: {base: a.BUTTON_BASE_CSS, disabled: a.BUTTON_DISABLED_CSS}
        });
        a.container.add(a.button.getContainer());
        a.button.setText(Services.languageManager.getText(Language.Keys.gameHistory));
        if (a.model.readData("disabled")) {
            a.disable()
        }
        a.fireEvent("view:addToContainer", "settingsWindow", {
            title: Services.languageManager.getText(Language.Keys.gameHistory_uc),
            content: a.container
        });
        if (!a.model.readData("removed")) {
            a.fireEvent("view:addToNavigator", "settingsMenu", {order: 5})
        }
        a.addScrolling();
        if (!a.model.readData("disabled")) {
            a.enable()
        }
        a.hide()
    },
    enable: function () {
        this.text.el.textContent = Services.languageManager.getText(Language.Keys.newHistoryWindow);
        this.button.enable()
    },
    disable: function () {
        this.text.el.textContent = Services.languageManager.getText(Language.Keys.historyNotAvailable);
        this.button.disable()
    },
    onUserInputStart: function (b) {
        var a = this;
        if (!a.model.readData("disabled") && Sys.UserInputUtils.isCoordinateTarget(a.button.getContainer().getEl(), b)) {
            a.model.storeData("buttonPressed", true);
            a.container.addCls(a.PRESSED_CSS)
        }
    },
    onUserInputEnd: function (c) {
        var b = this, a = this.model.readData("buttonPressed");
        b.model.storeData("buttonPressed", false);
        b.container.removeCls(this.PRESSED_CSS);
        if (a && Sys.UserInputUtils.isCoordinateTarget(b.button.getContainer().getEl(), c)) {
            b.fireEvent("view:userAction", "goToHistory")
        }
    }
};
Interface.GameHistoryBaseView = Sys.extend(Interface.SettingsSectionView, Interface.GameHistoryBaseView, "Interface.GameHistoryBaseView");
Sys.ns("Interface");
Interface.GameRules = {
    constructor: function () {
        Interface.GameRules.superclass.constructor.apply(this, arguments)
    }, getMixinDependencies: function () {
        return [{userInput: {inputEvents: ["start", "end", "cancel", "move", "scroll"]}}, "orientation"]
    }, getDefaultMVCClasses: function () {
        return {
            controller: Interface.GameRulesController,
            model: Interface.GameRulesModel,
            view: Interface.GameRulesBaseView
        }
    }
};
Interface.GameRules = Sys.extend(Interface.SettingsSection, Interface.GameRules, "Interface.GameRules");
Sys.ns("Interface");
Interface.GameRulesController = {
    constructor: function () {
        Interface.GameRulesController.superclass.constructor.apply(this, arguments)
    }, setupEvents: function () {
        var a = this;
        Interface.GameRulesController.superclass.setupEvents.apply(a, arguments);
        a.on({"notify:stateHandler.enteringspinTypeRespinRestoreState": a.view.disableButton.bind(a.view)});
        if (Sys.isGcmEnabled) {
            a.removeListener("view:addToNavigator")
        }
    }, show: function () {
        var a = this;
        if (!a.model.readData("hasLoadedGameRules") && !a.model.isState("fetchingGameRules")) {
            a.model.setState("fetchingGameRules");
            a.fetchGameRules()
        }
        Interface.GameRulesController.superclass.show.apply(a, arguments)
    }, fetchGameRules: function () {
        var b = this, a = new Sys.Deferred();
        a.when(Sys.utils.httpGet({url: b.model.readData("templateURL")}), Sys.utils.httpGet({url: b.model.readData("textURL")}), Sys.utils.httpGet({url: b.model.readData("manifestURL")})).fail(b.onRulesLoadingFailed, b).done(b.onRulesPartsFetched, b)
    }, onRulesPartsFetched: function (c, b, a) {
        this.model.processGameRules(c, b, a);
        this.view.updateContent()
    }, onRulesLoadingFailed: function () {
    }
};
Interface.GameRulesController = Sys.extend(Interface.SettingsSectionController, Interface.GameRulesController, "Interface.GameRulesController");
Sys.ns("Interface");
Interface.GameRulesModel = {
    constructor: function () {
        Interface.GameRulesModel.superclass.constructor.apply(this, arguments)
    }, setupData: function () {
        var g = this, c = Resources.readData("config"), b = c.gameRules, i = c.gameRulesPath,
            e = Resources.readData("language"), d = Resources.readData("queryData").gameId, a = "../", f, h;
        d = d.replace(/_sw$/, "");
        if (Sys.isDefined(b)) {
            if (Platform.isDesktopDevice) {
                d = (d.indexOf("netent_") > -1) ? "netent_" + b.desktop : b.desktop
            } else {
                d = (d.indexOf("netent_") > -1) ? "netent_" + b.touch : b.touch
            }
        }
        Interface.GameRulesModel.superclass.setupData.apply(this, arguments);
        if (i) {
            f = a + i + "templates/" + d + "." + e.lang + ".html";
            h = a + i + "META-INF/MANIFEST.MF"
        } else {
            f = a + "gamerules/template/" + d + ".template";
            h = a + "gamerules/META-INF/MANIFEST.MF";
            g.storeData("textURL", a + "gamerules/rules/" + e.lang + "/rulestext.xml")
        }
        g.storeData("templateURL", f);
        g.storeData("manifestURL", h);
        g.storeData("hasLoadedGameRules", false)
    }, processGameRules: function (f, c, b) {
        var e = (Resources.readData("config") || {}).gameRulesPath, d, a;
        if (!e) {
            d = this.parseTextsToObject(c.responseText);
            a = this.insertTextsInTemplate(f.responseText, d);
            a = this.removeLinkTags(a);
            a = this.removeNoncharacters(a)
        } else {
            a = this.alterImagePaths(f.responseText)
        }
        a = this.addTimestamp(a, b);
        this.storeData("content", a);
        this.storeData("hasLoadedGameRules", true);
        this.setState("idle")
    }, alterImagePaths: function (a) {
        return a.replace(/src="..\/([\w/.-]*)"/g, "src='../gamerules/$1'")
    }, parseTextsToObject: function (d) {
        var a = {}, b = /<ds.+name="([\w\d-]+)"[^>]*>(.+)<\/ds>/g, c = document.createElement("div");
        d.replace(b, function (g, e, f) {
            c.innerHTML = f;
            a[e] = c.textContent
        });
        return a
    }, insertTextsInTemplate: function (b, a) {
        var c = b.replace(/<#([\w\d-]+)#\/>/g, function (d, e) {
            if (a[e]) {
                return a[e]
            } else {
                if (Services.languageManager.hasText(e)) {
                    return Services.languageManager.getText(e)
                }
            }
            return "[rules string '" + e + "' not found]"
        });
        return c
    }, removeLinkTags: function (a) {
        return a.replace(/<link.+>/g, "")
    }, addTimestamp: function (a, b) {
        var c = this.parseDateFromManifest(b);
        return a + "<div id='manifest_timestamp' style='margin-top:10px;'>" + c + "</div>"
    }, removeNoncharacters: function (a) {
        return decodeURIComponent(encodeURIComponent(a).replace(/%EF%BF%BF/g, ""))
    }, parseDateFromManifest: function (b) {
        var a = this.checkIfRegExpMatch(b.response), c;
        b.responseText.replace(a, function (f, d, e) {
            c = d + " " + e + " (UTC)"
        });
        return c
    }, checkIfRegExpMatch: function (c) {
        var b, a;
        b = /Git-CommitTime:\s([\d\-]+)[T\s]([\d:]+)/;
        a = /Subversion-(?:Commited)?Date: ([\d\-]+)T([\d:]+)/;
        return b.test(c) ? b : a
    }
};
Interface.GameRulesModel = Sys.extend(Core.Model, Interface.GameRulesModel, "Interface.GameRulesModel");
Sys.ns("Interface");
Interface.GameRulesBaseView = {
    BASE_CSS: "tab interface-gameRules_base",
    PORTRAIT_CSS: "interface-gameRules_portrait",
    LANDSCAPE_CSS: "interface-gameRules_landscape",
    RULES_WRAPPER_CSS: "interface-gameRules_rulesWrapper",
    LOADER_CSS: "interface-gameRules_rulesLoader",
    LOADER_URI: "interface-smallSpinner_uri",
    constructor: function () {
        Interface.GameRulesBaseView.superclass.constructor.apply(this, arguments)
    },
    setUpContent: function () {
        var a = this;
        a.container = new Sys.Element({id: "gameRules", tag: "div", cls: a.BASE_CSS});
        a.rulesWrapper = a.container.add(new Sys.Element({
            id: "gameRules_rules",
            tag: "div",
            cls: a.RULES_WRAPPER_CSS
        }));
        a.rulesLoader = new Sys.Element({tag: "div", cls: a.LOADER_CSS + " " + a.LOADER_URI});
        a.fireEvent("view:addToContainer", "settingsWindow", {
            title: Services.languageManager.getText(Language.Keys.gameRules_uc),
            content: a.container
        });
        a.fireEvent("view:addToNavigator", "settingsMenu", {order: 4});
        a.addScrolling();
        if (!a.model.readData("disabled")) {
            a.enable()
        }
        a.hide()
    },
    updateContent: function () {
        var a = this;
        a.rulesWrapper.remove(a.rulesLoader);
        a.rulesWrapper.el.innerHTML = a.model.readData("content");
        a.updateScrollerDimensions()
    },
    show: function () {
        Interface.GameRulesBaseView.superclass.show.apply(this, arguments);
        if (this.model.isState("fetchingGameRules")) {
            this.rulesWrapper.add(this.rulesLoader)
        }
    },
    enable: function () {
    },
    disable: function () {
    },
    disableButton: function () {
        if (Sys.isDefined(this.abstractButton)) {
            this.abstractButton.disable("notInIdleState")
        }
    }
};
Interface.GameRulesBaseView = Sys.extend(Interface.SettingsSectionView, Interface.GameRulesBaseView, "Interface.GameRulesBaseView");
Sys.ns("Interface");
Interface.GameRulesDesktopView = {
    BUTTON_CSS: "interface-desktopSettingsMenu_button interface-gameRules_icon_uri",
    WRAPPER_CSS: "tab interface-settingsWindow_content",
    ENABLED_ONLY_IN_BASIC_GAME: true,
    constructor: function () {
        Interface.GameRulesDesktopView.superclass.constructor.apply(this, arguments)
    },
    setUpContent: function () {
        var a = this;
        a.containerWrapper = new Sys.Element({id: "containerWrapper", tag: "div", cls: a.WRAPPER_CSS});
        a.container = a.containerWrapper.add(new Sys.Element({id: "gameRules", tag: "div", cls: a.BASE_CSS}));
        a.rulesWrapper = a.container.add(new Sys.Element({
            id: "gameRules_rules",
            tag: "div",
            cls: a.RULES_WRAPPER_CSS
        }));
        a.rulesLoader = new Sys.Element({tag: "div", cls: a.LOADER_CSS + " " + a.LOADER_URI});
        a.createButton();
        a.fireEvent("view:addToContainer", "settingsWindow", {
            title: Services.languageManager.getText(Language.Keys.gameRules_uc),
            content: a.containerWrapper
        });
        a.fireEvent("view:addToNavigator", "desktopSettingsMenu", {order: 4, element: a.menuButton});
        a.addScrolling();
        if (!a.model.readData("disabled")) {
            a.enable()
        }
        a.hide()
    },
    createButton: function () {
        var a = this;
        a.menuButton = new Sys.Element({id: "gameRulesButton", tag: "div", cls: a.BUTTON_CSS});
        a.abstractButton = new Interface.AbstractButton({
            dimensions: a.menuButton.el, clickCallback: function () {
                if (!a.model.readData("showing")) {
                    a.fireEvent("view:showRequest")
                } else {
                    a.fireEvent("view:hideRequest")
                }
            }, hoverCallback: function () {
                a.menuButton.addCls("hover")
            }, upCallback: function () {
                a.menuButton.removeCls("hover")
            }
        })
    },
    hide: function () {
        this.containerWrapper.el.style.display = "none";
        Interface.GameRulesDesktopView.superclass.hide.apply(this, arguments)
    },
    show: function () {
        this.containerWrapper.el.style.display = "block";
        Interface.GameRulesDesktopView.superclass.show.apply(this, arguments)
    },
    disableButton: function () {
        this.abstractButton.disable("notInIdleState")
    }
};
Interface.GameRulesDesktopView = Sys.extend(Interface.GameRulesBaseView, Interface.GameRulesDesktopView, "Interface.GameRulesDesktopView");
Sys.ns("Interface");
Interface.Paytable = {
    constructor: function () {
        Interface.Paytable.superclass.constructor.apply(this, arguments)
    }, getMixinDependencies: function () {
        return {fallback: ["userInput", "orientation"], desktop: ["animation", "userInput"]}
    }, getDefaultMVCClasses: function () {
        return {
            controller: Interface.PaytableController,
            model: Interface.PaytableModel,
            view: Interface.PaytableBaseView
        }
    }
};
Interface.Paytable = Sys.extend(Interface.SettingsSection, Interface.Paytable, "Interface.Paytable");
Sys.ns("Interface");
Interface.PaytableController = {
    constructor: function () {
        Interface.PaytableController.superclass.constructor.apply(this, arguments)
    }, setupEvents: function () {
        var a = this;
        a.on({
            "request:paytable.forward": a.onForwardRequest,
            "request:paytable.backward": a.onBackwardRequest,
            "notify:responseParser.paytableResponseParsed": a.onPaytableResponse,
            "view:pageSwitch": a.fireEvent.bind(a, "notify:paytable.pageSwitched"),
            "notify:gameModeChanged": a.onGameModeChanged
        });
        Interface.PaytableController.superclass.setupEvents.apply(a, arguments)
    }, setUpContent: function () {
        this.fireEvent("request:serverManager.sendAction", "paytable", "notify:responseParser.paytableResponseParsed")
    }, onPaytableResponse: function (a) {
        this.model.processPaytableResponse(a);
        this.view.setUpContent()
    }, onShowRequest: function (a) {
        var b = this;
        if (!b.model.readData("showing")) {
            Interface.PaytableController.superclass.onShowRequest.apply(b, arguments)
        } else {
            b.view.show(a)
        }
    }, onForwardRequest: function () {
        if (this.model.readData("showing")) {
            this.view.showNextPage()
        }
    }, onBackwardRequest: function () {
        if (this.model.readData("showing")) {
            this.view.showPreviousPage()
        }
    }, onGameModeChanged: function (a) {
        if (Sys.isDefined(this.view.showButton) && Sys.isDefined(this.view.hideButton)) {
            if (a === "BASIC") {
                this.view.showButton()
            } else {
                this.view.hideButton()
            }
        }
    }
};
Interface.PaytableController = Sys.extend(Interface.SettingsSectionController, Interface.PaytableController, "Interface.PaytableController");
Sys.ns("Interface");
Interface.PaytableModel = {
    constructor: function () {
        Interface.PaytableModel.superclass.constructor.apply(this, arguments)
    }, setNumberOfPages: function (a) {
        Services.storage.storeData("paytable.numberOfPages", a)
    }, setCurrentPage: function (a) {
        Services.storage.storeData("paytable.currentPage", a)
    }, processPaytableResponse: function (a) {
        var b = this, c = a.pt, d = {};
        Sys.iterate(c, function (f, e) {
            b.parseGameMode(f, e, d)
        });
        b.storeData("paytableInfo", d)
    }, parseGameMode: function (c, a, e) {
        var d = this, b = {scatterWins: {}, betlineWins: {}};
        Sys.iterate(a.comp, function (f, g) {
            d.parsePaytableComponent(f, g, b)
        });
        e[a.id] = b
    }, parsePaytableComponent: function (b, d, a) {
        var g = d.symbol, c = d.type + "Wins", f = d.n, e;
        if (d.type !== "scatter" && d.type !== "betline") {
            return
        }
        if (!Sys.isDefined(a[c][g])) {
            a[c][g] = {freeSpins: [], betMultiplier: []}
        }
        e = a[c][g];
        e.freeSpins[f] = d.freespins;
        e.betMultiplier[f] = d.multi
    }, getCondensedInfo: function (b, a, c, f) {
        var h = this.readData("paytableInfo")[f || "basic"][c || "betlineWins"][b][a || "betMultiplier"], d = 1, i = 0,
            g = h[0], e = [];
        for (; d < h.length; d++) {
            if (h[d] !== g) {
                e.push({from: i, to: d - 1, value: g});
                i = d;
                g = h[d]
            }
        }
        e.push({from: i, to: d - 1, value: g});
        return e
    }, setupData: function () {
        var a = Game.stage.model.getCurrentReelGroupConfiguration();
        this.storeData("symbolWidth", a.symbolWidth);
        this.storeData("symbolHeight", a.symbolHeight);
        Services.storage.storeData("paytable.showing", false)
    }
};
Interface.PaytableModel = Sys.extend(Core.Model, Interface.PaytableModel, "Interface.PaytableModel");
Sys.ns("Interface");
Interface.PaytableBaseView = {
    BASE_CSS: "tab interface-paytable_base",
    PORTRAIT_CSS: "interface-paytable_portrait",
    LANDSCAPE_CSS: "interface-paytable_landscape",
    SECTION_CSS: "interface-paytable_section interface-settingsSection_subSection",
    SECTION_SEPARATOR_URI: "interface-settingsSection_subSection_uri",
    HEADING_CSS: "interface-paytable_heading",
    SECTIONS: ["SymbolValues", "Betlines", "Disclaimer"],
    HIGH_WIN: {COLOR: "", SYMBOLS: []},
    MEDIUM_WIN: {COLOR: "", SYMBOLS: []},
    LOW_WIN: {COLOR: "", SYMBOLS: []},
    DISCLAIMER_STRINGS: [Language.Keys.paytable_highest, Language.Keys.paytable_betLineWinsLeftToRightOnly, Language.Keys.paytable_voidAllPays, Language.Keys.paytable_extraInfo],
    constructor: function () {
        Interface.PaytableBaseView.superclass.constructor.apply(this, arguments);
        this.setupContainer();
        this.sectionElements = {}
    },
    setupContainer: function () {
        this.container = new Sys.Element({id: "paytable", tag: "div", cls: this.BASE_CSS})
    },
    setUpContent: function () {
        var a = this;
        a.model.setNumberOfPages(1);
        a.model.setCurrentPage(1);
        a.createSections();
        a.fireEvent("view:addToContainer", "settingsWindow", {
            title: Services.languageManager.getText(Language.Keys.paytable_uc),
            content: a.container
        });
        a.fireEvent("view:addToNavigator", "settingsMenu", {order: 3});
        a.addScrolling();
        if (!a.model.readData("disabled")) {
            a.enable()
        }
        a.hide()
    },
    showNextPage: function () {
    },
    showPreviousPage: function () {
    },
    createSections: function () {
        var c = this, d = c.SECTIONS, a = d.length, b;
        for (b = -1; ++b < a;) {
            if (Sys.isFunc(c["create" + d[b]])) {
                c["create" + d[b]]()
            }
        }
    },
    createSymbolValues: function () {
        var a = this, b = new Sys.Element({tag: "div", "class": a.SECTION_CSS + " " + a.SECTION_SEPARATOR_URI});
        b.add(new Sys.Element({
            tag: "div",
            textContent: Services.languageManager.getText(Language.Keys.paytable_symbolPayout),
            "class": a.HEADING_CSS + " utils_center_text"
        }));
        if (a.HIGH_WIN.SYMBOLS.length > 0) {
            b.add(a.createSymbolSubSection(a.HIGH_WIN.SYMBOLS, a.HIGH_WIN.COLOR))
        }
        if (a.MEDIUM_WIN.SYMBOLS.length > 0) {
            b.add(a.createSymbolSubSection(a.MEDIUM_WIN.SYMBOLS, a.MEDIUM_WIN.COLOR))
        }
        if (a.LOW_WIN.SYMBOLS.length > 0) {
            b.add(a.createSymbolSubSection(a.LOW_WIN.SYMBOLS, a.LOW_WIN.COLOR))
        }
        a.sectionElements.SymbolValues = b;
        a.container.add(b)
    },
    createSymbolSubSection: function (d, c) {
        var f = this, b = new Sys.Element({tag: "table", "class": "interface-paytable_symbols"}), a = d.length, g, e;
        for (e = -1; ++e < a;) {
            if (e % 2 === 0) {
                g = b.add(new Sys.Element({tag: "tr"}))
            }
            f.appendSymbolContainer(g, d[e], c)
        }
        return b
    },
    appendSymbolContainer: function (a, d, e, b, f, l) {
        var j = Resources.readData("animationImages"), o = this.model.readData("symbolHeight"),
            c = a.add(new Sys.Element({tag: "td", style: "min-height: " + o + "px; text-align: center;"})),
            h = this.model.getCondensedInfo(d, b, f, l).sort(function (p, i) {
                return i.from - p.from
            }), k = h.length, n, m, g;
        if (Sys.isDefined(j[d])) {
            c.el.appendChild(j[d])
        }
        n = a.add(new Sys.Element({tag: "td", style: "min-height: " + o + "px;"})).add(new Sys.Element({
            tag: "ul",
            "class": "interface-paytable_symbolValues"
        }));
        for (g = -1; ++g < k;) {
            m = h[g];
            if (Sys.isDefined(m.value)) {
                n.add(new Sys.Element({tag: "li", textContent: m.from, style: "width: 33%; color: " + e + ";"}));
                n.add(new Sys.Element({tag: "li", textContent: m.value, style: "width: 66%;"}))
            }
        }
    },
    createBetlines: function () {
        var b = this, a = Resources.readData("animationImages"),
            c = new Sys.Element({tag: "div", "class": b.SECTION_CSS + " utils_center_text " + b.SECTION_SEPARATOR_URI});
        c.add(new Sys.Element({
            tag: "div",
            textContent: Services.languageManager.getText(Language.Keys.paytable_winningBetLinesHeading),
            "class": b.HEADING_CSS
        }));
        if (Sys.isObj(a) && Sys.isDefined(a.betlines)) {
            c.el.appendChild(a.betlines)
        }
        b.sectionElements.Betlines = c;
        b.container.add(c)
    },
    createDisclaimer: function () {
        var c = this,
            d = new Sys.Element({tag: "div", "class": c.SECTION_CSS + " utils_center_text " + c.SECTION_SEPARATOR_URI}),
            a = c.DISCLAIMER_STRINGS, e = a.length, b;
        for (b = -1; ++b < e;) {
            d.add(new Sys.Element({tag: "div", textContent: Services.languageManager.getText(a[b])}))
        }
        c.sectionElements.Disclaimer = d;
        c.container.add(d)
    }
};
Interface.PaytableBaseView = Sys.extend(Interface.SettingsSectionView, Interface.PaytableBaseView, "Interface.PaytableBaseView");
Sys.ns("Interface");
Interface.PaytableDesktopView = {
    BASE_CSS: "tab interface-paytableDesktop_base",
    KEYPAD_BUTTON_CONFIG: {
        dimensions: {x: 50, y: 623, width: 52, height: 52},
        buttonImages: {
            up: "paytableButtonUp",
            down: "paytableButtonDown",
            hover: "paytableButtonOver",
            disabled: "paytableButtonDisabled"
        }
    },
    constructor: function () {
        Interface.PaytableDesktopView.superclass.constructor.apply(this, arguments)
    },
    show: function (b) {
        var c = this, a = c.navigation.getCurrentCardIndex();
        Interface.PaytableDesktopView.superclass.show.apply(c, arguments);
        if (Sys.isNumber(b) && b > 0 && b <= c.SECTIONS.length) {
            a = b - 1
        }
        c.navigation.selectCard(a);
        c.navigation.enable(c.MODULE_NAME)
    },
    hide: function () {
        var c = this, e, d, a, b;
        Interface.PaytableDesktopView.superclass.hide.apply(c, arguments);
        e = c.SECTIONS;
        d = c.sectionElements;
        a = e.length;
        for (b = -1; ++b < a;) {
            d[e[b]].el.style.display = "none"
        }
        c.navigation.disable(c.MODULE_NAME)
    },
    showNextPage: function () {
        this.navigation.next()
    },
    showPreviousPage: function () {
        this.navigation.previous()
    },
    enable: function (a) {
        if (this.animationsReady) {
            this.button.enable(a)
        }
    },
    disable: function (a) {
        if (this.animationsReady) {
            this.button.disable(a)
        }
    },
    setUpContent: function () {
        var a = this;
        a.model.setNumberOfPages(a.SECTIONS.length);
        a.model.setCurrentPage(1);
        a.createSections();
        a.createNavigation();
        a.fireEvent("view:addToContainer", "settingsWindow", {
            title: Services.languageManager.getText(Language.Keys.paytable_uc),
            content: a.container
        });
        a.addScrolling();
        if (!a.model.readData("disabled")) {
            a.enable()
        }
        a.hide()
    },
    createNavigation: function () {
        var a = this;
        a.navigation = new Interface.utils.CardNavigation({
            id: "paytableNavigation",
            numCards: this.SECTIONS.length,
            selectionCallback: a.onCardSelection.bind(a),
            closeCallback: a.onCloseCallback.bind(a),
            arrowLabels: {next: "Next", previous: "Previous"}
        });
        a.subComponents = [a.navigation];
        a.container.add(a.navigation.getArrows());
        a.container.add(a.navigation.getIndicators())
    },
    onCardSelection: function (b, e, a) {
        var c = this, d;
        c.hideSection(e);
        c.showSection(b);
        c.model.setCurrentPage(b + 1);
        if (b !== e) {
            d = (b > e) ? "forward" : "backward";
            if (a) {
                d = (b < e) ? "forward" : "backward"
            }
            c.fireEvent("view:pageSwitch", d)
        }
    },
    onCloseCallback: function () {
        this.fireEvent("view:hideRequest")
    },
    showSection: function (a) {
        this.sectionElements[this.SECTIONS[a]].el.style.display = "block"
    },
    hideSection: function (a) {
        this.sectionElements[this.SECTIONS[a]].el.style.display = "none"
    },
    showButton: function () {
        if (this.animationsReady) {
            this.button.show("buttonHideRequest");
            this.hidden = false
        }
    },
    hideButton: function () {
        if (this.animationsReady) {
            this.button.hide("buttonHideRequest");
            this.hidden = true
        }
    },
    enableButton: function () {
        if (!this.hidden) {
            this.button.enable("buttonDisableRequest")
        }
    },
    disableButton: function () {
        if (!this.hidden) {
            this.button.disable("buttonDisableRequest")
        }
    },
    initAnimations: function () {
        var b = this, a = Sys.applyProperties({clickCallback: b.onButtonClick.bind(b)}, b.KEYPAD_BUTTON_CONFIG);
        if (Sys.isDefined(a.buttonLabel)) {
            a.buttonLabel.depth = Layering.Game.Slots.Keypad.paytable.label
        }
        if (Sys.isDefined(a.buttonLayoutParameters)) {
            a.buttonLayoutParameters.depth = Layering.Game.Slots.Keypad.paytable.button
        } else {
            a.dimensions.depth = Layering.Game.Slots.Keypad.paytable.button
        }
        b.button = new Interface.utils.CanvasButton(a);
        b.button.id = "paytable";
        b.animationsReady = true
    },
    onButtonClick: function () {
        if (!this.model.readData("showing")) {
            this.fireEvent("view:showRequest")
        } else {
            this.fireEvent("view:hideRequest")
        }
    },
    shouldBeHiddenByUserInput: function () {
        return false
    },
    onDisableBasicGamePanel: function () {
        this.disable("disableBasicGamePanel")
    },
    onEnableBasicGamePanel: function () {
        this.enable("disableBasicGamePanel")
    },
    onScroll: function () {
    }
};
Interface.PaytableDesktopView = Sys.extend(Interface.PaytableBaseView, Interface.PaytableDesktopView, "Interface.PaytableDesktopView");
Sys.ns("Interface");
Interface.SpinSettingsBase = {
    constructor: function () {
        Interface.SpinSettingsBase.superclass.constructor.apply(this, arguments)
    }, getDefaultMVCClasses: function () {
        return {
            controller: Interface.SpinSettingsBaseController,
            model: Interface.SpinSettingsBaseModel,
            view: Core.View
        }
    }
};
Interface.SpinSettingsBase = Sys.extend(Interface.SettingsSection, Interface.SpinSettingsBase, "Interface.SpinSettingsBase");
Sys.ns("Interface");
Interface.SpinSettingsBaseController = {
    constructor: function () {
        Interface.SpinSettingsBaseController.superclass.constructor.apply(this, arguments)
    }, setupEvents: function () {
        var a = this;
        Interface.SpinSettingsBaseController.superclass.setupEvents.apply(a, arguments);
        a.on({
            "request:spinSettings.showStopIfFreeSpinsWon": a.showStopIfFreeSpinsWon,
            "request:spinSettings.showStopIfAutoplayingBonusGameWon": a.showStopIfAutoplayingBonusGameWon,
            "request:spinSettings.startAutoPlay": a.onStartAutoPlay,
            "notify:settingsManager.settingChanged": a.onSettingChanged,
            "notify:settingsManager.settingEnabled": a.onSettingEnabled,
            "notify:settingsManager.settingDisabled": a.onSettingDisabled,
            "notify:settingsManager.settingLocked": a.onSettingLocked,
            "notify:settingsManager.unlockSetting": a.onSettingUnlocked,
            "notify:moneyManager.betChanged": a.onBetChanged,
            "notify:stateHandler.enteringSetupGameState": a.checkIfAutoplayDisabled
        })
    }, onStartAutoPlay: function () {
        if (this.canStartAutoplay()) {
            this.fireEvent("request:autoPlayer.start")
        } else {
            this.showWarningDialog()
        }
    }, checkIfAutoplayDisabled: function () {
        var b = this, a = b.model.getAutoplaySpinsArray();
        if (a.length === 1 && (a[0] < 5 || a[0] > 1000)) {
            b.fireEvent("request:settingsManager.disableSetting", "autoPlayNrSpins");
            b.fireEvent("request:settingsManager.storeData", "autoPlayNrSpins", 0);
            b.fireEvent("request:settingsManager.lockSetting", "autoPlayNrSpins", b.MODULE_NAME)
        }
    }, onSettingChanged: function (a, c) {
        var b = this;
        if (a === "autoPlayNrSpins") {
            if (c === 0) {
                c = b.model.getAutoplaySpinsArray()[0]
            }
            b.model.storeData(a, c);
            b.view.update()
        }
    }, onBetChanged: function () {
        var a = Services.settingsManager.getSetting("autoPlayNrSpins");
        if (a > 0 && !this.canStartAutoplay()) {
            this.showWarningDialog()
        }
    }, canStartAutoplay: function () {
        var e = Services.moneyManager.getBetCents(), b = this.model.readData("isRestrictedMode"),
            c = Services.settingsManager.getSetting("stopAutoplayIfBalanceDecreasedBy"),
            d = this.model.readData("freeRoundsActive"), a = e <= c;
        if (b || c > 0) {
            return d || a
        }
        return true
    }, onSettingDisabled: function (a) {
        this.view.removeSetting(a)
    }, onSettingEnabled: function () {
    }, onSettingLocked: function (a) {
        this.view.lockSetting(a)
    }, onSettingUnlocked: function (a) {
        this.view.unlockSetting(a)
    }, onUserAction: function (a, b) {
        this.model.storeData(a, b);
        if (a === "autoPlayNrSpins" && isNaN(Number(b))) {
            b = 0
        }
        this.fireEvent("request:settingsManager.storeData", a, b)
    }, showWarningDialog: function () {
        var b = this, a = Services.languageManager;
        if (Environment.getCurrentPlatform() === "desktop") {
            b.fireEvent("request:dialogWindow.showDialog", {
                title: a.getText(Language.Keys.autoplay_setting_ifCashDecreasesBy),
                text: a.getText(Language.Keys.autoplay_setting_ifCashDecreasesByWarning),
                buttons: [{text: a.getText(Language.Keys.btn_ok)}]
            })
        } else {
            b.fireEvent("request:dialogWindow.showDialog", {
                title: a.getText(Language.Keys.autoplay_setting_ifCashDecreasesBy),
                text: a.getText(Language.Keys.autoplay_setting_ifCashDecreasesByWarningTouch),
                buttons: [{
                    text: a.getText(Language.Keys.btn_close), action: function () {
                        b.fireEvent("request:autoPlayer.stop")
                    }
                }, {
                    text: a.getText(Language.Keys.btn_ok), action: function () {
                        b.fireEvent("request:spinSettings.openAdvancedSettingKeyboard", "stopAutoplayIfBalanceDecreasedBy")
                    }
                }]
            })
        }
    }, showStopIfFreeSpinsWon: function () {
    }, showStopIfAutoplayingBonusGameWon: function () {
    }
};
Interface.SpinSettingsBaseController = Sys.extend(Interface.SettingsSectionController, Interface.SpinSettingsBaseController, "Interface.SpinSettingsBaseController");
Sys.ns("Interface");
Interface.SpinSettingsBaseModel = {
    AUTOPLAY_SPINS: [0, 10, 25, 50, 100, 250, 500, 750, 1000], constructor: function () {
        Interface.SpinSettingsBaseModel.superclass.constructor.apply(this, arguments)
    }, setupData: function () {
        var d = this, b = Resources.readData("gameServerInitResponseObject").autoplay, a, c;
        if (Sys.isDefined(b) && ((b === 0 || d.validateSingleAutoPlayValue(b) || d.validateAutoplayArray(b)))) {
            if (!Sys.isArray(b)) {
                b = [b]
            } else {
                b = b.slice()
            }
            if (!b.contains(0)) {
                b = [0].concat(b)
            }
            b.sort(function (f, e) {
                return f - e
            })
        } else {
            b = d.AUTOPLAY_SPINS
        }
        a = [{
            key: "autoPlayNrSpins",
            defaultValue: b[0],
            settingsManager: true,
            localStorage: false
        }, {key: "autoplaySpinsArray", defaultValue: b, settingsManager: false, localStorage: false}];
        a.forEach(d.initData, d);
        Services.storage.storeData("spinSettings.autoplayRoundsAvailable", b.slice(1));
        Interface.SpinSettingsBaseModel.superclass.setupData.apply(this, arguments);
        c = Resources.readData("gameServerInitResponse").autoplayLossLimitEnabled || false;
        this.storeData("isRestrictedMode", c)
    }, validateAutoplayArray: function (a) {
        var b = this, c = true, d = a.length;
        if (Sys.isArray(a) && d > 0 && d < 9) {
            Sys.each(a, function (f, e) {
                a[e] = Sys.utils.toInt(f);
                if (!b.validateSingleAutoPlayValue(a[e])) {
                    c = false
                }
            })
        } else {
            c = false
        }
        return c
    }, validateSingleAutoPlayValue: function (a) {
        var b = true, c = Sys.utils.toInt(a);
        if (Sys.isArray(a) || isNaN(c) || c < 5 || c > 1000) {
            b = false
        }
        return b
    }, getAutoplaySpinsArray: function () {
        return this.readData("autoplaySpinsArray")
    }
};
Interface.SpinSettingsBaseModel = Sys.extend(Interface.SettingsSectionModel, Interface.SpinSettingsBaseModel, "Interface.SpinSettingsBaseModel");
Sys.ns("Interface");
Interface.SpinSettings = {
    constructor: function () {
        Interface.SpinSettings.superclass.constructor.apply(this, arguments)
    }, getDefaultMVCClasses: function () {
        return {
            controller: Interface.SpinSettingsController,
            model: Interface.SpinSettingsModel,
            view: Interface.SpinSettingsView
        }
    }
};
Interface.SpinSettings = Sys.extend(Interface.SpinSettingsBase, Interface.SpinSettings, "Interface.SpinSettings");
Sys.ns("Interface");
Interface.SpinSettingsModel = {
    setupData: function () {
        var b = this, a = [{
            key: "stopAutoplayIfBalanceDecreasedBy",
            defaultValue: false,
            settingsManager: true,
            localStorage: true
        }, {key: "leftHandMode", defaultValue: false, settingsManager: true, localStorage: true}, {
            key: "quickSpin",
            defaultValue: false,
            settingsManager: true,
            localStorage: true
        }, {
            key: "stopAutoplayIfFreeSpinWon",
            defaultValue: false,
            settingsManager: true,
            localStorage: false
        }, {
            key: "stopAutoplayIfAutoplayingBonusGameWon",
            defaultValue: false,
            settingsManager: true,
            localStorage: false
        }, {key: "stopAutoplayIfWinExceeds", defaultValue: false, settingsManager: true, localStorage: false}];
        Interface.SpinSettingsModel.superclass.setupData.apply(this, arguments);
        a.forEach(b.initData, b)
    }
};
Interface.SpinSettingsModel = Sys.extend(Interface.SpinSettingsBaseModel, Interface.SpinSettingsModel, "Interface.SpinSettingsModel");
Sys.ns("Interface");
Interface.SpinSettingsController = {
    constructor: function () {
        Interface.SpinSettingsController.superclass.constructor.apply(this, arguments)
    }, setupEvents: function () {
        var a = this;
        Interface.SpinSettingsController.superclass.setupEvents.apply(a, arguments);
        a.on({
            "request:spinSettings.openAdvancedSettingKeyboard": a.openAdvancedSettingsKeyboard,
            "notify.dialogWindow.showingDialog": a.onShowingDialog,
            "view:autoPlaySliderEnd": a.userInteractionEnded,
            "notify:freeRounds.started": a.view.onFreeRoundsStateChange.bind(a.view, true),
            "notify:freeRounds.ended": a.view.onFreeRoundsStateChange.bind(a.view, false)
        })
    }, userInteractionEnded: function (c) {
        var b = this, a = b.model.readData("isRestrictedMode");
        if (a === true && c > 0) {
            b.fireEvent("request:userInputManager.activateExclusivity", "spinSettings.addingValue");
            b.addValueToLossLimit()
        }
    }, onBetChanged: function (a) {
        var b = this;
        Interface.SpinSettingsController.superclass.onBetChanged.apply(b, arguments);
        if (b.view.advancedSettings && b.view.advancedSettings.stopAutoplayIfBalanceDecreasedBy) {
            b.view.advancedSettings.stopAutoplayIfBalanceDecreasedBy.setMinValue(a.playerBetCents > 0 ? a.playerBetCents : undefined)
        }
    }, onUserAction: function (c, e) {
        var d = this, b = d.model.readData("isRestrictedMode"), a = d.model.readData("freeRoundsActive") || false;
        Interface.SpinSettingsController.superclass.onUserAction.apply(this, arguments);
        if (c === "leftHandMode" || c === "quickSpin") {
            Services.localStorageManager.storeData(c, e.toString())
        }
        if (c === "autoPlayNrSpins") {
            this.enableAdvancedSettings(e)
        }
        if (b === true && c === "stopAutoplayIfBalanceDecreasedBy" && e === 0 && !a) {
            Services.settingsManager.storeSetting("autoPlayNrSpins", 0)
        }
    }, enableAdvancedSettings: function (d) {
        var c = this, a = c.model.readData("isRestrictedMode"), e = c.model.readData("freeRoundsActive"),
            b = Services.settingsManager.getSetting("stopAutoplayIfBalanceDecreasedBy") || 0;
        d = Sys.isDefined(d) ? d : 0;
        if (d > 0) {
            c.view.showAdvancedSettings();
            c.view.enableAdvancedSettings()
        } else {
            c.view.hideAdvancedSettings();
            c.view.disableAdvancedSettings()
        }
        if (a === true && !e && b === 0) {
            c.view.disableAdvancedSettings()
        }
    }, onSettingChanged: function (c, e) {
        var d = this, b = d.model.readData("isRestrictedMode"), a = d.model.readData("freeRoundsActive") || false;
        Interface.SpinSettingsController.superclass.onSettingChanged.apply(d, arguments);
        if (c === "quickSpin") {
            d.model.storeData(c, e);
            d.view.update()
        }
        if (b === true && c === "stopAutoplayIfBalanceDecreasedBy" && e === 0 && !a) {
            Services.settingsManager.storeSetting("autoPlayNrSpins", 0)
        }
    }, showStopIfAutoplayingBonusGameWon: function () {
        this.view.showStopIfAutoplayingBonusGameWon()
    }, openAdvancedSettingsKeyboard: function (b) {
        var a = this;
        a.fireEvent("request:settingsWindow.openChild", "spinSettings");
        a.view.openAdvancedSetting(b)
    }, addValueToLossLimit: function () {
        var c = this, b = Services.settingsManager.getSetting("stopAutoplayIfBalanceDecreasedBy"),
            a = c.model.readData("freeRoundsActive");
        if ((!b || b === 0) && !a) {
            setTimeout(function () {
                c.fireEvent("request:userInputManager.deactivateExclusivity", "spinSettings.addingValue");
                c.view.openAdvancedSetting("stopAutoplayIfBalanceDecreasedBy");
                c.view.enableAdvancedSettings()
            }, 1000)
        } else {
            c.fireEvent("request:userInputManager.deactivateExclusivity", "spinSettings.addingValue");
            c.view.enableAdvancedSettings()
        }
    }, onShowingDialog: function () {
        if (this.model.readData("showing")) {
            this.fireEvent("request:keyboard.cancel")
        }
    }
};
Interface.SpinSettingsController = Sys.extend(Interface.SpinSettingsBaseController, Interface.SpinSettingsController, "Interface.SpinSettingsController");
Sys.ns("Interface");
Interface.SpinSettingsView = {
    BASE_CSS: "tab interface-spinSettings_base",
    PORTRAIT_CSS: "interface-spinSettings_portrait",
    LANDSCAPE_CSS: "interface-spinSettings_landscape",
    SECTION_CSS: "interface-settingsSection_subSection",
    SECTION_SEPARATOR_URI: "interface-settingsSection_subSection_uri",
    AUTOPLAY_SETTINGS_CSS: "interface-spinSettings_autoPlayContainer",
    AUTO_PLAY_ADDVALUE: "ifCashDecreasesByAddValue",
    AUTOPLAYING_BONUS_GAME_LABEL: Language.Keys.autoplay_setting_ifFBonusIsStarted,
    FREEROUND_ACTIVE_CONTROLS: ["stopAutoplayIfFreeSpinWon", "stopIfAutoplayingBonusGameWon"],
    ADVANCED_AUTOPLAY_SETTINGS: {
        stopAutoplayTitle: {
            labelOCTKey: Language.Keys.autoplay_setting_stopAutoPlay,
            type: "settingGroupTitle"
        },
        stopAutoplayIfBalanceDecreasedBy: {
            labelOCTKey: Language.Keys.autoplay_setting_ifCashDecreasesBy,
            buttonTextOCTKey: Language.Keys.btn_addValue,
            infoOCTKey: Language.Keys.autoplay_setting_ifCashDecreasesByInfoTouch,
            type: "interactiveContainer",
            defaultValue: 0
        },
        stopAutoplayIfWinExceeds: {
            labelOCTKey: Language.Keys.autoplay_setting_ifWinExeeds,
            buttonTextOCTKey: Language.Keys.btn_addValue,
            type: "interactiveContainer",
            defaultValue: 0
        },
        stopAutoplayIfBalanceIncreasedBy: {
            labelOCTKey: Language.Keys.autoplay_setting_ifCashIncreasesBy,
            buttonTextOCTKey: Language.Keys.btn_addValue,
            type: "interactiveContainer",
            defaultValue: 0
        },
        stopAutoplayIfFreeSpinWon: {
            type: "ToggleSwitch",
            titleOCTKey: Language.Keys.stopIfFreeSpins,
            defaultValue: false
        }
    },
    constructor: function () {
        Interface.SpinSettingsView.superclass.constructor.apply(this, arguments);
        this.lockedControllers = []
    },
    setUpContent: function () {
        var a = this, b;
        a.container = new Sys.Element({id: "spinSettings", tag: "div", cls: a.BASE_CSS});
        a.autoplayContainer = a.container.add(new Sys.Element({
            id: "spinSettings_autoplaySettings",
            tag: "div",
            cls: a.SECTION_CSS + " " + a.AUTOPLAY_SETTINGS_CSS
        }));
        a.numberOfAutoPlaysSetting = a.autoplayContainer.add(new Sys.Element({
            id: "nrOfAutoplaySpins",
            tag: "ul",
            "class": "interface-settingsSection_dynamicSliderPosition_container"
        }));
        a.nrOfSpinsText = a.numberOfAutoPlaysSetting.add(new Sys.Element({
            id: "nrAutoPlaySpinsLabel",
            tag: "li",
            "class": "interface-settingsSection_dynamicSliderPosition_label",
            textContent: Services.languageManager.getText(Language.Keys.autoplay)
        }));
        a.nrAutoPlaySpins = new Interface.utils.Slider({
            id: "nrAutoPlaySpinsSlider",
            values: a.model.getAutoplaySpinsArray(),
            callback: a.onSettingsControllerChanged.bind(a, "autoPlayNrSpins"),
            endCallback: a.fireEvent.bind(a, "view:autoPlaySliderEnd"),
            showLabels: true
        });
        a.advancedAutoplaySettings = a.autoplayContainer.add(new Sys.Element({
            id: "advancedAutoplaySettings",
            tag: "div",
            cls: "interface-autoPlay_advancedSettings_container",
            transitionend: this.updateScrollerDimensions.bind(this)
        }));
        a.initAdvancedAutoplaySettings();
        a.numberOfAutoPlaysSetting.add(new Sys.Element({
            id: "nrAutoPlaySpinsSliderWrapper",
            tag: "li",
            "class": "interface-settingsSection_dynamicSliderPosition_slider"
        })).add(a.nrAutoPlaySpins.getContainer());
        a.stopIfAutoplayingBonusGameWon = new Interface.utils.ToggleSwitch({
            id: "stopIfAutoplayingBonusGameWon",
            title: Services.languageManager.getText(a.AUTOPLAYING_BONUS_GAME_LABEL),
            callback: a.onSettingsControllerChanged.bind(a, "stopAutoplayIfAutoplayingBonusGameWon")
        });
        b = a.stopIfAutoplayingBonusGameWon.getContainer();
        a.stopIfAutoplayingBonusGameWonOriginalDisplay = b.el.style.display;
        b.el.style.display = "none";
        a.autoplayContainer.add(b);
        a.quickSpinContainer = a.container.add(new Sys.Element({
            id: "spinSettings_quickSpinSettings",
            tag: "div",
            cls: a.SECTION_CSS + " " + a.SECTION_SEPARATOR_URI
        }));
        a.quickSpin = new Interface.utils.ToggleSwitch({
            id: "quickSpinOnOff",
            title: Services.languageManager.getText(Language.Keys.setting_quickSpinGame),
            callback: a.onSettingsControllerChanged.bind(a, "quickSpin")
        });
        a.quickSpinContainer.add(a.quickSpin.getContainer());
        a.spinButtonPositionContainer = a.container.add(new Sys.Element({
            id: "spinSettings_spinButtonPositionSettings",
            tag: "div",
            cls: a.SECTION_CSS + " " + a.SECTION_SEPARATOR_URI
        }));
        a.spinButtonPosition = new Interface.utils.ToggleSwitch({
            id: "spinButtonPositionLeftRight",
            title: Services.languageManager.getText(Language.Keys.setting_leftHandMode),
            callback: a.onSettingsControllerChanged.bind(a, "leftHandMode")
        });
        a.spinButtonPositionContainer.add(a.spinButtonPosition.getContainer());
        a.addContainerToSettings();
        a.subComponents = [a.quickSpin, a.nrAutoPlaySpins, a.spinButtonPosition];
        a.update();
        a.addScrolling();
        if (!a.model.readData("disabled")) {
            a.enable()
        }
        a.hide()
    },
    addContainerToSettings: function () {
        var a = this;
        a.fireEvent("view:addToContainer", "settingsWindow", {
            title: Services.languageManager.getText(Language.Keys.spinSettings_uc),
            content: a.container
        });
        a.fireEvent("view:addToNavigator", "settingsMenu", {order: 2})
    },
    initAdvancedAutoplaySettings: function () {
        var b = this, d = b.advancedAutoplaySettings, a = Services.languageManager, c;
        b.advancedSettings = {};
        Sys.iterate(b.ADVANCED_AUTOPLAY_SETTINGS, function (f, e) {
            if (f === "stopAutoplayIfBalanceDecreasedBy") {
                c = Services.moneyManager.getBetCents()
            } else {
                c = undefined
            }
            if (e.type === "interactiveContainer") {
                b.advancedSettings[f] = new Interface.utils.InteractiveContainer({
                    title: a.getText(e.labelOCTKey),
                    info: a.hasText(e.infoOCTKey) ? a.getText(e.infoOCTKey) : "",
                    buttonText: a.hasText(e.buttonTextOCTKey) ? a.getText(e.buttonTextOCTKey) : "",
                    id: "advancedSetting-" + f,
                    cls: b.SECTION_CSS + " " + b.SECTION_SEPARATOR_URI,
                    callback: b.onSettingsControllerChanged.bind(b, f),
                    minValue: c
                })
            } else {
                if (e.type === "ToggleSwitch") {
                    b.advancedSettings[f] = new Interface.utils.ToggleSwitch({
                        title: a.getText(e.titleOCTKey),
                        id: "advanceSetting-" + f,
                        cls: b.SECTION_CSS + " " + b.SECTION_SEPARATOR_URI,
                        callback: b.onSettingsControllerChanged.bind(b, f)
                    })
                } else {
                    if (e.type === "settingGroupTitle") {
                        b.advancedSettings[f] = new Interface.utils.GroupTitle({
                            title: a.getText(e.labelOCTKey),
                            id: "advanceSetting-" + f,
                            cls: b.SECTION_CSS,
                            CSS: {disabled: ""}
                        })
                    }
                }
            }
            d.add(b.advancedSettings[f].getContainer())
        })
    },
    showAdvancedSettings: function () {
        this.advancedAutoplaySettings.el.style["max-height"] = "16rem"
    },
    hideAdvancedSettings: function () {
        this.advancedAutoplaySettings.el.style["max-height"] = "0"
    },
    enableAdvancedSettings: function () {
        var a = this;
        Sys.iterate(a.advancedSettings, function (c, d) {
            var b = a.model.readData("freeRoundsActive");
            if (!b || (b && a.FREEROUND_ACTIVE_CONTROLS.contains(c))) {
                d.enable()
            }
        })
    },
    disableAdvancedSettings: function () {
        var a = this;
        Sys.iterate(a.advancedSettings, function (b, c) {
            c.disable()
        })
    },
    openAdvancedSetting: function (a) {
        var b = this.advancedSettings[a];
        if (Sys.isDefined(b)) {
            b.click()
        } else {
        }
    },
    onSettingsControllerChanged: function (b, a) {
        this.fireEvent("view:userAction", b, a)
    },
    enable: function () {
        var a = this;
        a.model.storeData("disabled", false);
        a.callFunctionOnSubComponents("enable");
        Sys.each(a.lockedControllers, function (b) {
            b.disable()
        });
        if (a.nrAutoPlaySpins.getValue() !== a.model.getAutoplaySpinsArray()[0]) {
            a.stopIfAutoplayingBonusGameWon.enable();
            a.enableAdvancedSettings()
        }
    },
    disable: function () {
        var a = this;
        a.callFunctionOnSubComponents("disable");
        a.stopIfAutoplayingBonusGameWon.disable();
        a.disableAdvancedSettings();
        a.spinButtonPosition.enable();
        a.model.storeData("disabled", true)
    },
    update: function () {
        var c = this, b = c.model.readData.bind(c.model), a = !b("disabled"), d = b("autoPlayNrSpins");
        c.nrAutoPlaySpins.setValue(d);
        c.advancedSettings.stopAutoplayIfFreeSpinWon.toggle(b("stopAutoplayIfFreeSpinWon"));
        c.stopIfAutoplayingBonusGameWon.toggle(b("stopAutoplayIfAutoplayingBonusGameWon"));
        c.quickSpin.toggle(b("quickSpin"));
        c.spinButtonPosition.toggle(b("leftHandMode"));
        if (d === c.model.getAutoplaySpinsArray()[0]) {
            c.stopIfAutoplayingBonusGameWon.toggle(false);
            c.stopIfAutoplayingBonusGameWon.disable();
            Sys.iterate(c.ADVANCED_AUTOPLAY_SETTINGS, function (f, e) {
                c.advancedSettings[f].setValue(e.defaultValue)
            })
        } else {
            if (a && !c.stopIfAutoplayingBonusGameWon.isEnabled()) {
                c.stopIfAutoplayingBonusGameWon.enable()
            }
        }
    },
    showStopIfAutoplayingBonusGameWon: function () {
        this.stopIfAutoplayingBonusGameWon.getContainer().el.style.display = this.stopIfAutoplayingBonusGameWonOriginalDisplay
    },
    removeSetting: function (a) {
        var b = this;
        if (a === "quickSpin") {
            b.container.remove(b.quickSpinContainer)
        } else {
            if (a === "autoPlayNrSpins") {
                b.container.remove(b.autoplayContainer)
            }
        }
    },
    lockSetting: function (a) {
        var c = this, b;
        if (a === "autoPlayNrSpins") {
            b = c.nrAutoPlaySpins;
            c.nrOfSpinsText.el.style.opacity = "0.5"
        } else {
            if (a === "quickSpin") {
                b = c.quickSpin
            }
        }
        if (b) {
            b.disable();
            if (!c.lockedControllers.contains(b)) {
                c.lockedControllers.push(b)
            }
        }
    },
    unlockSetting: function (a) {
        var c = this, b;
        if (a === "autoPlayNrSpins") {
            b = c.nrAutoPlaySpins;
            c.nrOfSpinsText.el.style.opacity = ""
        } else {
            if (a === "quickSpin") {
                b = c.quickSpin
            }
        }
        if (b) {
            if (!c.model.readData("disabled")) {
                b.enable()
            }
            if (c.lockedControllers.contains(b)) {
                c.lockedControllers.splice(c.lockedControllers.indexOf(b), 1)
            }
        }
    },
    resetAutoPlay: function () {
    },
    reduceCounter: function () {
    },
    sortControls: function (b) {
        var c = this, a = b || [], d = c.advancedSettings.stopAutoplayIfBalanceDecreasedBy.container;
        if (c.model.readData("freeRoundsActive")) {
            a.forEach(function (e) {
                c.advancedAutoplaySettings.addBefore(e, d)
            })
        } else {
            a.forEach(function (e) {
                c.advancedAutoplaySettings.add(e, d)
            })
        }
    },
    toggleFreeRoundControls: function (b) {
        var c = this, a = b || [], d = [];
        Sys.iterate(c.advancedSettings, function (e, f) {
            if (!a.contains(e)) {
                if (c.model.readData("freeRoundsActive")) {
                    f.disable()
                } else {
                    f.enable()
                }
            } else {
                d.push(c.advancedAutoplaySettings.remove(f.container))
            }
        });
        c.sortControls(d)
    },
    onFreeRoundsStateChange: function (b) {
        var c = this, a = c.FREEROUND_ACTIVE_CONTROLS;
        c.model.storeData("freeRoundsActive", b);
        c.toggleFreeRoundControls(a)
    }
};
Interface.SpinSettingsView = Sys.extend(Interface.SettingsSectionView, Interface.SpinSettingsView, "Interface.SpinSettingsView");
Sys.ns("Interface");
Interface.AutoplaySettings = {
    constructor: function () {
        Interface.AutoplaySettings.superclass.constructor.apply(this, arguments)
    }, getMixinDependencies: function () {
        return ["userInput", "animation"]
    }, getDefaultMVCClasses: function () {
        return {
            model: Interface.AutoplaySettingsModel,
            view: Interface.AutoplaySettingsView,
            controller: Interface.AutoplaySettingsController
        }
    }
};
Interface.AutoplaySettings = Sys.extend(Interface.SpinSettingsBase, Interface.AutoplaySettings, "Interface.AutoplaySettings");
Sys.ns("Interface");
Interface.AutoplaySettingsController = {
    constructor: function () {
        Interface.AutoplaySettingsController.superclass.constructor.apply(this, arguments)
    }, setupEvents: function () {
        var a = this;
        Interface.AutoplaySettingsController.superclass.setupEvents.apply(a, arguments);
        a.on({
            "notify:stateHandler.enteringIdleState": a.onEnteringIdleState,
            "notify:autoPlayer.reduceCounter": a.view.reduceCounter.bind(a.view),
            "notify:autoPlayer.starting": a.view.onAutoplayStarting.bind(a.view),
            "notify:freeRounds.started": a.view.onFreeRoundsStateChange.bind(a.view, true),
            "notify:freeRounds.ended": a.view.onFreeRoundsStateChange.bind(a.view, false),
            "request:autoplaySettings.close": a.onHideRequest,
            "request:closeOpenWindows": a.onHideRequest,
            "request:autoplaySettings.toggle": a.toggle,
            "request:enableBasicGamePanel": a.view.enableKeypadButton.bind(a.view),
            "request:disableBasicGamePanel": a.view.disableKeypadButton.bind(a.view),
            "notify:gameModeChanged": a.onGameModeChanged,
            "view:startAutoPlay": a.onStartAutoPlay,
            "view:stopAutoPlay": a.onStopAutoPlay,
            "view:autoPlayActive": a.onAutoPlayActive
        })
    }, onStartAutoPlay: function () {
        var a = this;
        if (a.canStartAutoplay()) {
            a.fireEvent("request:autoPlayer.start")
        } else {
            a.resetAutoPlay();
            a.showWarningDialog()
        }
    }, onEnteringIdleState: function () {
        var a = this;
        Interface.AutoplaySettingsController.superclass.onEnteringIdleState.apply(a, arguments);
        if (a.model.readData("autoPlayNrSpins") === 0) {
            a.view.resetAutoPlay();
            a.model.storeData("autoPlayActive", false)
        }
    }, onShowRequest: function () {
        var a = this;
        if (!a.model.readData("disabled")) {
            a.fireEvent("request:gameSettings.close");
            Interface.AutoplaySettingsController.superclass.onShowRequest.apply(this, arguments)
        }
    }, onAutoPlayActive: function () {
        this.model.storeData("autoPlayActive", true);
        this.view.update()
    }, onStopAutoPlay: function () {
        this.fireEvent("request:autoPlayer.stop")
    }, toggle: function () {
        if (this.model.readData("showing")) {
            this.onHideRequest()
        } else {
            this.onShowRequest()
        }
    }, onSettingDisabled: function (a) {
        this.view.hideSetting(a)
    }, onSettingEnabled: function (a) {
        this.view.showSetting(a)
    }, onSettingChanged: function (a, b) {
        Interface.AutoplaySettingsController.superclass.onSettingChanged.apply(this, arguments);
        this.view.advancedListChanged(a, b)
    }, onSettingLocked: function (a) {
        if (a === "autoPlayNrSpins") {
            this.onHideRequest();
            this.disable("autoplayLocked");
            this.view.disableKeypadButton("autoplayLocked")
        }
    }, onSettingUnlocked: function (a) {
        if (a === "autoPlayNrSpins") {
            this.enable("autoplayLocked");
            this.view.enableKeypadButton("autoplayLocked")
        }
    }, onGameModeChanged: function (a) {
        if (a === "BASIC") {
            this.view.showKeypadButton("gameModeNotBasic")
        } else {
            this.view.hideKeypadButton("gameModeNotBasic")
        }
    }, showStopIfFreeSpinsWon: function () {
        var a = this;
        a.fireEvent("request:settingsManager.enableSetting", "stopAutoplayIfFreeSpinWon")
    }, showStopIfAutoplayingBonusGameWon: function () {
        this.fireEvent("request:settingsManager.enableSetting", "stopAutoplayIfAutoplayingBonusGameWon")
    }, resetAutoPlay: function () {
        this.view.resetAutoPlay();
        this.model.storeData("autoPlayActive", false);
        this.fireEvent("request:settingsManager.storeData", "autoPlayNrSpins", 0)
    }
};
Interface.AutoplaySettingsController = Sys.extend(Interface.SpinSettingsBaseController, Interface.AutoplaySettingsController, "Interface.AutoplaySettingsController");
Sys.ns("Interface");
Interface.AutoplaySettingsView = {
    MENU_BUTTON_CSS: "interface-desktopSettingsMenu_button interface-autoplaySettings_icon_uri interface-autoplaySettings-menuButton",
    KEYPAD_BUTTON_CONFIG: {
        dimensions: {x: 437, y: 613, width: 143, height: 72},
        buttonImages: {
            up: "autoPlayButtonUp",
            down: "autoPlayButtonDown",
            hover: "autoPlayButtonOver",
            disabled: "autoPlayButtonDisabled"
        },
        buttonLabel: {
            width: 107,
            height: 54,
            text: Language.Keys.btn_autoplay,
            font: "24px NetentStandardUI",
            lineHeight: 24,
            alignment: "center",
            color: "#000000",
            breakOn: "<br>"
        }
    },
    ADVANCED_TOGGLE_CSS: {
        base: "interface-standAloneSettingsSectionToggle_base",
        disabled: "interface-standAloneSettingsSectionToggle_disabled",
        button_wrapper: "interface-standAloneSettingsSectionToggle_wrapper",
        label: "interface-standAloneSettingsSectionToggle_label interface-spinSettings_autoPlayAdvancedToggle_label",
        button_handle: "interface-standAloneSettingsSectionToggle_handle",
        button_background: "interface-standAloneSettingsSectionToggle_background",
        open: "advancedOpen",
        closed: "advancedClosed"
    },
    RESTRICTED_CONFIG_CONTROLS: [],
    FREEROUND_ACTIVE_CONTROLS: ["stopAutoplayOnAnyWin", "stopAutoplayIfFreeSpinWon", "stopIfAutoplayingBonusGameWon"],
    ADVANCED_CONFIG_CONTROLS: [{
        id: "stopAutoplayOnAnyWin",
        label: Language.Keys.autoplay_setting_onAnyWin,
        type: "checkbox"
    }, {
        id: "stopAutoplayIfFreeSpinWon",
        label: Language.Keys.autoplay_setting_ifFreeSpinsIsStarted,
        type: "checkbox",
        disabled: true
    }, {
        id: "stopAutoplayIfAutoplayingBonusGameWon",
        label: Language.Keys.autoplay_setting_ifFBonusIsStarted,
        type: "checkbox",
        disabled: true
    }, {
        id: "stopAutoplayIfWinExceeds",
        label: Language.Keys.autoplay_setting_ifWinExeeds,
        type: "checkbox",
        withInput: {label: undefined}
    }, {
        id: "stopAutoplayIfBalanceIncreasedBy",
        label: Language.Keys.autoplay_setting_ifCashIncreasesBy,
        type: "checkbox",
        withInput: {label: undefined}
    }, {
        id: "stopAutoplayIfBalanceDecreasedBy",
        label: Language.Keys.autoplay_setting_ifCashDecreasesBy,
        type: "checkbox",
        withInput: {label: undefined}
    }],
    ARROW_LEFT_VALUE: "0.54rem",
    RENDER_TARGET: "gameWrapper",
    DISABLE_BUTTON_DURING_SPIN: false,
    ORDER: 3,
    TITLE: Language.Keys.autoplay,
    constructor: function () {
        Interface.AutoplaySettingsView.superclass.constructor.apply(this, arguments)
    },
    init: function () {
        var b = this, a;
        Interface.AutoplaySettingsView.superclass.init.apply(b, arguments);
        b.selectedAutoplayTarget = undefined;
        b.isActive = false;
        b.keypadPendingDisable = [];
        if (b.model.readData("isRestrictedModeEnabled") === true) {
            a = Sys.find(b.ADVANCED_CONFIG_CONTROLS, function (c) {
                return c.id === "stopAutoplayIfBalanceDecreasedBy"
            });
            b.RESTRICTED_CONFIG_CONTROLS.push(a);
            if (b.ADVANCED_CONFIG_CONTROLS.indexOf(a) >= 0) {
                b.ADVANCED_CONFIG_CONTROLS.splice(b.ADVANCED_CONFIG_CONTROLS.indexOf(a), 1)
            }
        }
    },
    setUpContent: function () {
        var a = this;
        Interface.AutoplaySettingsView.superclass.setUpContent.apply(a, arguments);
        a.setupAutoPlayContainer(a.container)
    },
    initAnimations: function () {
        this.setUpKeypadButton()
    },
    setupAutoPlayContainer: function () {
        var a = this;
        a.autoplaySettingsWrapper = a.container.add(new Sys.Element({
            id: "autoplaySettings",
            tag: "div",
            cls: "interface-spinSettings_autoplaySettings_wrapper"
        }));
        if (a.model.readData("isRestrictedModeEnabled") === true) {
            a.setupRestrictedAutoPlayContainer()
        }
        a.setupAdvancedAutoPlayContainer();
        a.setUpAutoplaySpinsSelector();
        a.setUpAutoplayStopControls()
    },
    toggleAdvancedSettings: function () {
        this.advancedSettingsWrapper.toggleClass("advancedSettingsOpen")
    },
    setupAdvancedAutoPlayContainer: function () {
        var c = this, a = new Sys.Element({
            id: "advancedAutoplaySettings",
            tag: "div",
            cls: "interface-spinSettings_autoplayAdvancedSettings_wrapper"
        }), b = Services.moneyManager.getCurrencyIsoName();
        c.ADVANCED_CONFIG_CONTROLS.forEach(function (d) {
            if (Sys.isDefined(d.withInput)) {
                d.withInput.label = b
            }
        });
        c.advancedToggle = new Interface.utils.ToggleSwitch({
            id: "advancedAutoplaySettingsToggle",
            title: Services.languageManager.getText(Language.Keys.autoplay_advancedSettings),
            CSS: c.ADVANCED_TOGGLE_CSS,
            enabled: true,
            callback: c.toggleAdvancedSettings.bind(c)
        });
        a.add(c.advancedToggle.getContainer());
        a.add(c.setupResetButton());
        a.add(c.setupStopAutoPlaySection());
        a.add(c.getDivider());
        c.advancedSettingsWrapper = a;
        c.container.addAsFirst(a);
        c.ADVANCED_CONFIG_CONTROLS.forEach(function (d) {
            c.fireEvent("view:userAction", d.id, false);
            if (Sys.isDefined(d.disabled)) {
                c.hideSetting(d.id);
                c.fireEvent("view:disableSetting", d.id)
            }
        })
    },
    setupRestrictedAutoPlayContainer: function () {
        var c = this, a = new Sys.Element({
            id: "restrictedAutoplaySettings",
            tag: "div",
            cls: "interface-spinSettings_autoplayAdvancedSettings_wrapper"
        }), b = Services.moneyManager.getCurrencyIsoName();
        c.RESTRICTED_CONFIG_CONTROLS.forEach(function (d) {
            if (Sys.isDefined(d.withInput)) {
                d.withInput.label = b
            }
        });
        c.restrictedWrapper = a.add(c.setupRestrictedStopAutoPlaySection());
        a.add(c.getDivider());
        c.container.addAsFirst(a);
        c.RESTRICTED_CONFIG_CONTROLS.forEach(function (d) {
            c.fireEvent("view:userAction", d.id, false);
            if (Sys.isDefined(d.disabled)) {
                c.hideSetting(d.id);
                c.fireEvent("view:disableSetting", d.id)
            }
        })
    },
    setupStopAutoPlaySection: function () {
        var a = this, c = new Sys.Element({
            id: "advancedSettings",
            tag: "div",
            cls: "interface-spinSettings_autoplayAdvancedSettings_settingsListWrapper"
        }), b = new Interface.utils.DOMControlList({
            id: "autoplaySettingsStoppedList",
            controls: a.ADVANCED_CONFIG_CONTROLS,
            callback: a.advancedListChanged.bind(a)
        });
        c.add(new Sys.Element({
            id: "advancedSettingsListHeader",
            tag: "div",
            cls: "interface-spinSettings_autoplayAdvancedSettings_settingsListHeader",
            textContent: Services.languageManager.getText(Language.Keys.autoplay_stopAutoPlay)
        }));
        a.advancedList = b;
        c.add(b.getContainer());
        return c
    },
    setupRestrictedStopAutoPlaySection: function () {
        var b = this, a, d = new Sys.Element({id: "restrictedSettings", tag: "div"}),
            c = new Interface.utils.DOMControlList({
                id: "autoplaySettingsRestrictedStoppedList",
                controls: b.RESTRICTED_CONFIG_CONTROLS,
                callback: b.advancedListChanged.bind(b)
            });
        b.restrictedAdvancedList = c;
        a = b.restrictedAdvancedList.getControl("stopAutoplayIfBalanceDecreasedBy")[0];
        a.checkBox.setValue(true, true);
        a.checkBox.lock("autoplay");
        d.add(c.getContainer());
        d.add(new Sys.Element({
            id: "restrictedSettings_info",
            tag: "div",
            cls: "interface-spinSettings_autoplayStopControls_info",
            textContent: Services.languageManager.getText(Language.Keys.autoplay_setting_ifCashDecreasesByInfo)
        }));
        return d
    },
    advancedListChanged: function (b, d) {
        var c = this, a = false;
        c.fireEvent("view:userAction", b, d);
        c.ADVANCED_CONFIG_CONTROLS.forEach(function (e) {
            if (Services.settingsManager.getSetting(e.id) !== false) {
                a = true
            }
        });
        c.RESTRICTED_CONFIG_CONTROLS.forEach(function (e) {
            if (Services.settingsManager.getSetting(e.id) !== false) {
                a = true
            }
        });
        if (a) {
            c.advancedToggle.getContainer().addCls("sectionActive");
            c.showResetButton()
        } else {
            c.advancedToggle.getContainer().removeCls("sectionActive");
            c.hideResetButton()
        }
    },
    setupResetButton: function () {
        var a = this;
        a.resetButton = new Interface.utils.DOMButton({
            id: "autoplaySettingsReset",
            textContent: Services.languageManager.getText(Language.Keys.reset),
            clickCallback: a.resetSettings.bind(a),
            baseCSS: "interface-desktopControls_Button_small interface-interface-desktopControls_Button_small_uri interface-spinSettings_autoplayStopControls_resetButton"
        });
        a.hideResetButton();
        return a.resetButton.getContainer()
    },
    showResetButton: function () {
        this.resetButton.show(this.MODULE_NAME)
    },
    hideResetButton: function () {
        this.resetButton.hide(this.MODULE_NAME)
    },
    hideSetting: function (a) {
        this.advancedList.hide(a)
    },
    showSetting: function (a) {
        this.advancedList.show(a)
    },
    resetSettings: function () {
        var a = this;
        a.ADVANCED_CONFIG_CONTROLS.forEach(function (b) {
            a.advancedList.update(b.id, false);
            a.advancedListChanged(b.id, false)
        });
        a.RESTRICTED_CONFIG_CONTROLS.forEach(function (b) {
            a.restrictedAdvancedList.update(b.id, false);
            a.advancedListChanged(b.id, false)
        });
        a.resetAutoPlay();
        a.fireEvent("view:stopAutoPlay")
    },
    setUpAutoplaySpinsSelector: function () {
        var b = this, d = "[Off]", c = new Sys.Element({
            id: "autoplaySelectorWrapper",
            tag: "div",
            cls: "interface-spinSettings_autoplaySelector_wrapper"
        }), a = {
            id: "autoplaySelector",
            values: b.model.getAutoplaySpinsArray(),
            CSS: {
                base: "interface-spinSettings_autoplaySelector_base",
                buttonBase: "interface-spinSettings_autoplaySelector_buttonBase",
                buttonUp: "interface-DOMOptionScroller_buttonUp_uri",
                buttonDown: "interface-DOMOptionScroller_buttonDown_uri",
                valuesHolder: "interface-spinSettings_autoplaySelector_valuesHolder",
                value: "interface-spinSettings_autoplaySelector_value interface-DOMOptionScroller_value_uri interface-spinSettings_button",
                wrapper: "interface-spinSettings_autoplaySelector_valueWrapper"
            },
            callback: function (e) {
                b.fireEvent("view:userAction", "autoPlayNrSpins", Sys.utils.toInt(e));
                b.disableAdvancedControls();
                b.disableRestrictedControls();
                b.fireEvent("view:startAutoPlay")
            },
            scrollOffsetModifier: 3,
            valueWidth: 50,
            replaceTextByIndex: [{index: 0, text: d, skip: true}]
        };
        c.add(new Sys.Element({
            id: "topLabel",
            tag: "div",
            cls: "interface-spinSettings_autoplaySelector_label",
            textContent: Services.languageManager.getText(Language.Keys.autoplay_numberSpins)
        }));
        b.selector = new Interface.utils.DOMOptionScroller(a);
        c.add(b.selector.getContainer());
        c.add(new Sys.Element({
            id: "topLabel",
            tag: "div",
            cls: "interface-spinSettings_autoplaySelector_label",
            textContent: Services.languageManager.getText(Language.Keys.autoplay_panelStartText)
        }));
        b.autoplaySettingsWrapper.add(c)
    },
    onAutoplayStarting: function () {
        this.fireEvent("view:autoPlayActive")
    },
    selectorCallbackFunction: function (a) {
        var b = this;
        if (a.element === b.selectedAutoplayTarget) {
            return false
        } else {
            if (!Sys.isDefined(b.selectedAutoplayTarget)) {
                a.element.style.opacity = "0.7";
                b.selectedAutoplayTarget = a.element;
                return true
            } else {
                if (a !== b.selectedAutoplayTarget) {
                    b.selectedAutoplayTarget.style.opacity = "1";
                    a.element.style.opacity = "0.7";
                    b.selectedAutoplayTarget = a.element;
                    return true
                }
            }
        }
        return false
    },
    deSelectAutoPlayTarget: function () {
        if (Sys.isDefined(this.selectedAutoplayTarget)) {
            this.selectedAutoplayTarget.style.opacity = "1";
            this.selectedAutoplayTarget = undefined
        }
    },
    setUpAutoplayStopControls: function () {
        var a = this, c = new Sys.Element({
            id: "autoplayStopControls",
            tag: "div",
            cls: "interface-spinSettings_autoplayStopControls_wrapper"
        }), b = new Sys.Element({
            id: "autoplayStopControlsHeader",
            tag: "div",
            cls: "interface-spinSettings_autoplayStopControls_header",
            textContent: Services.languageManager.getText(Language.Keys.spinsLeftText, [Services.languageManager.getText(Language.Keys.autoSpins)])
        });
        a.spinsLeftCounter = new Sys.Element({
            id: "autoplayStopControlsSpinsCounter",
            tag: "div",
            cls: "interface-spinSettings_autoplaySelector_value interface-DOMOptionScroller_value_uri",
            textContent: "0"
        });
        a.stopButton = new Interface.utils.DOMButton({
            id: "autoplayStopControlsStopButton",
            baseCSS: "interface-desktopControls_Button interface-spinSettings_autoplayStopControls_stopButton interface-interface-desktopControls_Button_uri",
            textContent: Services.languageManager.getText(Language.Keys.autoplay_stopText),
            clickCallback: a.fireEvent.bind(a, "view:stopAutoPlay")
        });
        c.add(b);
        c.add(a.spinsLeftCounter);
        c.add(a.stopButton.getContainer());
        a.container.add(c)
    },
    setUpKeypadButton: function () {
        var b = this, a = Sys.applyProperties({clickCallback: b.onButtonClick.bind(b)}, b.KEYPAD_BUTTON_CONFIG);
        a.buttonLabel.depth = Layering.Game.Slots.Keypad.autoPlay.label;
        if (Sys.isDefined(a.buttonLayoutParameters)) {
            a.buttonLayoutParameters.depth = Layering.Game.Slots.Keypad.autoPlay.button
        } else {
            a.dimensions.depth = Layering.Game.Slots.Keypad.autoPlay.button
        }
        b.keypadButton = new Interface.utils.CanvasButton(a);
        b.keypadPendingDisable.forEach(b.keypadButton.disable.bind(b.keypadButton));
        delete b.keypadPendingDisable
    },
    update: function () {
        var b = this, a = b.model.readData("autoPlayNrSpins"), c = b.model.readData("autoPlayActive");
        if (c && a > 0) {
            b.spinsLeftCounter.el.textContent = a;
            b.container.addCls("autoplayActive");
            b.menuButton.getContainer().el.textContent = a;
            b.menuButton.getContainer().addCls("autoplayActive");
            b.menuButton.addProperty("active", "autoplayActive");
            b.isActive = true
        } else {
            b.resetAutoPlay()
        }
    },
    reduceCounter: function (c) {
        var b = this, a = c !== 0 ? c : "";
        b.spinsLeftCounter.el.textContent = a;
        b.menuButton.getContainer().el.textContent = a
    },
    resetAutoPlay: function () {
        var a = this;
        if (a.isActive) {
            a.container.removeCls("autoplayActive");
            a.menuButton.removeProperty("active", "autoplayActive");
            a.menuButton.getContainer().removeCls("autoplayActive");
            a.menuButton.getContainer().el.textContent = "";
            a.isActive = false;
            a.deSelectAutoPlayTarget()
        }
        a.enableRestrictedControls();
        a.enableAdvancedControls()
    },
    enableKeypadButton: function (c) {
        var b = this, a;
        if (!c) {
            c = "keypadDisabled"
        }
        if (Sys.isDefined(b.keypadButton)) {
            b.keypadButton.enable(c)
        } else {
            a = b.keypadPendingDisable.indexOf(c);
            if (a >= 0) {
                b.keypadPendingDisable.splice(a, 1)
            }
        }
    },
    disableKeypadButton: function (b) {
        var a = this;
        if (!b) {
            b = "keypadDisabled"
        }
        if (Sys.isDefined(a.keypadButton)) {
            a.keypadButton.disable(b)
        } else {
            if (!a.keypadPendingDisable.contains(b)) {
                a.keypadPendingDisable.push(b)
            }
        }
    },
    showKeypadButton: function (a) {
        if (Sys.isDefined(this.keypadButton)) {
            this.keypadButton.show(a)
        }
    },
    hideKeypadButton: function (a) {
        if (Sys.isDefined(this.keypadButton)) {
            this.keypadButton.hide(a)
        }
    },
    toggleFreeRoundControls: function (b) {
        var c = this, a = b || [];
        Sys.each(c.ADVANCED_CONFIG_CONTROLS, function (d) {
            if (!a.contains(d.id)) {
                if (c.model.readData("freeRoundsActive")) {
                    c.advancedList.disable(d.id)
                } else {
                    c.advancedList.enable(d.id)
                }
            }
        })
    },
    onFreeRoundsStateChange: function (b) {
        var c = this, a = c.FREEROUND_ACTIVE_CONTROLS;
        c.model.storeData("freeRoundsActive", b);
        c.toggleFreeRoundControls(a);
        c.toggleRestrictedControls()
    },
    toggleRestrictedControls: function () {
        var b = this, c = b.model.readData("freeRoundsActive"), a;
        if (b.model.readData("isRestrictedModeEnabled")) {
            a = b.restrictedAdvancedList.getControl("stopAutoplayIfBalanceDecreasedBy")[0];
            if (c) {
                b.model.storeData("isRestrictedMode", false);
                a.checkBox.unlock("autoplay");
                a.checkBox.setValue(false, false);
                b.restrictedAdvancedList.disable("stopAutoplayIfBalanceDecreasedBy");
                a.checkBox.lock("autoplay");
                b.restrictedAdvancedList.hide("stopAutoplayIfBalanceDecreasedBy");
                b.restrictedWrapper.addCSSClass("hide")
            } else {
                b.model.storeData("isRestrictedMode", true);
                b.restrictedAdvancedList.enable("stopAutoplayIfBalanceDecreasedBy");
                a.checkBox.unlock("autoplay");
                a.checkBox.setValue(true, true);
                b.restrictedAdvancedList.show("stopAutoplayIfBalanceDecreasedBy");
                b.restrictedWrapper.removeCSSClass("hide")
            }
        }
    },
    disableAdvancedControls: function () {
        var a = this;
        a.ADVANCED_CONFIG_CONTROLS.forEach(function (b) {
            if (Sys.isDefined(b.withInput)) {
                a.advancedList.disable(b.id)
            }
        })
    },
    enableAdvancedControls: function () {
        var a = this;
        a.ADVANCED_CONFIG_CONTROLS.forEach(function (d) {
            var c = a.model.readData("freeRoundsActive"), b = !c && Sys.isDefined(d.withInput),
                e = c && d.withInput && a.FREEROUND_ACTIVE_CONTROLS.contains(d.id);
            if (b || e) {
                a.advancedList.enable(d.id)
            }
        })
    },
    disableRestrictedControls: function () {
        var a = this;
        a.RESTRICTED_CONFIG_CONTROLS.forEach(function (b) {
            a.restrictedAdvancedList.disable(b.id)
        })
    },
    enableRestrictedControls: function () {
        var a = this;
        if (!a.model.readData("freeRoundsActive")) {
            a.RESTRICTED_CONFIG_CONTROLS.forEach(function (b) {
                a.restrictedAdvancedList.enable(b.id)
            })
        }
    }
};
Interface.AutoplaySettingsView = Sys.extend(Interface.StandAloneSettingsSectionView, Interface.AutoplaySettingsView, "Interface.AutoplaySettingsView");
Sys.ns("Interface");
Interface.AutoplaySettingsModel = {
    constructor: function () {
        Interface.AutoplaySettingsModel.superclass.constructor.apply(this, arguments)
    }, setupData: function () {
        var c = this, b, a = [{
            key: "stopAutoplayOnAnyWin",
            defaultValue: false,
            settingsManager: true,
            localStorage: false
        }, {
            key: "stopAutoplayIfBalanceIncreasedBy",
            defaultValue: false,
            settingsManager: true,
            localStorage: false
        }, {
            key: "stopAutoplayIfWinExceeds",
            defaultValue: false,
            settingsManager: true,
            localStorage: false
        }, {key: "stopAutoplayIfBalanceDecreasedBy", defaultValue: false, settingsManager: true, localStorage: false}];
        b = Resources.readData("gameServerInitResponse").autoplayLossLimitEnabled || false;
        c.storeData("isRestrictedModeEnabled", b);
        Interface.AutoplaySettingsModel.superclass.setupData.apply(c, arguments);
        a.forEach(c.initData, c)
    }
};
Interface.AutoplaySettingsModel = Sys.extend(Interface.SpinSettingsBaseModel, Interface.AutoplaySettingsModel, "Interface.AutoplaySettingsModel");
Sys.ns("Interface");
Interface.GameSettings = {
    constructor: function () {
        Interface.GameSettings.superclass.constructor.apply(this, arguments)
    }, getDefaultMVCClasses: function () {
        return {
            controller: Interface.GameSettingsController,
            model: Interface.GameSettingsModel,
            view: Interface.GameSettingsBaseView
        }
    }
};
Interface.GameSettings = Sys.extend(Interface.SettingsSection, Interface.GameSettings, "Interface.GameSettings");
Sys.ns("Interface");
Interface.GameSettingsController = {
    LOCAL_STORAGE_SETTINGS: ["showFeatureSplash", "quickSpin", "showIntroMovie", "spacebarToSpin"],
    constructor: function () {
        Interface.GameSettingsController.superclass.constructor.apply(this, arguments)
    },
    setupEvents: function () {
        var a = this;
        a.on({
            "notify:settingsManager.settingChanged": a.view.update.bind(a.view),
            "notify:settingsManager.settingDisabled": a.view.hideSetting.bind(a.view),
            "notify:settingsManager.settingEnabled": a.view.showSetting.bind(a.view),
            "notify:settingsManager.settingLocked": a.view.disableSetting.bind(a.view),
            "notify:settingsManager.settingUnlocked": a.view.enableSetting.bind(a.view),
            "notify:stateHandler.leavingIdleState": a.hide,
            "request:gameSettings.close": a.onHideRequest,
            "request:closeOpenWindows": a.onHideRequest,
            "request:gameSettings.toggle": a.onToggle,
            "view:gameHistoryClicked": a.onGameHistoryClicked
        });
        Interface.GameSettingsController.superclass.setupEvents.apply(a, arguments)
    },
    onUserAction: function (b, d) {
        var c = this, a = false;
        if (c.LOCAL_STORAGE_SETTINGS.contains(b)) {
            a = true
        }
        this.fireEvent("request:settingsManager.storeData", b, d, a)
    },
    onShowRequest: function () {
        var a = this;
        a.fireEvent("request:autoplaySettings.close");
        Interface.GameSettingsController.superclass.onShowRequest.apply(a, arguments)
    },
    onGameHistoryClicked: function () {
        var a = this.model;
        if (!a.readData("historyRemoved") && !a.readData("historyDisabled")) {
            Environment.openNewBrowserTab(Resources.readData("historyUrl"), "gameHistory")
        }
    },
    onToggle: function () {
        var a = this;
        if (a.model.readData("showing")) {
            a.hide()
        } else {
            a.show()
        }
    }
};
Interface.GameSettingsController = Sys.extend(Interface.SettingsSectionController, Interface.GameSettingsController, "Interface.GameSettingsController");
Sys.ns("Interface");
Interface.GameSettingsModel = {
    constructor: function () {
        Interface.GameSettingsModel.superclass.constructor.apply(this, arguments)
    }, setupData: function () {
        var c = this, a = [{
                key: "showFeatureSplash",
                defaultValue: true,
                settingsManager: true,
                localStorage: true
            }, {key: "quickSpin", defaultValue: false, settingsManager: true, localStorage: true}, {
                key: "showIntroMovie",
                defaultValue: true,
                settingsManager: true,
                localStorage: true
            }, {key: "spacebarToSpin", defaultValue: false, settingsManager: true, localStorage: true}],
            b = Resources.readData("gameServerInitResponse");
        a.forEach(c.initData, c);
        if (b.playforfun) {
            c.storeData("historyDisabled", true)
        } else {
            if (Sys.isDefined(b.historybutton) && !b.historybutton) {
                c.storeData("historyRemoved", true)
            }
        }
    }
};
Interface.GameSettingsModel = Sys.extend(Interface.SettingsSectionModel, Interface.GameSettingsModel, "Interface.GameSettingsModel");
Sys.ns("Interface");
Interface.GameSettingsDesktopView = {
    MENU_BUTTON_CSS: "interface-desktopSettingsMenu_button interface-gameSettings_icon_uri",
    DISABLE_BUTTON_DURING_SPIN: false,
    SETTINGS_CONTROLS: [{
        id: "quickSpin",
        label: Language.Keys.setting_quickSpinGame,
        type: "checkbox"
    }, {id: "showFeatureSplash", label: Language.Keys.setting_introScreeGame, type: "checkbox"}, {
        id: "showIntroMovie",
        label: Language.Keys.setting_introGame,
        type: "checkbox"
    }, {id: "spacebarToSpin", label: Language.Keys.setting_spaceSpin, type: "checkbox"}],
    TITLE: Language.Keys.gameSettingsPanelLabel,
    ARROW_LEFT_VALUE: "0.05rem",
    ORDER: 1,
    constructor: function () {
        Interface.GameSettingsDesktopView.superclass.constructor.apply(this, arguments)
    },
    setUpContent: function () {
        var b = this, a = b.model;
        Interface.GameSettingsDesktopView.superclass.setUpContent.apply(b, arguments);
        b.settingsList = new Interface.utils.DOMControlList({
            id: "gameSettingsSettingsList",
            controls: b.SETTINGS_CONTROLS,
            callback: b.fireEvent.bind(b, "view:userAction")
        });
        b.SETTINGS_CONTROLS.forEach(function (c) {
            b.settingsList.update(c.id, b.model.readData(c.id))
        });
        b.container.add(b.settingsList.getContainer());
        if (!(a.readData("historyRemoved") || a.readData("historyDisabled"))) {
            b.container.add(b.createGameHistoryButton())
        }
    },
    update: function (a, b) {
        this.settingsList.update(a, b)
    },
    hideSetting: function (a) {
        this.settingsList.hide(a)
    },
    showSetting: function (a) {
        this.settingsList.show(a)
    },
    disableSetting: function (a) {
        this.settingsList.disable(a)
    },
    enableSetting: function (a) {
        this.settingsList.enable(a)
    },
    createGameHistoryButton: function () {
        var a = this;
        a.historyButton = new Interface.utils.DOMButton({
            id: "gameHistoryButton",
            baseCSS: "interface-desktopControls_Button_small interface-desktopGameHistoryButton preventUserSelect interface-interface-desktopControls_Button_small_uri",
            clickCallback: a.fireEvent.bind(a, "view:gameHistoryClicked"),
            textContent: Services.languageManager.getText(Language.Keys.gameHistory)
        });
        return a.historyButton.getContainer()
    }
};
Interface.GameSettingsDesktopView = Sys.extend(Interface.StandAloneSettingsSectionView, Interface.GameSettingsDesktopView, "Interface.GameSettingsDesktopView");
Sys.ns("Interface");
Interface.SoundSettings = {
    constructor: function () {
        Interface.SoundSettings.superclass.constructor.apply(this, arguments)
    }, getMixinDependencies: function () {
        return {
            fallback: ["userInput", "orientation"],
            desktop: [{userInput: {inputEvents: ["start", "end", "cancel", "move", "hover"], listenToUserInput: true}}]
        }
    }, getDefaultMVCClasses: function () {
        return {
            controller: Interface.SoundSettingsController,
            model: Interface.SoundSettingsModel,
            view: Interface.SoundSettingsBaseView
        }
    }
};
Interface.SoundSettings = Sys.extend(Interface.SettingsSection, Interface.SoundSettings, "Interface.SoundSettings");
Sys.ns("Interface");
Interface.SoundSettingsController = {
    constructor: function () {
        Interface.SoundSettingsController.superclass.constructor.apply(this, arguments)
    }, setupEvents: function () {
        var a = this;
        a.on({
            "request:soundSettings.enableVibrationSetting": a.onEnableVibrationSetting,
            "notify:settingsManager.settingChanged": a.onSettingChanged,
            "notify:audioPlayer.loadingSound": a.view.startSoundLoading.bind(a.view),
            "notify:audioPlayer.soundLoaded": a.view.soundLoadedStopLoader.bind(a.view),
            "view:toggleSound": a.toggleSound
        });
        Interface.SoundSettingsController.superclass.setupEvents.apply(a, arguments)
    }, onUserAction: function (a, b) {
        switch (a) {
            case"audioOn":
                Services.settingsManager.storeSetting("volume", b ? this.model.getPreviousVolume() : 0, true);
                break;
            case"volume":
                Services.settingsManager.storeSetting("volume", b, true);
                break;
            case"vibrationOn":
                Services.settingsManager.storeSetting("vibration", b, true);
                break;
            default:
        }
    }, onEnableVibrationSetting: function () {
        this.view.addVibrationToggle()
    }, onUserInputHover: function (a) {
        this.view.onUserInputHover(a)
    }, onSettingChanged: function (a, b) {
        if (a === "volume") {
            this.view.update(b);
            if (b > 0) {
                this.model.storeData("previousVolume", b)
            }
        } else {
            if (a === "vibration") {
                this.view.updateVibration(b)
            }
        }
    }
};
Interface.SoundSettingsController = Sys.extend(Interface.SettingsSectionController, Interface.SoundSettingsController, "Interface.SoundSettingsController");
Sys.ns("Interface");
Interface.SoundSettingsModel = {
    constructor: function () {
        Interface.SoundSettingsModel.superclass.constructor.apply(this, arguments)
    }, setupData: function () {
        var a = this;
        a.initData({
            key: "volume",
            defaultValue: Platform.resourceBundle.preloadAudio ? 1 : 0,
            settingsManager: true,
            localStorage: Platform.resourceBundle.preloadAudio
        });
        a.initData({key: "vibration", defaultValue: false, settingsManager: true, localStorage: true});
        a.storeData("previousVolume", 1)
    }, getPreviousVolume: function () {
        var a = this.readData("previousVolume");
        if (!Sys.isDefined(a)) {
            a = 1
        }
        return a
    }
};
Interface.SoundSettingsModel = Sys.extend(Interface.SettingsSectionModel, Interface.SoundSettingsModel, "Interface.SoundSettingsModel");
Sys.ns("Interface");
Interface.SoundSettingsBaseView = {
    BASE_CSS: "tab interface-soundSettings_base",
    PORTRAIT_CSS: "interface-soundSettings_portrait",
    LANDSCAPE_CSS: "interface-soundSettings_landscape",
    SECTION_CSS: "utils_empty interface-settingsSection_subSection",
    LOAD_ANIMATION_CSS: "interface-smallSpinner_uri",
    constructor: function () {
        Interface.SoundSettingsBaseView.superclass.constructor.apply(this, arguments)
    },
    setUpContent: function () {
        var a = this;
        a.container = new Sys.Element({id: "userSettings", tag: "div", cls: a.BASE_CSS});
        a.audioOnOffContainer = a.container.add(new Sys.Element({
            id: "soundSettings_soundSettings",
            tag: "div",
            cls: a.SECTION_CSS
        }));
        a.audioOnOff = new Interface.utils.ToggleSwitch({
            id: "audioOnOff",
            title: Services.languageManager.getText(Language.Keys.setting_gameSound),
            callback: a.onSettingsControllerChanged.bind(a, "audioOn")
        });
        a.audioOnOffContainer.add(a.audioOnOff.getContainer());
        a.fireEvent("view:addToContainer", "settingsWindow", {
            title: Services.languageManager.getText(Language.Keys.soundSettings_uc),
            content: a.container
        });
        a.fireEvent("view:addToNavigator", "settingsMenu", {order: 1});
        a.subComponents = [a.audioOnOff];
        a.addScrolling();
        if (!a.model.readData("disabled")) {
            a.enable()
        }
        a.hide()
    },
    addVibrationToggle: function () {
        var a = this;
        a.vibrationOnOffContainer = a.container.add(new Sys.Element({
            id: "soundSettings_soundSettings",
            tag: "div",
            cls: a.SECTION_CSS
        }));
        a.vibrationOnOff = new Interface.utils.ToggleSwitch({
            id: "vibrationOnOff",
            title: Services.languageManager.getText(Language.Keys.setting_gameVibration),
            callback: a.onSettingsControllerChanged.bind(a, "vibrationOn")
        });
        a.vibrationOnOffContainer.add(a.vibrationOnOff.getContainer());
        a.subComponents.push(a.vibrationOnOff);
        a.vibrationOnOff.enable();
        a.updateVibration(Services.settingsManager.getSetting("vibration"))
    },
    onSettingsControllerChanged: function (b, a) {
        this.fireEvent("view:userAction", b, a)
    },
    enable: function () {
        this.callFunctionOnSubComponents("enable")
    },
    disable: function () {
        this.callFunctionOnSubComponents("disable")
    },
    update: function (a) {
        this.audioOnOff.toggle(a > 0)
    },
    updateVibration: function (a) {
        this.vibrationOnOff.toggle(a)
    },
    startSoundLoading: function () {
        var a = this;
        a.audioOnOff.displayLoadAnimation();
        a.disable();
        a.update(Services.settingsManager.getSetting("volume"))
    },
    soundLoadedStopLoader: function () {
        this.enable();
        this.update(Services.settingsManager.getSetting("volume"));
        this.audioOnOff.hideLoadAnimation()
    }
};
Interface.SoundSettingsBaseView = Sys.extend(Interface.SettingsSectionView, Interface.SoundSettingsBaseView, "Interface.SoundSettingsBaseView");
Sys.ns("Interface");
Interface.SoundSettingsDesktopView = {
    WRAPPER_CSS: "interface-soundSettingsDesktop_sliderWrapper",
    BASE_CSS: "interface-soundSettingsDesktop_sliderBase interface-standAloneSettingsSectionMiddle_uri",
    BUTTON_CSS: "interface-desktopSettingsMenu_button interface-soundSettings_audioOn_icon_uri",
    BUTTON_OFF_CSS: "interface-soundSettings_audioOff_icon_uri",
    LOAD_ANIMATION_CSS: "interface-soundSettingsDesktop_spinner interface-smallSpinner_uri hidden",
    CLOSE_ANIMATION_CSS: "interface-soundSettingsDesktop_closeTransition",
    constructor: function () {
        Interface.SoundSettingsDesktopView.superclass.constructor.apply(this, arguments)
    },
    onUserInputStart: function (a) {
    },
    onUserInputMove: function () {
    },
    onUserInputEnd: function (a) {
    },
    onUserInputHover: function (b) {
        var a = this;
        if (Sys.UserInputUtils.isCoordinateTarget(a.container.el, b) || Sys.UserInputUtils.isCoordinateTarget(a.menuButton.el, b)) {
            a.menuButton.addCls("hover");
            a.open()
        } else {
            a.menuButton.removeCls("hover");
            a.close()
        }
    },
    show: function () {
        this.open()
    },
    hide: function () {
        this.close()
    },
    open: function () {
        var a = this;
        a.wrapper.removeCls(a.CLOSE_ANIMATION_CSS);
        a.isOpen = true;
        if (!a.model.readData("disabled")) {
            a.volume.enable()
        }
    },
    close: function () {
        var a = this;
        a.wrapper.addCls(a.CLOSE_ANIMATION_CSS);
        if (a.volume) {
            a.volume.disable()
        }
        a.isOpen = false
    },
    setUpContent: function () {
        var a = this;
        a.wrapper = new Sys.Element({
            id: "soundSettingsWrapper",
            tag: "div",
            cls: a.WRAPPER_CSS,
            renderTo: "gameWrapper"
        });
        a.container = a.wrapper.add(new Sys.Element({id: "soundSettings", tag: "div", cls: a.BASE_CSS}));
        a.menuButton = new Sys.Element({id: "soundSettingsButton", tag: "div", cls: a.BUTTON_CSS});
        a.abstractButton = new Interface.AbstractButton({dimensions: a.menuButton.el, clickCallback: a.toggle.bind(a)});
        a.volume = new Interface.utils.VerticalSlider({
            id: "soundVolumeSlider",
            minValue: 0,
            maxValue: 1,
            valueStep: 0.05,
            startValue: Services.settingsManager.getSetting("volume"),
            callback: a.fireEvent.bind(a, "view:userAction", "volume"),
            ascendingGrowth: true,
            showDisplay: false,
            callbackOnlyOnEndEvent: false
        });
        a.loadAnimation = a.container.add(new Sys.Element({
            id: "soundSettings_loadAnimation",
            tag: "div",
            cls: a.LOAD_ANIMATION_CSS
        }));
        a.container.add(a.volume.getContainer());
        a.fireEvent("view:addToNavigator", "desktopSettingsMenu", {order: 1, element: a.menuButton});
        a.update(Services.settingsManager.getSetting("volume"));
        a.hide()
    },
    toggle: function () {
        this.fireEvent("view:userAction", "audioOn", Services.settingsManager.getSetting("volume") === 0)
    },
    enable: function () {
        var a = this;
        a.abstractButton.enable("sectionDisabled");
        a.volume.enable()
    },
    disable: function () {
        var a = this;
        a.abstractButton.disable("sectionDisabled");
        a.volume.disable()
    },
    startSoundLoading: function () {
        this.disable();
        this.loadAnimation.el.style.display = "block"
    },
    soundLoadedStopLoader: function () {
        this.enable();
        this.loadAnimation.el.style.display = "none"
    },
    update: function (b) {
        var a = this;
        if (!a.volume.enabled) {
            a.enable()
        }
        a.menuButton.removeCls(a.BUTTON_OFF_CSS);
        if (!(b > 0)) {
            a.menuButton.addCls(a.BUTTON_OFF_CSS)
        }
        a.volume.moveSlider(b)
    },
    removeSetting: function () {
    }
};
Interface.SoundSettingsDesktopView = Sys.extend(Core.View, Interface.SoundSettingsDesktopView, "Interface.SoundSettingsDesktopView");
Sys.ns("Core");
Core.Trigger = {
    constructor: function () {
        Core.Trigger.superclass.constructor.apply(this, arguments)
    }, getDefaultMVCClasses: function () {
        return {model: Core.TriggerModel, controller: Core.TriggerController}
    }
};
Core.Trigger = Sys.extend(Core.Module, Core.Trigger, "Core.Trigger");
Resources.storeData("triggerScripts", {});
Sys.ns("Core");
Core.TriggerController = {
    DEBUG: false, constructor: function () {
        Core.TriggerController.superclass.constructor.apply(this, arguments)
    }, setupEvents: function () {
        var a = this;
        Core.TriggerController.superclass.setupEvents.apply(a, arguments);
        a.on({
            pageVisibilityChanged_event: a.onPageVisibilityChanged,
            "notify:moduleLoader.finishedLoadingModules": a.onFinishedLoadingModules,
            "notify:audioPlayer.soundPlayable": a.onSoundReady
        })
    }, onFinishedLoadingModules: function () {
        var a = Resources.readData("config") || {};
        if (Platform.isWebAudioEnabled && a.enableWADE) {
            this.fireEvent("request:audioPlayer.disableEventInteractions")
        }
        this.fireEvent("notify:trigger.ready")
    }, onSoundReady: function () {
        this.audioReady = true
    }, onPageVisibilityChanged: function (a) {
    }, registerTrigger: function (d, a, c) {
        var b = this;
        b.addListener(d, function () {
            b.executeTrigger.apply(b, [d].concat(Array.prototype.slice.call(arguments)))
        });
        b.model.registerTrigger(d, a, c)
    }, executeTrigger: function (h) {
        var d = this.model.getScriptsLinkedToTrigger(h), c = d.length, f = Array.prototype.slice.call(arguments, 1), b,
            e, g, a;
        if (!Platform.isWebAudioEnabled || !this.audioReady) {
            return
        }
        for (g = -1; ++g < c;) {
            e = d[g];
            b = this.determineExecutionEnvironment(h, e.type);
            e.script.apply(b.scope, f)
        }
    }, listTriggers: function () {
        return Object.keys(this.model.getTriggers())
    }, listLinkedTriggers: function () {
        return this.model.getLinkedTriggers()
    }, getTriggerDescription: function (a) {
        return this.model.getTriggerDescription(a)
    }, getScript: function (a) {
        return Resources.readData("triggerScripts")[a].script.toString()
    }, getScriptsLinkedToTrigger: function (a) {
        return this.model.getScriptsLinkedToTrigger(a)
    }, getScriptNamesLinkedToTrigger: function (a) {
        return this.model.getScriptNamesLinkedToTrigger(a)
    }, linkScriptToTrigger: function (b, a) {
        this.model.linkScriptToTrigger(b, a)
    }, unlinkScriptAndTrigger: function (b, a) {
        this.model.unlinkScriptAndTrigger(b, a)
    }, determineExecutionEnvironment: function (c, b) {
        var a = {args: []};
        switch (b) {
            case"audio":
                a.scope = Audio.Engine;
                break;
            case"animation":
                a.scope = {};
                break;
            default:
                a.scope = [this.model.getTriggerScope(c)]
        }
        return a
    }
};
Core.TriggerController = Sys.extend(Core.Controller, Core.TriggerController, "Core.TriggerController");
Sys.ns("Core");
Core.TriggerModel = {
    constructor: function () {
        Core.TriggerModel.superclass.constructor.apply(this, arguments)
    }, registerTrigger: function (a, c, b) {
        this.readData("triggers")[a] = {description: b, defaultScope: c}
    }, getTriggers: function () {
        return this.readData("triggers")
    }, hasTrigger: function (a) {
        return Sys.isDefined(this.readData("triggers")[a])
    }, getLinkedTriggers: function () {
        return Object.keys(this.readData("scriptLookup"))
    }, getTriggerDescription: function (b) {
        var a = this.readData("triggers")[b];
        if (Sys.isObj(a)) {
            return a.description
        }
        return undefined
    }, getTriggerScope: function (b) {
        var a = this.readData("triggers")[b];
        if (Sys.isObj(a)) {
            return a.defaultScope
        }
        return undefined
    }, getScriptNamesLinkedToTrigger: function (b) {
        var a = this.readData("scriptLookup")[b];
        if (!a) {
            a = []
        }
        return a
    }, getScriptsLinkedToTrigger: function (c) {
        var e = Resources.readData("triggerScripts"), b = this.getScriptNamesLinkedToTrigger(c), a = [], d;
        for (d = -1; ++d < b.length;) {
            a.push(e[b[d]])
        }
        return a
    }, linkScriptToTrigger: function (c, a) {
        var b = this.readData("scriptLookup");
        if (!Sys.isArray(b[a])) {
            b[a] = []
        }
        if (!b[a].contains(c)) {
            b[a].push(c)
        }
    }, unlinkScriptAndTrigger: function (e, a) {
        var d = this.readData("scriptLookup"), c = d[a], b;
        if (Sys.isArray(c)) {
            b = c.indexOf(e);
            if (b >= 0) {
                c.splice(b, 1)
            }
        }
    }, setupData: function () {
        this.storeData("triggers", {});
        this.storeData("scriptLookup", this.initializeScriptLookup())
    }, initializeScriptLookup: function () {
        var b = Resources.readData("triggerScripts"), a = Object.keys(b), h = a.length, f = {}, g, d, e, c;
        for (e = -1; ++e < h;) {
            g = a[e];
            d = b[g];
            for (c = -1; ++c < d.usedOn.length;) {
                if (!Sys.isDefined(f[d.usedOn[c]])) {
                    f[d.usedOn[c]] = []
                }
                f[d.usedOn[c]].push(g)
            }
        }
        return f
    }
};
Core.TriggerModel = Sys.extend(Core.Model, Core.TriggerModel, "Core.TriggerModel");
(function (a) {
    var b = "buttonSounds";
    a.buttonUp = {
        usedOn: ["notify:button.up", "notify:spinButton.up"], type: "audio", script: function () {
            this.play(b, "buttonUp")
        }
    };
    a.buttonDown = {
        usedOn: ["notify:button.down", "notify:spinButton.down"], type: "audio", script: function () {
            this.play(b, "buttonDown")
        }
    };
    a.buttonHover = {
        usedOn: ["notify:button.hover", "notify:spinButton.hover", "notify:paytableClose.hover", "notify:paytableIndicator_0.hover", "notify:paytableIndicator_1.hover", "notify:paytableIndicator_2.hover", "notify:paytableNext.hover", "notify:paytablePrevious.hover"],
        type: "audio",
        script: function (c) {
            if (!c) {
                this.play(b, "buttonHover")
            }
        }
    };
    a.buttonClick = {
        usedOn: ["notify:button.click"], type: "audio", script: function () {
            this.play(b, "buttonClick")
        }
    };
    a.spinButtonClick = {
        usedOn: ["notify:spinButton.clicked"], type: "audio", script: function () {
            this.play(b, "spinButtonClick")
        }
    };
    a.sliderIncrease = {
        usedOn: [], type: "audio", script: function () {
        }
    };
    a.sliderDecrease = {
        usedOn: [], type: "audio", script: function () {
        }
    };
    a.paytableFlip = {
        usedOn: ["notify:paytableNext.click", "notify:paytablePrevious.click", "notify:paytableIndicator_0.click", "notify:paytableIndicator_1.click", "notify:paytableIndicator_2.click"],
        type: "audio",
        script: function () {
        }
    };
    a.paytableButtonDown = {
        usedOn: ["notify:paytableClose.down"], type: "audio", script: function () {
        }
    };
    a.paytableButtonUp = {
        usedOn: ["notify:paytableClose.up"], type: "audio", script: function () {
        }
    };
    a.paytableButtonClick = {
        usedOn: ["notify:paytableClose.click"], type: "audio", script: function () {
        }
    };
    Resources.storeData("triggerScripts", a)
}(Resources.readData("triggerScripts")));
(function (a) {
    var c = "nearWin", d = "spinSounds", b = function (e) {
        var f = this.getGroup(e);
        if (Sys.isDefined(f)) {
            f.fadeIn({duration: 0.1})
        }
    };
    a.reelSpin = {
        usedOn: ["notify:spin.spinAnimationStarted"], type: "audio", script: function (e) {
            b.call(this, d);
            this.play(d, "reelSpin")
        }
    };
    a.reelBounceStart = {
        usedOn: ["notify:spin.reelStopBouncingStarted"], type: "audio", script: function () {
            b.call(this, d);
            this.play(d, "reelBounce")
        }
    };
    a.reelStop = {
        usedOn: ["notify:spin.reelStopStarted"], type: "audio", script: function (e) {
            b.call(this, d);
            this.play(d, "reelStop")
        }
    };
    a.spinComplete = {
        usedOn: ["notify:spin.spinAnimationComplete"], type: "audio", script: function () {
            var e = this.getGroup(c), f = this.getGroup(d);
            if (Sys.isDefined(e)) {
                e.fadeOut({duration: 1})
            }
            if (Sys.isDefined(f)) {
                f.fadeOut({duration: 0.5})
            }
        }
    };
    a.quickStop = {
        usedOn: ["notify:quickStopper.quickStop"], type: "audio", script: function () {
        }
    };
    a.scatterHit = {
        usedOn: ["notify:reelStopAnimations.symbolsToAnimate"], type: "audio", script: function (f, e) {
            b.call(this, d);
            this.play(d, "scatterHit")
        }
    };
    a.nearWin = {
        usedOn: ["notify:spin.nearWinStarted"], type: "audio", script: function () {
            b.call(this, c);
            this.play(c, "nearWin")
        }
    };
    a.nearWinFail = {
        usedOn: [], type: "audio", script: function () {
            var e = this.getGroup(c);
            if (Sys.isDefined(e)) {
                e.fadeOut({duration: 1})
            }
        }
    };
    Resources.storeData("triggerScripts", a)
}(Resources.readData("triggerScripts")));
(function (a) {
    var c = "winPresentation", d = "main", b;
    a.standardWinStartAudio = {
        usedOn: ["notify:standardWin.startPresentation"], type: "audio", script: function (e) {
            var f = this.getGroup(c);
            if (Sys.isDefined(f)) {
                f.fadeIn({duration: 0.1})
            }
            switch (e) {
                case"smallWin":
                    a.smallWin.script.call(this);
                    break;
                case"mediumWin":
                    a.mediumWin.script.call(this);
                    break;
                case"largeWin":
                    a.largeWin.script.call(this);
                    break;
                default:
            }
        }
    };
    a.countUpAborted = {
        usedOn: ["notify:standardWin.countupAborted"], type: "audio", script: function () {
            this.getGroup(d).fadeIn({duration: 0.5})
        }
    };
    a.stopWinSound = {
        usedOn: ["notify:standardWin.countupAborted", "notify:stateHandler.leavingStandardWinPresentationState"],
        type: "audio",
        script: function () {
            var e = this.getGroup(c);
            if (Sys.isDefined(e)) {
                e.fadeOut({duration: 0.5})
            }
        }
    };
    a.smallWin = {
        usedOn: [], type: "audio", script: function () {
            var f = Resources.readData("audioConfig").clips, e = f.main.smallWin;
            if (Sys.isDefined(e.duck) && Sys.isDefined(e.duck.ambienceGeneral)) {
                this.duck(this.getGroup(d), e.duck.ambienceGeneral)
            }
            this.play(c, "smallWin")
        }
    };
    a.mediumWin = {
        usedOn: [], type: "audio", script: function () {
            var f = Resources.readData("audioConfig").clips, e = f.main.mediumWin;
            if (Sys.isDefined(e.duck) && Sys.isDefined(e.duck.ambienceGeneral)) {
                this.duck(this.getGroup(d), e.duck.ambienceGeneral)
            }
            this.play(c, "mediumWin")
        }
    };
    a.largeWin = {
        usedOn: [], type: "audio", script: function () {
            var f = Resources.readData("audioConfig").clips, e = f.main.largeWin;
            if (Sys.isDefined(e.duck) && Sys.isDefined(e.duck.ambienceGeneral)) {
                this.duck(this.getGroup(d), e.duck.ambienceGeneral)
            }
            this.play(c, "largeWin")
        }
    };
    a.bigWinStart = {
        usedOn: ["notify:stateHandler.enteringBigWinState"], type: "audio", script: function () {
            var f = this, e, g = this.getGroup(c);
            if (Sys.isDefined(g)) {
                g.fadeIn({duration: 0.1})
            }
            b = true;
            a.ambienceGeneralStop.script.call(this);
            f.play(c, "bigWinStart");
            f.play(c, "bigWinLoop", {loop: true});
            e = f.startMetronome("bigWin", {bpm: 123});
            e.at(4, 4).stop(c);
            e.at(4, 4).play(c, "bigWinEnd", {offset: 0.6});
            e.at(4, 4).then(function () {
                f.stopMetronome("bigWin");
                b = false
            })
        }
    };
    a.bigWinLoop = {
        usedOn: ["notify:stateHandler.enteringBigWinState"], type: "audio", script: function () {
        }
    };
    a.bigWinCountUpEnd = {
        usedOn: ["notify:bigWin.showTotalInCountUp"], type: "audio", script: function () {
            if (b) {
                this.stop(c);
                this.play(c, "bigWinEnd", {offset: 2.7})
            }
        }
    };
    a.bigWinEnd = {
        usedOn: ["notify:stateHandler.leavingBigWinState"], type: "audio", script: function () {
            this.getGroup(c).fadeOut({duration: 2});
            a.ambienceGeneralStart.script.call(this)
        }
    };
    Resources.storeData("triggerScripts", a)
}(Resources.readData("triggerScripts")));
(function (a) {
    var c = "main", b = false;
    a.globalSettings = {
        usedOn: ["notify:settingsManager.settingChanged"], type: "audio", script: function (d, e) {
            if (d === "volume") {
                this.setVolume(e)
            }
        }
    };
    a.volumeRestore = {
        usedOn: ["notify:stateHandler.leavingSetupGameState"], type: "audio", script: function () {
            var d = Services.settingsManager.getSetting("volume");
            this.setVolume(d)
        }
    };
    a.soundLoaded = {
        usedOn: ["notify:audioPlayer.soundLoaded"], type: "audio", script: function () {
            var d;
            if (Services.storage.readData("IntroMovie.showing") === true) {
                return
            }
            d = Services.storage.readData("playModeManager.modes");
            if (d.indexOf("basic") > -1) {
                a.ambienceGeneralStart.script.call(this)
            } else {
                if (d.indexOf("freespin") > -1) {
                    a.ambienceFreeSpinStart.script.call(this)
                }
            }
        }
    };
    a.ambienceGeneralStart = {
        usedOn: ["notify:stateHandler.leavingShowingIntroMovieState"],
        type: "audio",
        script: function () {
            var d = b ? "freeSpin" : "ambienceGeneral";
            this.stop(c);
            this.play(c, d, {loop: true})
        }
    };
    a.ambienceGeneralStop = {
        usedOn: ["notify:stateHandler.enteringShowingIntroMovieState"],
        type: "audio",
        script: function () {
            this.stop(c)
        }
    };
    a.ambienceFreeSpinStart = {
        usedOn: ["notify:stateHandler.enteringFreeSpinIntroState"],
        type: "audio",
        script: function () {
            b = true;
            a.ambienceGeneralStart.script.call(this)
        }
    };
    a.ambienceFreeSpinStop = {
        usedOn: ["notify:stateHandler.leavingFreeSpinOutroState"],
        type: "audio",
        script: function () {
            b = false;
            a.ambienceGeneralStart.script.call(this)
        }
    };
    a.freeSpinCountdown = {
        usedOn: ["notify:stateHandler.enteringCountDownFreespinsState"],
        type: "audio",
        script: function () {
        }
    };
    Resources.storeData("triggerScripts", a)
}(Resources.readData("triggerScripts")));
Sys.ns("Core");
Core.SlowRequestAnimation = {
    constructor: function () {
        Core.SlowRequestAnimation.superclass.constructor.apply(this, arguments)
    }, getDefaultMVCClasses: function () {
        return {
            model: Core.SlowRequestAnimationModel,
            view: Core.SlowRequestAnimationView,
            controller: Core.SlowRequestAnimationController
        }
    }, getMixinDependencies: function () {
        return ["orientation"]
    }
};
Core.SlowRequestAnimation = Sys.extend(Core.Module, Core.SlowRequestAnimation, "Core.SlowRequestAnimation");
Sys.ns("Core");
Core.SlowRequestAnimationModel = {
    constructor: function () {
        Core.SlowRequestAnimationModel.superclass.constructor.apply(this, arguments);
        this.initModel()
    }, initModel: function () {
        var a = this;
        a.storeData("timeConfig", {between: 300, slowConnectionTime: 10000, slowDialogTime: 30000});
        a.storeData("activeStack", []);
        a.storeData("requestConfig", a.getRequestConfig());
        a.storeData("dialogShowing", false);
        a.setState("idle")
    }, updateActiveStack: function (d) {
        var c = this, a = this.readData("activeStack"), b = a.indexOf(d);
        if (b > -1) {
            a.splice(b, 1);
            c.storeData("activeStack", a)
        }
        return a
    }, pushActive: function (c) {
        var b = this, a = b.readData("activeStack");
        a.push(c);
        b.storeData("activeStack", a)
    }, getRequestConfig: function () {
        return ["spin", "drop", "freespin", "respin", "freespininit"]
    }, removeSlowTimeout: function () {
        var a = this.readData("slowTimeout");
        if (a) {
            clearTimeout(a);
            this.removeData("slowTimeout")
        }
    }, removeDialogTimeout: function () {
        var a = this.readData("dialogTimeout");
        if (a) {
            this.storeData("dialogShowing", false);
            clearTimeout(a);
            this.removeData("dialogTimeout")
        }
    }, getSlowConnectionTimeout: function () {
        return this.readData("slowTimeout")
    }, getDialogTimeout: function () {
        return this.readData("dialogTimeout")
    }, storeDialogTimeout: function (a) {
        var b = this, c = b.readData("dialogTimeout");
        if (c) {
            clearTimeout(c);
            b.storeData("dialogTimeout", a)
        } else {
            b.storeData("dialogTimeout", a)
        }
    }, storeSlowConnectionTimeout: function (a) {
        var b = this, c = b.readData("slowTimeout");
        if (c) {
            clearTimeout(c);
            b.storeData("slowTimeout", a)
        } else {
            b.storeData("slowTimeout", a)
        }
    }
};
Core.SlowRequestAnimationModel = Sys.extend(Core.Model, Core.SlowRequestAnimationModel, "Core.SlowRequestAnimationModel");
Sys.ns("Core");
Core.SlowRequestAnimationController = {
    constructor: function () {
        Core.SlowRequestAnimationController.superclass.constructor.apply(this, arguments);
        this.initController()
    }, initController: function () {
        var a = this;
        a.on({
            "view:showDialog": a.onShowDialog,
            "view:dialogContinue": a.onDialogContinueOption,
            "view:setSafeArea": a.fireEvent.bind(a, "request:fullscreen.setSafeArea"),
            "notify:stateHandler.leavingBeforeLoaderCloseState": a.onLoaderClose,
            "notify:serverManager.actionRequestSent": a.onServerRequest,
            "notify:serverManager.actionRequestError": a.tryToHideAnimation,
            "notify:serverManager.slowRequest": a.onSlowResponse,
            "notify:responseParser.responseParsed": a.onServerResponse,
            "request:slowRequestAnimation.show": a.showSpinnerAnimation,
            "request:slowRequestAnimation.hide": a.hideSpinnerAnimation
        })
    }, onLoaderClose: function () {
        this.view.initView()
    }, onShowDialog: function (a) {
        var b = this;
        b.fireEvent("request:dialogWindow.showDialog", a);
        b.model.storeData("dialogShowing", true)
    }, animationRequested: function () {
        var a = this;
        if (a.model.isState("active")) {
            a.view.display({modal: false});
            a.model.setState("running")
        }
    }, showSpinnerAnimation: function () {
        this.fireEvent("request:userInputManager.activateExclusivity", "slowRequestAnimation");
        this.view.addOverlay();
        this.view.showSpinner()
    }, hideSpinnerAnimation: function () {
        this.fireEvent("request:userInputManager.deactivateExclusivity", "slowRequestAnimation");
        this.view.removeOverlay();
        this.view.hideSpinner()
    }, onServerRequest: function (b) {
        var a = this;
        if (a.model.readData("requestConfig").contains(b) && a.model.isState("idle")) {
            a.model.setState("active");
            a.model.pushActive(b)
        }
    }, onSlowResponse: function () {
        this.animationRequested()
    }, onServerResponse: function (a) {
        if ((Sys.isDefined(a) && Sys.isDefined(a.clientaction))) {
            this.tryToHideAnimation(a.clientaction)
        }
    }, tryToHideAnimation: function (d) {
        var c = this, b = c.model, a;
        if (b.isState("running") || b.isState("active")) {
            a = b.updateActiveStack(d);
            if (a.length > 0) {
            } else {
                if (c.model.readData("dialogShowing")) {
                    c.fireEvent("request:dialogWindow.closeCurrentDialog")
                }
                c.view.hideWrapper();
                c.view.resetSlowMessage();
                c.view.resetDialogMessage(false);
                b.setState("idle")
            }
        }
    }, onDialogContinueOption: function () {
        this.view.resetDialogMessage(true)
    }
};
Core.SlowRequestAnimationController = Sys.extend(Core.Controller, Core.SlowRequestAnimationController, "Core.SlowRequestAnimationController");
Sys.ns("Core.Slots");
Core.SlowRequestAnimationView = {
    BASE_CSS: "interface-slowRequestAnimation _base",
    PORTRAIT_CSS: "interface-slowRequestAnimation _portrait",
    LANDSCAPE_CSS: "interface-slowRequestAnimation _landscape",
    PIXEL_FACTOR: 0.01,
    constructor: function () {
        Core.SlowRequestAnimationView.superclass.constructor.apply(this, arguments)
    },
    initView: function () {
        var a = this;
        a.hasOverlay = false;
        a.setupElements()
    },
    removeOverlay: function () {
        var b = this, a = b.getLayoutConfig().background, c = b.getLayoutConfig().animation;
        b.background.el.style.top = a.top * b.PIXEL_FACTOR + "rem";
        b.background.el.style.left = a.left * b.PIXEL_FACTOR + "rem";
        b.background.el.style.width = a.width * b.PIXEL_FACTOR + "rem";
        b.background.el.style.height = a.height * b.PIXEL_FACTOR + "rem";
        b.background.el.style.borderRadius = "0";
        b.background.el.style.zIndex = 340;
        b.animation.el.style.top = c.top * b.PIXEL_FACTOR + "rem";
        b.animation.el.style.left = c.left * b.PIXEL_FACTOR + "rem";
        b.hasOverlay = false
    },
    addOverlay: function () {
        var b = this, a = b.getLayoutConfig().overlayConfig.background, c = b.getLayoutConfig().overlayConfig.animation;
        b.background.el.style.top = a.top * b.PIXEL_FACTOR + "rem";
        b.background.el.style.left = a.left * b.PIXEL_FACTOR + "rem";
        b.background.el.style.width = a.width * b.PIXEL_FACTOR + "rem";
        b.background.el.style.height = a.height * b.PIXEL_FACTOR + "rem";
        b.background.el.style.borderRadius = "0";
        b.background.el.style.zIndex = 340;
        b.animation.el.style.top = c.top * b.PIXEL_FACTOR + "rem";
        b.animation.el.style.left = c.left * b.PIXEL_FACTOR + "rem";
        b.hasOverlay = true
    },
    onPortrait: function () {
        var a = this;
        Mixins.orientation.view.methods.onPortrait.call(a);
        if (a.hasOverlay) {
            a.addOverlay()
        }
    },
    onLandscape: function () {
        var a = this;
        Mixins.orientation.view.methods.onLandscape.call(a);
        if (a.hasOverlay) {
            a.addOverlay()
        }
    },
    getLayoutConfig: function () {
        var a = {width: 960, height: 540}, b = Environment.getStageResolution().height;
        return {
            overlayConfig: {
                background: {
                    top: 0 - Environment.getSpaceAboveGame(),
                    left: 0,
                    width: a.width,
                    height: b / Environment.getScale() + Environment.getSpaceBelowGame()
                },
                animation: {
                    top: (b - Environment.scaleValue(310)) / 2 + Environment.getSpaceAboveGame(),
                    left: a.width / 2 - (Environment.scaleValue(210) / 2)
                }
            },
            wrapper: {top: 0, left: 0},
            background: {
                top: (a.height / 2) - (Environment.scaleValue(180) / 2),
                left: (a.width / 2) - (Environment.scaleValue(210) / 2),
                width: Environment.scaleValue(210),
                height: Environment.scaleValue(180)
            },
            animation: {
                top: (a.height / 2) - (Environment.scaleValue(180) / 2),
                left: (a.width / 2) - (Environment.scaleValue(376) / 2),
                width: Environment.scaleValue(210),
                height: Environment.scaleValue(180)
            },
            textArea: {top: Environment.scaleValue(130), left: 0, width: 0, height: Environment.scaleValue(80)},
            guiArea: {top: Environment.scaleValue(410), left: 0, width: 0, height: Environment.scaleValue(100)}
        }
    },
    setupBackgroundArea: function (c) {
        var b = this, a = c || b.getLayoutConfig();
        return new Sys.Element({
            tag: "div",
            id: "slowRequestAnimation",
            cls: "slowRequestAnimation background",
            style: "top:" + a.background.top * b.PIXEL_FACTOR + "rem;left:" + a.background.left * b.PIXEL_FACTOR + "rem;width:" + a.background.width * b.PIXEL_FACTOR + "rem;height:" + a.background.height * b.PIXEL_FACTOR + "rem;"
        })
    },
    getDialogConfig: function () {
        var a = this;
        return {
            slowDialog: {
                title: Services.languageManager.getText(Language.Keys.connectionQualityPoor),
                text: Services.languageManager.getText(Language.Keys.slowConnection),
                buttons: [{
                    text: Services.languageManager.getText(Language.Keys.btn_casino),
                    action: Environment.goToLobby.bind(Environment, "9")
                }, {
                    text: Services.languageManager.getText(Language.Keys.btn_continue),
                    action: a.fireEvent.bind(a, "view:dialogContinue")
                }]
            }
        }
    },
    setupAnimationArea: function (c) {
        var b = this, a = c || this.getLayoutConfig();
        return new Sys.Element({
            tag: "div",
            cls: "slowRequestAnimation loadAnimation animation slowRequestAnimation_uri",
            style: "width:" + a.animation.width * b.PIXEL_FACTOR + "rem;height:" + a.animation.height * b.PIXEL_FACTOR + "rem;"
        })
    },
    setupTextArea: function (c) {
        var b = this, d, a = c || this.getLayoutConfig();
        b.textSpan = new Sys.Element({
            tag: "span",
            textContent: Services.languageManager.getText(Language.Keys.slowConnection)
        });
        d = new Sys.Element({
            tag: "div",
            cls: "slowRequestAnimation text hide",
            style: "left:" + a.textArea.left * b.PIXEL_FACTOR + "rem;width:100%;min-height:" + a.textArea.height * b.PIXEL_FACTOR + "rem;"
        });
        d.add(b.textSpan);
        return d
    },
    setupElements: function () {
        var b = this, a = b.getLayoutConfig();
        b.wrapper = new Sys.Element({
            tag: "div",
            id: "slowRequestAnimation",
            cls: "slowRequestAnimation wrapper hide",
            style: "top:" + a.wrapper.top * b.PIXEL_FACTOR + "rem;left:" + a.wrapper.left * b.PIXEL_FACTOR + "rem;width: 100%;height: 100%;",
            renderTo: "gameWrapper"
        });
        b.background = b.setupBackgroundArea(a);
        b.animation = b.setupAnimationArea(a);
        b.textArea = b.setupTextArea(a);
        b.background.add(b.animation);
        b.wrapper.add(b.background);
        b.wrapper.add(b.textArea);
        b.container = b.wrapper;
        b.fireEvent("view:setSafeArea", "slowRequestAnimation", {element: b.container.getEl()})
    },
    setupRequestDialogTimeout: function () {
        var b = this, c, a = b.model.readData("timeConfig").slowDialogTime;
        c = setTimeout(function () {
            b.requestSlowDialog()
        }, a);
        b.model.storeDialogTimeout(c)
    },
    requestSlowDialog: function () {
        var b = this, a = b.getDialogConfig().slowDialog;
        if (b.model.isState("running")) {
            b.hideSpinner();
            b.hideText();
            b.fireEvent("view:showDialog", a)
        }
    },
    onShowSlowConnection: function () {
        this.showText()
    },
    display: function (a) {
        var c = this, d, b;
        if (a.modal) {
            c.wrapper.addCls("modal")
        }
        c.wrapper.removeCls("hide");
        if (!a.modal) {
            b = c.model.readData("timeConfig").slowConnectionTime;
            d = setTimeout(function () {
                c.onShowSlowConnection();
                c.setupRequestDialogTimeout()
            }, b);
            c.model.storeSlowConnectionTimeout(d)
        }
        return true
    },
    resetSlowMessage: function () {
        var a = this, b = a.model.getSlowConnectionTimeout();
        if (b) {
            a.model.removeSlowTimeout();
            a.hideText()
        }
    },
    resetDialogMessage: function (a) {
        var b = this, c = b.model.getDialogTimeout();
        if (c) {
            b.model.removeDialogTimeout();
            if (a && b.model.isState("running")) {
                b.showSpinner();
                b.showText();
                b.setupRequestDialogTimeout()
            }
        }
    },
    showSpinner: function () {
        this.wrapper.removeCls("hide")
    },
    hideSpinner: function () {
        this.hideWrapper()
    },
    hideWrapper: function () {
        this.wrapper.addCls("hide")
    },
    hideText: function () {
        this.textArea.addCls("hide")
    },
    showText: function () {
        this.textArea.removeCls("hide")
    }
};
Core.SlowRequestAnimationView = Sys.extend(Core.View, Core.SlowRequestAnimationView, "Core.SlowRequestAnimationView");
Sys.ns("Core");
Core.SlowRequestAnimationDesktopView = {
    constructor: function () {
        Core.SlowRequestAnimationDesktopView.superclass.constructor.apply(this, arguments)
    }, setupRequestDialogTimeout: function () {
    }
};
Core.SlowRequestAnimationDesktopView = Sys.extend(Core.SlowRequestAnimationView, Core.SlowRequestAnimationDesktopView, "Core.SlowRequestAnimationDesktopView");
Sys.ns("Interface");
Interface.HomeButton = {
    constructor: function () {
        Interface.HomeButton.superclass.constructor.apply(this, arguments)
    }, getMixinDependencies: function () {
        return ["orientation", {userInput: {listenToUserInput: true}}]
    }, getDefaultMVCClasses: function () {
        return {controller: Interface.HomeButtonController, model: Core.Model, view: Interface.HomeButtonBaseView}
    }
};
Interface.HomeButton = Sys.extend(Core.Module, Interface.HomeButton, "Interface.HomeButton");
Sys.ns("Interface");
Interface.HomeButtonController = {
    constructor: function () {
        Interface.HomeButtonController.superclass.constructor.apply(this, arguments)
    }, setupEvents: function () {
        var a = this;
        Interface.HomeButtonController.superclass.setupEvents.apply(this, arguments);
        a.on({
            "view:setSafeArea": a.fireEvent.bind(a, "request:fullscreen.setSafeArea"),
            "notify:stateHandler.leavingBeforeLoaderCloseState": a.onLoaderClose,
            "notify:settingsMenu.open": a.view.hide.bind(a.view),
            "notify:settingsMenu.closed": a.view.show.bind(a.view),
            "request:homeButton.hidePermanently": a.hidePermanently
        })
    }, onLoaderClose: function () {
        var a = this;
        a.view.show();
        a.view.setFullscreenSafeArea()
    }, hidePermanently: function () {
        this.model.storeData("hiddenPermanently", true);
        this.view.hide()
    }, onUserInputStart: function (a) {
        if (this.view.isInputTarget(a)) {
            this.model.storeData("activeInputTarget", true)
        }
    }, onUserInputEnd: function (c) {
        var b = this, a = Resources.readData("lobbyUrl");
        if (b.model.readData("activeInputTarget")) {
            if (b.view.isInputTarget(c)) {
                if (Sys.isDefined(a) && a !== "") {
                    b.fireEvent("request:slowRequestAnimation.show")
                }
                Environment.goToLobby(0)
            }
        }
        b.model.storeData("activeInputTarget", false)
    }
};
Interface.HomeButtonController = Sys.extend(Core.Controller, Interface.HomeButtonController, "Interface.HomeButtonController");
Sys.ns("Interface");
Interface.HomeButtonBaseView = {
    BASE_BUTTON_CSS: "interface-homeButton_baseButton",
    PORTRAIT_CSS: "interface-homeButton_portraitBase",
    LANDSCAPE_CSS: "interface-homeButton_landscapeBase",
    URI_BUTTON: "interface-homeButton_button_uri",
    RENDER_TARGET: "gameWrapper",
    constructor: function () {
        Interface.HomeButtonBaseView.superclass.constructor.apply(this, arguments)
    },
    adaptToOrientation: function (a) {
        this.setStyle(a)
    },
    init: function () {
        var a = this;
        Interface.HomeButtonBaseView.superclass.init.apply(a, arguments);
        a.container = new Sys.Element({
            id: "homeButton",
            tag: "div",
            cls: a.BASE_BUTTON_CSS,
            renderTo: a.RENDER_TARGET,
            style: "display: none;"
        })
    },
    setFullscreenSafeArea: function () {
        var a = this;
        a.fireEvent("view:setSafeArea", "homeButton", {element: a.container.getEl()})
    },
    show: function () {
        var b = this, a = b.container;
        if (!b.model.readData("hiddenPermanently")) {
            a.el.style.display = "block";
            if (!a.hasCls(b.URI_BUTTON)) {
                a.addCls(b.URI_BUTTON)
            }
        }
    },
    hide: function () {
        this.container.el.style.display = "none"
    },
    isInputTarget: function (a) {
        return Sys.UserInputUtils.isCoordinateTarget(this.container.el, a)
    },
    setStyle: function (a) {
        var c = this, d = a + "_CSS", b = a === "LANDSCAPE" ? "PORTRAIT_CSS" : "LANDSCAPE_CSS";
        if (Sys.isDefined(c[d])) {
            c.container.removeCls(c[b]);
            c.container.addCls(c[d])
        }
    }
};
Interface.HomeButtonBaseView = Sys.extend(Core.View, Interface.HomeButtonBaseView, "Interface.HomeButtonBaseView");
Sys.ns("Interface");
Interface.HomeButtonMobileView = {
    PORTRAIT_CSS: "interface-homeButton_portraitBase_mobile",
    LANDSCAPE_CSS: "interface-homeButton_landscapeBase_mobile",
    constructor: function () {
        Interface.HomeButtonMobileView.superclass.constructor.apply(this, arguments)
    }
};
Interface.HomeButtonMobileView = Sys.extend(Interface.HomeButtonBaseView, Interface.HomeButtonMobileView, "Interface.HomeButtonMobileView");
Sys.ns("Interface");
Interface.SoundOnOffButton = {
    constructor: function () {
        Interface.SoundOnOffButton.superclass.constructor.apply(this, arguments)
    }, getMixinDependencies: function () {
        return ["orientation", {userInput: {listenToUserInput: true}}, {properties: {updateOnStartup: true}}]
    }, getDefaultMVCClasses: function () {
        return {
            controller: Interface.SoundOnOffButtonController,
            model: Core.Model,
            view: Interface.SoundOnOffButtonBaseView
        }
    }
};
Interface.SoundOnOffButton = Sys.extend(Core.Module, Interface.SoundOnOffButton, "Interface.SoundOnOffButton");
Sys.ns("Interface");
Interface.SoundOnOffButtonController = {
    constructor: function () {
        Interface.SoundOnOffButtonController.superclass.constructor.apply(this, arguments)
    }, setupEvents: function () {
        var a = this;
        a.on({
            "notify:audioPlayer.loadingSound": a.loadingSound,
            "notify:audioPlayer.soundLoaded": a.soundFinishedLoading,
            "notify:settingsMenu.open": a.onSettingsMenuOpened,
            "notify:settingsMenu.closed": a.onSettingsMenuClosed,
            "notify:settingsManager.settingChanged": a.onSettingChanged
        })
    }, loadingSound: function () {
        this.model.storeData("soundIsLoading", true);
        this.addProperty("soundLoading", this.MODULE_NAME)
    }, soundFinishedLoading: function () {
        this.model.storeData("soundIsLoading", false);
        this.removeProperty("soundLoading", this.MODULE_NAME)
    }, onSettingsMenuOpened: function () {
        this.addProperty("hidden", "settingsMenuOpen")
    }, onSettingsMenuClosed: function () {
        this.removeProperty("hidden", "settingsMenuOpen")
    }, onUserInputStart: function (a) {
        if (this.model.readData("soundIsLoading")) {
            return
        }
        this.model.storeData("isInputTarget", this.view.isTarget(a))
    }, onUserInputEnd: function (a) {
        if (this.model.readData("soundIsLoading")) {
            return
        }
        if (this.view.isTarget(a) && this.model.readData("isInputTarget")) {
            Services.settingsManager.storeSetting("volume", Services.settingsManager.getSetting("volume") > 0 ? 0 : 1)
        }
    }, onSettingChanged: function (a) {
        if (a === "volume") {
            this.updateAppearance()
        }
    }, updateAppearance: function () {
        this.view.update()
    }
};
Interface.SoundOnOffButtonController = Sys.extend(Core.Controller, Interface.SoundOnOffButtonController, "Interface.SoundOnOffButtonController");
Sys.ns("Interface");
Interface.SoundOnOffButtonBaseView = {
    BASE_BUTTON_CSS: "interface-soundOnOffButton_baseButton",
    PORTRAIT_CSS: "interface-soundOnOffButton_portrait",
    LANDSCAPE_CSS: "interface-soundOnOffButton_landscape",
    ON_URI: "interface-soundOnOffButton_on_uri",
    OFF_URI: "interface-soundOnOffButton_off_uri",
    LOADING_URI: "interface-smallSpinner_uri",
    RENDER_TARGET: "gameWrapper",
    constructor: function () {
        Interface.SoundOnOffButtonBaseView.superclass.constructor.apply(this, arguments)
    },
    adaptToOrientation: function (a) {
        this.setStyle(a)
    },
    init: function () {
        var a = this;
        Interface.SoundOnOffButtonBaseView.superclass.init.apply(a, arguments);
        a.container = new Sys.Element({
            id: "soundOnOffButton",
            tag: "div",
            cls: a.BASE_BUTTON_CSS,
            renderTo: a.RENDER_TARGET
        })
    },
    isTarget: function (a) {
        return Sys.UserInputUtils.isCoordinateTarget(this.container.el, a)
    },
    setStyle: function (a) {
        var c = this, d = a + "_CSS", b = a === "LANDSCAPE" ? "PORTRAIT_CSS" : "LANDSCAPE_CSS";
        if (Sys.isDefined(c[d])) {
            c.container.removeCls(c[b]);
            c.container.addCls(c[d])
        }
    },
    update: function () {
        var c = this, b = c.model, a = c.container;
        if (b.hasProperty("hidden")) {
            a.el.style.display = "none"
        } else {
            a.el.style.display = "block"
        }
        a.removeCSSClass(c.ON_URI);
        a.removeCSSClass(c.OFF_URI);
        a.removeCSSClass(c.LOADING_URI);
        if (b.hasProperty("soundLoading")) {
            a.addCSSClass(c.LOADING_URI)
        } else {
            if (Services.settingsManager.getSetting("volume") > 0) {
                a.addCSSClass(c.ON_URI)
            } else {
                a.addCSSClass(c.OFF_URI)
            }
        }
    }
};
Interface.SoundOnOffButtonBaseView = Sys.extend(Core.View, Interface.SoundOnOffButtonBaseView, "Interface.SoundOnOffButtonBaseView");
Sys.ns("Interface");
Interface.SoundOnOffButtonMobileView = {
    PORTRAIT_CSS: "interface-soundOnOffButton_portrait_mobile",
    LANDSCAPE_CSS: "interface-soundOnOffButton_landscape_mobile",
    constructor: function () {
        Interface.SoundOnOffButtonMobileView.superclass.constructor.apply(this, arguments)
    }
};
Interface.SoundOnOffButtonMobileView = Sys.extend(Interface.SoundOnOffButtonBaseView, Interface.SoundOnOffButtonMobileView, "Interface.SoundOnOffButtonMobileView");
Sys.ns("Interface");
Interface.AutoPlayButton = {
    constructor: function () {
        Interface.AutoPlayButton.superclass.constructor.apply(this, arguments)
    }, getMixinDependencies: function () {
        return {
            fallback: ["orientation", "userInput", "animation", "properties"],
            desktop: [{userInput: {inputEvents: ["start", "end", "cancel", "move", "hover"]}}, "properties", "animation"]
        }
    }, getDefaultMVCClasses: function () {
        return {
            controller: Interface.AutoPlayButtonController,
            model: Interface.AutoPlayButtonModel,
            view: Interface.AutoPlayButtonBaseView
        }
    }
};
Interface.AutoPlayButton = Sys.extend(Core.Module, Interface.AutoPlayButton, "Interface.AutoPlayButton");
Sys.ns("Interface");
Interface.AutoPlayButtonController = {
    constructor: function () {
        Interface.AutoPlayButtonController.superclass.constructor.apply(this, arguments)
    }, setupEvents: function () {
        var a = this;
        Interface.AutoPlayButtonController.superclass.setupEvents.apply(a, arguments);
        a.on({
            "notify:stateHandler.leavingBeforeLoaderCloseState": a.onBeforeLoaderClose,
            "notify:stateHandler.leavingIdleState": a.hide,
            "notify:stateHandler.enteringIdleState": a.show,
            "notify:settingsManager.settingChanged": a.onSettingChanged,
            "notify:settingsManager.settingDisabled": a.settingDisabled,
            "notify:settingsManager.settingLocked": a.settingLocked,
            "notify:freeRounds.ended": a.onFreeRoundsEnded,
            "notify:freeRounds.reInitResponseReceived": a.onReInitResponse,
            "view:settingChangedLocally": a.onSettingChangedLocally
        })
    }, onSettingChanged: function (a, c) {
        var b = this, d = b.model.readData("isFreerounds");
        if (a === "autoPlayNrSpins") {
            this.view.changeSetting(a, c);
            if (c !== 0 && this.model.readData("restrictedModeEnabled") && !d) {
                this.fireEvent("request:spinSettings.show")
            }
        }
    }, onSettingChangedLocally: function (a, b) {
        this.fireEvent("request:settingsManager.storeData", a, b)
    }, settingDisabled: function (a) {
        if (a === "autoPlayNrSpins") {
            this.view.disable()
        }
    }, settingLocked: function (a) {
        if (a === "autoPlayNrSpins") {
            this.view.locked()
        }
    }, onBeforeLoaderClose: function () {
        var a = this;
        if (a.view.dispatchAddToContainerRequest()) {
            a.view.show()
        } else {
            a.fireEvent("request:quickSettingsMenu.removeAndDisableSetting", "autoPlay")
        }
    }, onFreeRoundsEnded: function () {
        if (this.model.readData("restrictedModeEnabled")) {
            this.model.storeData("isFreerounds", false);
            this.checkAndSetAvailability()
        }
    }, onReInitResponse: function (b) {
        var a;
        if (this.model.readData("restrictedModeEnabled")) {
            a = b.freeRoundsLeft;
            this.model.storeData("isFreerounds", a && a > 0);
            this.checkAndSetAvailability()
        }
    }, checkAndSetAvailability: function () {
        var a = this.model.readData("isFreerounds");
        if (!a) {
            this.view.disable();
            this.fireEvent("request:quickSettingsMenu.removeAndDisableSetting", "autoPlay")
        } else {
            this.view.dispatchAddToContainerRequest();
            this.view.enable();
            this.fireEvent("request:quickSettingsMenu.addAndEnableSetting", "autoPlay")
        }
    }
};
Interface.AutoPlayButtonController = Sys.extend(Interface.SettingsSectionController, Interface.AutoPlayButtonController, "Interface.AutoPlayButtonController");
Sys.ns("Interface");
Interface.AutoPlayButtonModel = {
    DEFAULT_NUMBER_OF_ROUNDS: 50, constructor: function () {
        Interface.AutoPlayButtonModel.superclass.constructor.apply(this, arguments)
    }, setupData: function () {
        var g = this, d = Resources.readData("gameServerInitResponseObject"), b = d.autoplay,
            a = g.DEFAULT_NUMBER_OF_ROUNDS, f = d.freeRoundsLeft, c, j, e, h;
        g.storeData("isFreerounds", Sys.isDefined(f) && f > 0);
        if (Sys.isDefined(b) && (g.validateSingleAutoPlayValue(b) || g.validateAutoplayArray(b))) {
            if (!Sys.isArray(b)) {
                c = b
            } else {
                c = b[0];
                for (e = 1; e < b.length; e++) {
                    j = Math.abs(a - c) - Math.abs(a - b[e]);
                    if (j > 0 || (j === 0 && b[e] > c)) {
                        c = b[e]
                    }
                }
            }
        } else {
            c = a
        }
        g.storeData("roundsToTrigger", c);
        h = Resources.readData("gameServerInitResponse").autoplayLossLimitEnabled || false;
        g.storeData("restrictedModeEnabled", h);
        if (h) {
            g.storeData("isRemovedAndDisabled", true)
        }
    }, validateAutoplayArray: function (a) {
        var b = this, c = true, d = a.length;
        if (Sys.isArray(a) && d > 0 && d < 9) {
            Sys.each(a, function (f, e) {
                a[e] = Sys.utils.toInt(f);
                if (!b.validateSingleAutoPlayValue(a[e])) {
                    c = false
                }
            })
        } else {
            c = false
        }
        return c
    }, validateSingleAutoPlayValue: function (a) {
        var b = true, c = Sys.utils.toInt(a);
        if (Sys.isArray(a) || isNaN(c) || c < 5 || c > 1000) {
            b = false
        }
        return b
    }
};
Interface.AutoPlayButtonModel = Sys.extend(Core.Model, Interface.AutoPlayButtonModel, "Interface.AutoPlayButtonModel");
Sys.ns("Interface");
Interface.AutoPlayButtonBaseView = {
    BASE_CSS: "interface-autoPlayButton_baseContainer",
    PORTRAIT_CSS: "interface-autoPlayButton_portraitBase",
    LANDSCAPE_CSS: "interface-autoPlayButton_landscapeBase",
    PRESSED_CSS: "interface-autoPlayButton_pressedBase",
    TOGGLE_BASE_CSS: "interface-autoPlayToggle_base",
    TOGGLE_BUTTON_WRAPPER_CSS: "interface-autoPlayToggle_buttonWrapper",
    TOGGLE_BUTTON_BACKGROUND_CSS: "",
    TOGGLE_BUTTON_HANDLE_CSS: "",
    NUMBER_DISPLAY_CSS: "interface-autoPlayButton_numberDisplay",
    TARGET_CONTAINER: "quickSettingsMenu",
    constructor: function () {
        Interface.AutoPlayButtonBaseView.superclass.constructor.apply(this, arguments)
    },
    changeSetting: function (b, d) {
        var c = this, a = true;
        if (b === "autoPlayNrSpins") {
            if (d === 0) {
                a = false;
                c.showNumberDisplay()
            }
            if (a !== c.button.isOn()) {
                c.sliderShown = a;
                c.button.toggle(a, true);
                if (a === true) {
                    c.hideNumberDisplay()
                }
            }
        }
    },
    setUpContent: function () {
        var a = this;
        a.container = new Sys.Element({id: "autoPlayButton", tag: "div", cls: a.BASE_CSS, style: "visibility:hidden;"});
        a.button = new Interface.utils.ToggleSwitch({
            id: "autoplayQuickSettingsButton",
            CSS: {
                base: a.TOGGLE_BASE_CSS,
                button_wrapper: a.TOGGLE_BUTTON_WRAPPER_CSS,
                button_background: a.TOGGLE_BUTTON_BACKGROUND_CSS,
                button_handle: a.TOGGLE_BUTTON_HANDLE_CSS
            },
            enabled: true,
            callback: a.onSwitchToggled.bind(a)
        });
        a.numberDisplay = new Sys.Element({
            tag: "div",
            "class": a.NUMBER_DISPLAY_CSS,
            textContent: a.model.readData("roundsToTrigger")
        });
        a.container.add(a.button.getContainer());
        a.container.add(a.numberDisplay)
    },
    dispatchAddToContainerRequest: function () {
        var a = this, b = a.model.readData("isFreerounds");
        if (a.model.readData("restrictedModeEnabled") && !b) {
            return false
        }
        a.fireEvent("view:addToContainer", a.TARGET_CONTAINER, {content: a.container});
        return true
    },
    onSwitchToggled: function (b) {
        var a = this;
        if (b) {
            a.fireEvent("view:settingChangedLocally", "autoPlayNrSpins", a.model.readData("roundsToTrigger"));
            a.hideNumberDisplay()
        } else {
            a.fireEvent("view:settingChangedLocally", "autoPlayNrSpins", 0);
            a.showNumberDisplay()
        }
    },
    show: function () {
        var a = this;
        a.container.el.style.visibility = "visible";
        a.button.enable()
    },
    hide: function () {
        var a = this;
        a.container.el.style.visibility = "hidden";
        a.button.disable()
    },
    press: function () {
        this.button.addCls(this.PRESSED_CSS)
    },
    release: function () {
        this.button.removeCls(this.PRESSED_CSS)
    },
    disable: function () {
        this.fireEvent("view:removeFromContainer", this.TARGET_CONTAINER, {content: this.container})
    },
    enable: function () {
        var a = this;
        a.fireEvent("view:addToContainer", a.TARGET_CONTAINER, {content: a.container})
    },
    locked: function () {
        this.disable()
    },
    showNumberDisplay: function () {
        this.numberDisplay.el.style.display = "block"
    },
    hideNumberDisplay: function () {
        this.numberDisplay.el.style.display = "none"
    },
    onUserInputStart: function (a) {
        this.wasInitialTarget = Sys.UserInputUtils.isCoordinateTarget(this.numberDisplay.el, a)
    },
    onUserInputMove: function () {
    },
    onUserInputEnd: function (a) {
        if (this.wasInitialTarget && Sys.UserInputUtils.isCoordinateTarget(this.numberDisplay.el, a)) {
            this.button.toggle()
        }
    },
    hideButton: function () {
    },
    showButton: function () {
    }
};
Interface.AutoPlayButtonBaseView = Sys.extend(Core.View, Interface.AutoPlayButtonBaseView, "Interface.AutoPlayButtonBaseView");
Sys.ns("Interface");
Interface.QuickSpinButton = {
    constructor: function () {
        Interface.QuickSpinButton.superclass.constructor.apply(this, arguments)
    }, getMixinDependencies: function () {
        return ["orientation"]
    }, getDefaultMVCClasses: function () {
        return {
            controller: Interface.QuickSpinButtonController,
            model: Interface.QuickSpinButtonModel,
            view: Interface.QuickSpinButtonBaseView
        }
    }
};
Interface.QuickSpinButton = Sys.extend(Core.Module, Interface.QuickSpinButton, "Interface.QuickSpinButton");
Sys.ns("Interface");
Interface.QuickSpinButtonController = {
    constructor: function () {
        Interface.QuickSpinButtonController.superclass.constructor.apply(this, arguments)
    }, setupEvents: function () {
        var a = this;
        Interface.QuickSpinButtonController.superclass.setupEvents.apply(a, arguments);
        a.on({
            "notify:stateHandler.leavingBeforeLoaderCloseState": a.onBeforeLoaderClose,
            "notify:stateHandler.leavingIdleState": a.view.hide.bind(a.view),
            "notify:stateHandler.enteringIdleState": a.view.show.bind(a.view),
            "notify:settingsManager.settingChanged": a.onSettingChanged,
            "notify:settingsManager.settingDisabled": a.settingDisabled,
            "view:settingChangedLocally": a.onSettingChangedLocally
        })
    }, onSettingChanged: function (a, b) {
        if (a === "quickSpin") {
            this.view.changeSetting(a, b)
        }
    }, onSettingChangedLocally: function (a, b) {
        this.fireEvent("request:settingsManager.storeData", a, b)
    }, settingDisabled: function (a) {
        var b = this;
        if (a === "quickSpin") {
            b.model.storeData("isRemovedAndDisabled", true);
            b.view.disable()
        }
    }, onBeforeLoaderClose: function () {
        var a = this;
        if (a.view.dispatchAddToContainerRequest()) {
            a.view.show()
        } else {
            a.fireEvent("request:quickSettingsMenu.removeAndDisableSetting", "quickSpin")
        }
    }
};
Interface.QuickSpinButtonController = Sys.extend(Interface.SettingsSectionController, Interface.QuickSpinButtonController, "Interface.QuickSpinButtonController");
Sys.ns("Interface");
Interface.QuickSpinButtonModel = {
    constructor: function () {
        Interface.QuickSpinButtonModel.superclass.constructor.apply(this, arguments)
    }, setupData: function () {
        var a = Services.localStorageManager.hasData("quickSpin") && Services.localStorageManager.readData("quickSpin") === "true";
        this.storeData("quickSpin", a);
        Services.settingsManager.storeSetting("quickSpin", a, false, false)
    }
};
Interface.QuickSpinButtonModel = Sys.extend(Core.Model, Interface.QuickSpinButtonModel, "Interface.QuickSpinButtonModel");
Sys.ns("Interface");
Interface.QuickSpinButtonBaseView = {
    BASE_CSS: "interface-quickSpinButton_baseContainer",
    PORTRAIT_CSS: "interface-quickSpinButton_portraitBase",
    LANDSCAPE_CSS: "interface-quickSpinButton_landscapeBase",
    PRESSED_CSS: "interface-quickSpinButton_pressedBase",
    TOGGLE_BASE_CSS: "interface-quickSpinToggle_base",
    TOGGLE_BUTTON_WRAPPER_CSS: "interface-quickSpinToggle_buttonWrapper",
    TOGGLE_BUTTON_BACKGROUND_CSS: "",
    TOGGLE_BUTTON_HANDLE_CSS: "",
    TARGET_CONTAINER: "quickSettingsMenu",
    constructor: function () {
        Interface.QuickSpinButtonBaseView.superclass.constructor.apply(this, arguments)
    },
    changeSetting: function (a, b) {
        if (a === "quickSpin" && b !== this.button.isOn()) {
            this.button.toggle(b, true)
        }
    },
    setUpContent: function () {
        var a = this;
        a.container = new Sys.Element({
            id: "quickSpinButton",
            tag: "div",
            cls: a.BASE_CSS,
            renderTo: a.RENDER_TARGET,
            style: "visibility:hidden;"
        });
        a.button = new Interface.utils.ToggleSwitch({
            id: "quickSpinQuickSettingsButton",
            CSS: {
                base: a.TOGGLE_BASE_CSS,
                button_wrapper: a.TOGGLE_BUTTON_WRAPPER_CSS,
                button_background: a.TOGGLE_BUTTON_BACKGROUND_CSS,
                button_handle: a.TOGGLE_BUTTON_HANDLE_CSS
            },
            enabled: true,
            callback: a.onSwitchToggled.bind(a, "quickSpin")
        });
        a.container.add(a.button.getContainer());
        a.button.toggle(a.model.readData("quickSpin"))
    },
    dispatchAddToContainerRequest: function () {
        var a = this;
        if (!a.model.readData("isRemovedAndDisabled")) {
            a.fireEvent("view:addToContainer", a.TARGET_CONTAINER, {content: a.container});
            return true
        }
        return false
    },
    onSwitchToggled: function (a, b) {
        this.fireEvent("view:settingChangedLocally", a, b)
    },
    show: function () {
        this.button.enable();
        this.container.el.style.visibility = "visible"
    },
    hide: function () {
        this.container.el.style.visibility = "hidden";
        this.button.disable()
    },
    disable: function () {
        var a = this;
        a.fireEvent("view:removeFromContainer", a.TARGET_CONTAINER, {content: a.container})
    },
    press: function () {
        this.button.addCls(this.PRESSED_CSS)
    },
    release: function () {
        this.button.removeCls(this.PRESSED_CSS)
    }
};
Interface.QuickSpinButtonBaseView = Sys.extend(Core.View, Interface.QuickSpinButtonBaseView, "Interface.QuickSpinButtonBaseView");
Sys.ns("Interface");
Interface.BalanceDisplay = {
    constructor: function () {
        Interface.BalanceDisplay.superclass.constructor.apply(this, arguments)
    }, getMixinDependencies: function () {
        return ["orientation"]
    }, getDefaultMVCClasses: function () {
        return {controller: Interface.BalanceDisplayController, view: Interface.BalanceDisplayBaseView}
    }
};
Interface.BalanceDisplay = Sys.extend(Core.Module, Interface.BalanceDisplay, "Interface.BalanceDisplay");
Sys.ns("Interface");
Interface.BalanceDisplayModel = {
    constructor: function () {
        Interface.BalanceDisplayModel.superclass.constructor.apply(this, arguments)
    }, setupData: function () {
    }
};
Interface.BalanceDisplayModel = Sys.extend(Core.Model, Interface.BalanceDisplayModel, "Interface.BalanceDisplayModel");
Sys.ns("Interface");
Interface.BalanceDisplayController = {
    constructor: function () {
        Interface.BalanceDisplayController.superclass.constructor.apply(this, arguments)
    }, setupEvents: function () {
        var a = this;
        a.on({
            "request:balanceDisplay.appendChild": a.appendChild,
            "request:balanceDisplay.addClass": a.view.addClass.bind(a.view),
            "request:balanceDisplay.removeClass": a.view.removeClass.bind(a.view)
        })
    }, appendChild: function (a) {
        this.view.addChild(a)
    }
};
Interface.BalanceDisplayController = Sys.extend(Core.Controller, Interface.BalanceDisplayController, "Interface.BalanceDisplayController");
Sys.ns("Interface");
Interface.BalanceDisplayBaseView = {
    BASE_CSS: "interface-balanceDisplay_base",
    PORTRAIT_CSS: "interface-balanceDisplay_portrait",
    LANDSCAPE_CSS: "interface-balanceDisplay_landscape",
    RENDER_TARGET: "gameWrapper",
    constructor: function () {
        Interface.BalanceDisplayBaseView.superclass.constructor.apply(this, arguments)
    },
    adaptToOrientation: function (a) {
        this.setStyle(a)
    },
    init: function () {
        this.constructDOMElement()
    },
    constructDOMElement: function () {
        var a = this;
        a.container = new Sys.Element({id: "gameFooter", tag: "div", cls: a.BASE_CSS, renderTo: a.RENDER_TARGET})
    },
    addClass: function (a) {
        this.container.addCls(a)
    },
    removeClass: function (a) {
        this.container.removeCls(a)
    },
    addChild: function (b) {
        var a = this;
        a.container.add(b)
    }
};
Interface.BalanceDisplayBaseView = Sys.extend(Core.View, Interface.BalanceDisplayBaseView, "Interface.BalanceDisplayBaseView");
Sys.ns("interface");
Interface.BalanceDisplayMobileView = {
    PORTRAIT_CSS: "interface-balanceDisplay_portrait_mobile",
    LANDSCAPE_CSS: "interface-balanceDisplay_landscape_mobile",
    constructor: function () {
        Interface.BalanceDisplayMobileView.superclass.constructor.apply(this, arguments)
    }
};
Interface.BalanceDisplayMobileView = Sys.extend(Interface.BalanceDisplayBaseView, Interface.BalanceDisplayMobileView, "Interface.BalanceDisplayMobileView");
Sys.ns("Interface");
Interface.BalanceDisplayDesktopView = {
    LANDSCAPE_CSS: "interface-balanceDisplay_landscape_desktop",
    constructor: function () {
        Interface.BalanceDisplayDesktopView.superclass.constructor.apply(this, arguments)
    }
};
Interface.BalanceDisplayDesktopView = Sys.extend(Interface.BalanceDisplayBaseView, Interface.BalanceDisplayDesktopView, "Interface.BalanceDisplayDesktopView");
Sys.ns("Interface");
Interface.SystemClock = {
    constructor: function () {
        Interface.SystemClock.superclass.constructor.apply(this, arguments)
    }, getMixinDependencies: function () {
        return ["orientation"]
    }, getDefaultMVCClasses: function () {
        return {
            controller: Interface.SystemClockController,
            model: Interface.SystemClockModel,
            view: Interface.SystemClockBaseView
        }
    }
};
Interface.SystemClock = Sys.extend(Core.Module, Interface.SystemClock, "Interface.SystemClock");
Sys.ns("Interface");
Interface.SystemClockController = {
    constructor: function () {
        Interface.SystemClockController.superclass.constructor.apply(this, arguments)
    }, setupEvents: function () {
        var a = this;
        a.on({
            "request:systemClock.enableInMode": a.view.show.bind(a.view),
            "request:systemClock.show": a.view.show.bind(a.view),
            "request:systemClock.hide": a.view.show.bind(a.hide)
        })
    }
};
Interface.SystemClockController = Sys.extend(Core.Controller, Interface.SystemClockController, "Interface.SystemClockController");
Sys.ns("Interface");
Interface.SystemClockModel = {
    constructor: function () {
        Interface.SystemClockModel.superclass.constructor.apply(this, arguments)
    }, getTime: function () {
        var a = new Date();
        return {hours: a.getHours(), minutes: a.getMinutes()}
    }
};
Interface.SystemClockModel = Sys.extend(Core.Model, Interface.SystemClockModel, "Interface.SystemClockModel");
Sys.ns("Interface");
Interface.SystemClockBaseView = {
    BASE_CSS: "interface-systemClock_base",
    PORTRAIT_POSITION: {ABOVE_GAME: true, TOP: 0.05, LEFT: 0.5},
    LANDSCAPE_POSITION: {BOTTOM: 0, LEFT: 0.055},
    RENDER_TARGET: "gameWrapper",
    constructor: function () {
        Interface.SystemClockBaseView.superclass.constructor.apply(this, arguments)
    },
    init: function () {
        var a = this;
        Interface.SystemClockBaseView.superclass.init.apply(a, arguments);
        a.container = new Sys.Element({
            id: "systemClock",
            tag: "div",
            cls: a.BASE_CSS,
            renderTo: a.RENDER_TARGET,
            style: "display:none;"
        });
        a.hours = document.createElement("span");
        a.container.el.appendChild(a.hours);
        a.colon = document.createElement("span");
        a.colon.textContent = ":";
        a.container.el.appendChild(a.colon);
        a.minutes = document.createElement("span");
        a.container.el.appendChild(a.minutes);
        a.showColon = true
    },
    updateTime: function () {
        var c = this, d = c.model.getTime(), a = d.hours, b = d.minutes;
        if (a < 10) {
            a = "0" + a
        }
        if (b < 10) {
            b = "0" + b
        }
        c.hours.textContent = a;
        c.minutes.textContent = b;
        c.colon.style.visibility = c.showColon ? "visible" : "hidden";
        c.showColon = !c.showColon;
        c.ticker = setTimeout(function () {
            c.updateTime()
        }, 1000)
    },
    show: function () {
        this.container.el.style.display = "block";
        this.updateTime()
    },
    hide: function () {
        this.container.el.style.display = "none";
        clearTimeout(this.ticker)
    }
};
Interface.SystemClockBaseView = Sys.extend(Core.View, Interface.SystemClockBaseView, "Interface.SystemClockBaseView");
Sys.ns("Interface");
Interface.SystemClockTabletView = {
    PORTRAIT_POSITION: {BOTTOM: 0, LEFT: 0.055}, constructor: function () {
        Interface.SystemClockTabletView.superclass.constructor.apply(this, arguments)
    }
};
Interface.SystemClockTabletView = Sys.extend(Interface.SystemClockBaseView, Interface.SystemClockTabletView, "Interface.SystemClockTabletView");
Sys.ns("Interface");
Interface.SystemClockDesktopView = {
    PORTRAIT_POSITION: undefined,
    LANDSCAPE_POSITION: undefined,
    constructor: function () {
        Interface.SystemClockDesktopView.superclass.constructor.apply(this, arguments)
    }
};
Interface.SystemClockDesktopView = Sys.extend(Interface.SystemClockBaseView, Interface.SystemClockDesktopView, "Interface.SystemClockDesktopView");
Sys.ns("Interface");
Interface.NetEntLogo = {
    constructor: function () {
        Interface.NetEntLogo.superclass.constructor.apply(this, arguments)
    }, getMixinDependencies: function () {
        return ["orientation"]
    }, getDefaultMVCClasses: function () {
        return {controller: Interface.NetEntLogoController, view: Interface.NetEntLogoBaseView}
    }
};
Interface.NetEntLogo = Sys.extend(Core.Module, Interface.NetEntLogo, "Interface.NetEntLogo");
Sys.ns("Interface");
Interface.NetEntLogoController = {
    constructor: function () {
        Interface.NetEntLogoController.superclass.constructor.apply(this, arguments)
    }, setupEvents: function () {
        var a = this;
        a.on({"request:netEntLogo.show": a.view.show.bind(a.view), "request:netEntLogo.hide": a.view.hide.bind(a.view)})
    }
};
Interface.NetEntLogoController = Sys.extend(Core.Controller, Interface.NetEntLogoController, "Interface.NetEntLogoController");
Sys.ns("Interface");
Interface.NetEntLogoBaseView = {
    BASE_CSS: "interface-netEntLogo_base interface-netEntLogo_uri",
    PORTRAIT_POSITION: {BELOW_GAME: true, BOTTOM: 0.01, LEFT: 0.5},
    LANDSCAPE_POSITION: {BOTTOM: 0, RIGHT: 0.04},
    RENDER_TARGET: "gameWrapper",
    constructor: function () {
        Interface.NetEntLogoBaseView.superclass.constructor.apply(this, arguments)
    },
    init: function () {
        var a = this;
        Interface.NetEntLogoBaseView.superclass.init.apply(a, arguments);
        a.hidden = false;
        a.container = new Sys.Element({id: "netEntLogo", tag: "div", cls: a.BASE_CSS, renderTo: a.RENDER_TARGET})
    },
    show: function () {
        this.container.el.style.display = "block"
    },
    hide: function () {
        this.container.el.style.display = "none"
    }
};
Interface.NetEntLogoBaseView = Sys.extend(Core.View, Interface.NetEntLogoBaseView, "Interface.NetEntLogoBaseView");
Sys.ns("Interface");
Interface.QuickSettingsMenu = {
    constructor: function () {
        Interface.QuickSettingsMenu.superclass.constructor.apply(this, arguments)
    }, getDefaultMVCClasses: function () {
        return {
            controller: Interface.QuickSettingsMenuController,
            model: Interface.QuickSettingsMenuModel,
            view: Interface.QuickSettingsMenuBaseView
        }
    }, getMixinDependencies: function () {
        return [{userInput: {listenToUserInput: true}}, "orientation", "properties"]
    }
};
Interface.QuickSettingsMenu = Sys.extend(Core.Module, Interface.QuickSettingsMenu, "Interface.QuickSettingsMenu");
Sys.ns("Interface");
Interface.QuickSettingsMenuController = {
    constructor: function () {
        Interface.QuickSettingsMenuController.superclass.constructor.apply(this, arguments)
    }, setupEvents: function () {
        var a = this;
        a.eventToUseWhenActive = {
            "notify:stateHandler.leavingBeforeLoaderCloseState": a.onLeavingBeforeLoaderCloseState,
            "notify:stateHandler.enteringIdleState": a.onEnteringIdleState.bind(a, true),
            "notify:stateHandler.leavingIdleState": a.onLeavingIdleState,
            "notify:spinButton.shown": a.show,
            "notify:spinButton.hidden": a.hide,
            "notify:spinButton.pressed": a.onSpinButtonPress,
            "notify:spinButton.released": a.onSpinButtonRelease.bind(a, true),
            "notify:settingsManager.settingChanged": a.onSettingsChanged
        };
        a.on({
            "request:quickSettingsMenu.addChild": a.addChild,
            "request:quickSettingsMenu.removeChild": a.removeChild,
            "request:quickSettingsMenu.externalActivate": a.onExternalActivate,
            "request:quickSettingsMenu.externalDeactivate": a.onExternalDeactivate,
            "request:quickSettingsMenu.movePosition": a.onMovePositionRequest,
            "request:quickSettingsMenu.removeAndDisableSetting": a.onRemoveAndDisableSetting,
            "request:quickSettingsMenu.addAndEnableSetting": a.onAddAndEnableSetting,
            "notify:autoPlayer.starting": a.onExternalDeactivate.bind(a, "autoplay"),
            "notify:autoPlayer.stopped": a.onExternalActivate.bind(a, "autoplay")
        });
        a.on(a.eventToUseWhenActive)
    }, onMovePositionRequest: function (a) {
        this.view.moveSettingPosition(a)
    }, onLeavingBeforeLoaderCloseState: function () {
        this.model.storeData("activated", false);
        this.view.deactivate()
    }, disableMenu: function () {
        var d = this, c = d.eventToUseWhenActive, e = Object.keys(c), b = e.length, a;
        for (a = -1; ++a < b;) {
            d.removeListener(e[a])
        }
        d.model.storeData("activated", false);
        d.hide()
    }, enableMenu: function () {
        var a = this;
        if (!a.model.readData("activated")) {
            a.on(a.eventToUseWhenActive);
            a.model.storeData("activated", true);
            a.show()
        }
    }, getChildCount: function () {
        return Object.keys(this.view.children).length
    }, addChild: function (c, a) {
        var b = this;
        b.view.addChild(c, a);
        if (b.getChildCount() > 0) {
            b.enableMenu()
        }
    }, removeChild: function (e, b) {
        var c = this, d = c.getChildCount(), a;
        c.view.removeChild(e, b);
        a = c.getChildCount();
        if (d !== a && a <= 0) {
            c.disableMenu()
        }
    }, onExternalDeactivate: function (a) {
        this.addProperty("externalDeactivated", a);
        this.hide()
    }, onExternalActivate: function (b) {
        var a = this;
        a.removeProperty("externalDeactivated", b);
        if (a.model.readData("status") !== "open") {
            a.show(true)
        }
    }, onSpinButtonPress: function () {
        if (this.model.readData("activated")) {
            this.hide()
        }
    }, onSpinButtonRelease: function (a) {
        if (this.model.readData("activated")) {
            this.show(a)
        }
    }, onEnteringIdleState: function (a) {
        if (this.getChildCount() === 0) {
            this.disableMenu();
            return
        }
        this.model.storeData("activated", true);
        this.show(a)
    }, onLeavingIdleState: function () {
        this.model.storeData("activated", false);
        this.hide()
    }, hide: function () {
        var a = this;
        a.model.storeData("hidden", true);
        a.view.deactivate();
        if (a.model.readData("status") === "open") {
            a.view.close();
            a.model.storeData("status", "close");
            a.fireEvent("request:spinButton.removeProperty", "visibleOnInput", a.MODULE_NAME)
        }
    }, show: function (a) {
        var b = this;
        if (!b.model.hasProperty("externalDeactivated")) {
            b.model.storeData("hidden", false);
            if (b.model.readData("activated")) {
                b.view.activate(a)
            }
        }
    }, onUserInputStart: function (a) {
        if (this.view.isInputTarget(a) && this.model.readData("activated")) {
            this.model.storeData("activeInputTarget", true)
        }
    }, onUserInputMove: function (a) {
    }, onUserInputEnd: function (c) {
        var b = this, a = b.model.readData("status");
        if (a === "open" && (b.view.isInputTarget(c) || !b.view.isContainer(c))) {
            b.view.close();
            b.model.storeData("status", "close");
            b.fireEvent("request:spinButton.removeProperty", "visibleOnInput", b.MODULE_NAME)
        } else {
            if (b.view.isInputTarget(c) && b.model.readData("activeInputTarget")) {
                b.view.open();
                b.model.storeData("status", "open");
                b.fireEvent("notify:quickSettingsMenu." + b.model.readState);
                b.fireEvent("request:spinButton.addProperty", "visibleOnInput", b.MODULE_NAME)
            }
        }
        b.model.storeData("activeInputTarget", false)
    }, onSettingsChanged: function (a, b) {
        if (a === "leftHandMode") {
            this.view.positionMenu(b)
        }
    }, onRemoveAndDisableSetting: function (a) {
        this.view.removeAndDisableSetting(a)
    }, onAddAndEnableSetting: function (a) {
        this.view.addAndEnableSetting(a)
    }
};
Interface.QuickSettingsMenuController = Sys.extend(Core.Controller, Interface.QuickSettingsMenuController, "Interface.QuickSettingsMenuController");
Sys.ns("Interface");
Interface.QuickSettingsMenuModel = {
    PROPERTIES: {externalDeactivated: []}, constructor: function () {
        Interface.QuickSettingsMenuModel.superclass.constructor.apply(this, arguments)
    }, setupData: function () {
        var b = this,
            a = Services.localStorageManager.hasData("leftHandMode") && Services.localStorageManager.readData("leftHandMode") === "true";
        b.storeData("children", {});
        b.storeData("disableDuringSpin", []);
        b.storeData("status", "close");
        b.storeData("leftHandMode", a)
    }
};
Interface.QuickSettingsMenuModel = Sys.extend(Core.Model, Interface.QuickSettingsMenuModel, "Interface.QuickSettingsMenuModel");
Sys.ns("Interface");
Interface.QuickSettingsMenuBaseView = {
    BASE_CSS: "interface-quickSettingsMenu_base",
    PORTRAIT_CSS: "interface-quickSettingsMenu_portrait",
    LANDSCAPE_CSS: "interface-quickSettingsMenu_landscape",
    LANDSCAPE_BG_URI: "interface-quickSettingsMenu_sliderBg_landscape_uri",
    PORTRAIT_BG_URI: "interface-quickSettingsMenu_sliderBg_portrait_uri",
    LANDSCAPE_FRONT_CSS: "interface-quickSettingsMenu_front_landscape",
    PORTRAIT_FRONT_CSS: "interface-quickSettingsMenu_front_portrait",
    LANDSCAPE_BACK_CSS: "interface-quickSettingsMenu_back_landscape",
    PORTRAIT_BACK_CSS: "interface-quickSettingsMenu_back_portrait",
    SLIDER_BUTTON_URI: "interface-quickSettingsMenu_sliderButton_uri",
    ICON_BASE_CSS: "interface-quickSettingsMenu_icon_base",
    LANDSCAPE_ICON_CSS: "interface-quickSettingsMenu_icon_landscape",
    PORTRAIT_ICON_CSS: "interface-quickSettingsMenu_icon_portrait",
    ICON_CLOSE_CSS: "interface-quickSettingsMenu_icon_close",
    ICON_OPEN_CSS: "interface-quickSettingsMenu_icon_open",
    ICON_URI: "interface-quickSettingsMenu_icon_uri",
    BASE_SLIDE_CSS: "interface-quickSettingsMenu_portraitSlide",
    LANDSCAPE_AUTOPLAY_SLIDE_CSS: "interface-quickSettingsMenu_autoPlaySlide_landscape",
    PORTRAIT_AUTOPLAY_SLIDE_CSS: "interface-quickSettingsMenu_autoPlaySlide_portrait",
    AUTOPLAY_SLIDE_CLOSE: "interface-quickSettingsMenu_autoPlaySlide_close",
    AUTOPLAY_SLIDE_OPEN: "interface-quickSettingsMenu_autoPlaySlide_open",
    LANDSCAPE_QUICKSPIN_SLIDE_CSS: "interface-quickSettingsMenu_quickSpinSlide_landscape",
    PORTRAIT_QUICKSPIN_SLIDE_CSS: "interface-quickSettingsMenu_quickSpinSlide_portrait",
    QUICKSPIN_SLIDE_CLOSE: "interface-quickSettingsMenu_quickSpinSlide_close",
    QUICKSPIN_SLIDE_OPEN: "interface-quickSettingsMenu_quickSpinSlide_open",
    BASE_CHILDREN_CSS: "interface-quickSettingsMenu_children_base",
    LANDSCAPE_CHILDREN_CSS: "interface-quickSettingsMenu_children_landscape_base",
    PORTRAIT_CHILDREN_CSS: "interface-quickSettingsMenu_children_portrait_base",
    CHILD_CSS: "interface-quickSettingsMenu_child_base",
    PORTRAIT_CHILD_CSS: "interface-quickSettingsMenu_child_portrait",
    LANDSCAPE_CHILD_CSS: "interface-quickSettingsMenu_child_landscape",
    HANDLE_CSS: "interface-quickSettingsMenu_handle",
    LANDSCAPE_HANDLE_CSS: {
        open: "interface-quickSettingsMenu_handle_open_landscape",
        close: "interface-quickSettingsMenu_handle_close_landscape"
    },
    PORTRAIT_HANDLE_CSS: {
        open: "interface-quickSettingsMenu_handle_portrait",
        close: "interface-quickSettingsMenu_handle_portrait"
    },
    MENU_LEFT_SIDE_CSS: "interface-quickSettingsMenu_left",
    HANDLE_LEFT_SIDE_CSS: "interface-quickSettingsMenu_handle_left",
    PORTRAIT_POSITION: {BELOW_GAME: true, TOP: 0.4, MIN_TOP: 825, LEFT: 0.3994},
    PORTRAIT_SIZE: {HEIGHT: 0.55, WIDTH: 0.28},
    LANDSCAPE_CLOSEDSIZE: "0.00rem",
    LANDSCAPE_FRONTSTARTPOS: "-0.64rem",
    LANDSCAPE_FRONTENDPOS: "-0.24rem",
    LANDSAPE_BACKSTARTPOS: "0.00rem",
    LANDSCAPE_BACKENDPOS: "0.50rem",
    LANDSCAPE_OPENSIZE: "2.70rem",
    RENDER_TARGET: "gameWrapper",
    PIXEL_FACTOR: 0.01,
    constructor: function () {
        Interface.QuickSettingsMenuBaseView.superclass.constructor.apply(this, arguments)
    },
    moveSettingPosition: function (a) {
        var b = this;
        if (Sys.isDefined(a)) {
            if (Sys.isString(a.orientation) && a.orientation.toLowerCase() === "portrait") {
                if (Sys.isDefined(a.vertical)) {
                    b.PORTRAIT_POSITION.TOP = b.PORTRAIT_POSITION.TOP + a.vertical
                }
                if (Environment.getViewportOrientation() === "LANDSCAPE") {
                    b.onLandscape()
                } else {
                    b.onPortrait()
                }
            }
        }
    },
    open: function () {
        var b = this, a = Environment.getViewportOrientation();
        b["open" + a](a);
        b.icon.replaceCSSClass(b.ICON_CLOSE_CSS, b.ICON_OPEN_CSS)
    },
    openLANDSCAPE: function () {
        var d = this, a = d.model.readData("status"), c = d.getNewStatus(a), e = d.LANDSCAPE_HANDLE_CSS,
            b = d.animations.LANDSCAPE;
        d.back.el.style.display = "block";
        d.childrenContainer.el.style.display = "block";
        if (a !== c) {
            d.handle.replaceCSSClass(e[a], e[c])
        }
        Sys.iterate(d.children, function (f) {
            b.openChild.run(d.children[f].el)
        });
        b.open.run(d.container.el);
        b.openFront.run(d.front.el);
        b.openBack.run(d.back.el);
        if (Sys.isIphone4Or4s) {
            d.container.el.style.display = "none";
            d.container.el.style.display = "block"
        }
    },
    openPORTRAIT: function () {
        var a = this;
        a.childrenContainer.el.style.display = "none";
        a.front.el.style.left = "";
        Sys.iterate(a.children, function (b) {
            a.children[b].el.style.opacity = 1
        });
        a.autoPlaySlide.replaceCSSClass(a.AUTOPLAY_SLIDE_CLOSE, a.AUTOPLAY_SLIDE_OPEN);
        a.quickSpinSlide.replaceCSSClass(a.QUICKSPIN_SLIDE_CLOSE, a.QUICKSPIN_SLIDE_OPEN)
    },
    getNewStatus: function (a) {
        if (Environment.getViewportOrientation() === this.currentOrientation) {
            return (a === "close") ? "open" : "close"
        }
        return a
    },
    close: function () {
        var b = this, a = Environment.getViewportOrientation();
        b["close" + a](a);
        b.icon.replaceCSSClass(b.ICON_OPEN_CSS, b.ICON_CLOSE_CSS)
    },
    closeLANDSCAPE: function () {
        var d = this, a = d.model.readData("status"), c = (a === "close") ? "open" : "close",
            b = d.animations.LANDSCAPE;
        d.handle.replaceCSSClass(d.LANDSCAPE_HANDLE_CSS[a], d.LANDSCAPE_HANDLE_CSS[c]);
        Sys.iterate(d.children, function (e) {
            b.closeChild.run(d.children[e].el)
        });
        b.close.run(d.container.el);
        b.closeFront.run(d.front.el);
        b.closeBack.run(d.back.el);
        if (Sys.isIphone4Or4s) {
            d.container.el.style.display = "none";
            d.container.el.style.display = "block"
        }
    },
    closePORTRAIT: function () {
        var a = this;
        a.autoPlaySlide.replaceCSSClass(a.AUTOPLAY_SLIDE_OPEN, a.AUTOPLAY_SLIDE_CLOSE);
        a.quickSpinSlide.replaceCSSClass(a.QUICKSPIN_SLIDE_OPEN, a.QUICKSPIN_SLIDE_CLOSE)
    },
    activate: function (c) {
        var b = this, a = Environment.getViewportOrientation();
        if (b.model.readData("hidden")) {
            return
        }
        if (!b.model.readData("animationReady")) {
            b.setupAnimations()
        }
        b.container.el.style.display = "block";
        b.childrenContainer.el.style.display = "none";
        b.back.el.style.display = "none";
        b.handle.el.style.display = "block";
        if (c) {
            b.animations[a].activate.run(b.container.el)
        }
    },
    deactivate: function () {
        var b = this, a = Sys.utils.pollyFill("animation");
        b.childrenContainer.el.style.display = "none";
        b.handle.el.style.display = "none";
        b.container.el.style.display = "none";
        b.container.el.style[a] = "none";
        b.front.el.style[a] = "none"
    },
    isInputTarget: function (a) {
        return Sys.UserInputUtils.isCoordinateTarget(this.handle.el, a)
    },
    isContainer: function (a) {
        return Sys.UserInputUtils.isCoordinateTarget(this.container.el, a)
    },
    init: function () {
        var a = this;
        Interface.QuickSettingsMenuBaseView.superclass.init.apply(a, arguments);
        a.setupDOMStructure();
        a.children = {}
    },
    setupEvents: function () {
        var a = this;
        a.on({
            "model:childAdded": a.addChild,
            "model:childRemoved": a.removeChild,
            "model:childActivated": a.activateChild,
            "model:childDeactivated": a.deactivateChild
        })
    },
    addChild: function (e, b) {
        var d = this, a = Environment.getViewportOrientation(), c = b.content;
        c.addCls(d.CHILD_CSS);
        c.addCls(d[a + "_CHILD_CSS"]);
        d.append(e, c, a);
        d.children[e] = c
    },
    append: function (d, c, a) {
        var b = this;
        if (a === "LANDSCAPE") {
            b.childrenContainer.add(c)
        } else {
            if (d === "autoPlayButton") {
                b.autoPlaySlide.add(c)
            } else {
                if (d === "quickSpinButton") {
                    b.quickSpinSlide.add(c)
                }
            }
        }
    },
    removeChild: function (d, b) {
        var c = this, a = Environment.getViewportOrientation();
        if (a === "LANDSCAPE" && Sys.isObj(b)) {
            c.childrenContainer.remove(b.content)
        } else {
            if (d === "autoPlayButton" && Sys.isObj(b)) {
                c.autoPlaySlide.remove(b.content)
            } else {
                if (d === "quickSpinButton") {
                    c.quickSpinSlide.remove(b.content)
                }
            }
        }
        delete c.children[d]
    },
    onPortrait: function () {
        var d = this, b = d.model.readData("status"), c = Sys.utils.pollyFill("animation"),
            a = Sys.isDefined(d.animations) && d.model.readData("activated");
        if (Environment.getViewportOrientation() !== this.currentOrientation) {
            d.adaptToOrientation("PORTRAIT");
            if (a) {
                d.container.el.style[c] = "none";
                d.animations.PORTRAIT.activate.run(d.container.el)
            }
            Sys.iterate(d.children, function (e) {
                d.children[e].el.style[c] = "none"
            });
            d[b + "PORTRAIT"]();
            d.currentOrientation = "PORTRAIT"
        }
        d.front.el.style.left = "";
        d.setPosition("PORTRAIT");
        d.container.el.style.top = (Sys.utils.toInt(d.container.el.style.top) + 70) * d.PIXEL_FACTOR + "rem";
        d.setHandlePostion()
    },
    onLandscape: function () {
        var d = this, b = d.model.readData("status"), c = Sys.utils.pollyFill("animation"),
            a = Sys.isDefined(d.animations) && d.model.readData("activated");
        if (Environment.getViewportOrientation() !== this.currentOrientation) {
            d.adaptToOrientation("LANDSCAPE");
            if (a) {
                d.container.el.style[c] = "none";
                if (b === "close") {
                    d.animations.LANDSCAPE.activate.run(d.container.el);
                    d.back.el.style.display = "none"
                } else {
                    d.childrenContainer.el.style.display = "block";
                    d.open()
                }
                d.animations.LANDSCAPE[b + "Front"].run(d.front.el);
                d.animations.LANDSCAPE[b + "Back"].run(d.back.el)
            }
            this.currentOrientation = "LANDSCAPE"
        }
    },
    adaptToOrientation: function (b) {
        var d = this, c = (b === "LANDSCAPE") ? "PORTRAIT" : "LANDSCAPE", a = d.model.readData("status");
        d.setStyle(b);
        d.resetPosition();
        Sys.iterate(d.updateOnOrientation, function (e, f) {
            d[e].replaceCSSClass(d[c + f], d[b + f])
        });
        d.handle.replaceCSSClass(d[c + "_HANDLE_CSS"][a], d[b + "_HANDLE_CSS"][a]);
        d.moveChildren(d[c + "_CHILD_CSS"], d[b + "_CHILD_CSS"], b);
        if (d.model.readData("activated") === true) {
            d.activate()
        } else {
            d.deactivate()
        }
    },
    setHandlePostion: function () {
        var b = this, a = b.handle.el.style, c = b.container.el.style;
        a.top = c.top;
        a.bottom = c.bottom;
        a.left = c.left;
        a.right = c.right
    },
    moveChildren: function (c, d, a) {
        var b = this;
        Sys.iterate(b.children, function (e) {
            b.children[e].replaceCSSClass(c, d);
            if (a === "LANDSCAPE") {
                b.childrenContainer.add(b.children[e])
            } else {
                if (e === "autoPlayButton") {
                    b.autoPlaySlide.add(b.children[e])
                } else {
                    if (e === "quickSpinButton") {
                        b.quickSpinSlide.add(b.children[e])
                    }
                }
            }
        })
    },
    resetPosition: function () {
        var e = this, f = e.container.el.style, a = e.handle.el.style, d = e.front.el.style,
            c = Sys.utils.pollyFill("animation"), g = ["top", "left", "bottom", "right", "width", "height", "opacity"],
            b;
        f[c] = "none";
        d[c] = "none";
        for (b = -1; ++b < g.length;) {
            f[g[b]] = "";
            a[g[b]] = ""
        }
    },
    setupDOMStructure: function () {
        var b = this, a = Environment.getViewportOrientation();
        b.container = new Sys.Element({
            tag: "div",
            cls: b.BASE_CSS + " " + b.LANDSCAPE_BG_URI,
            renderTo: b.RENDER_TARGET
        });
        b.handle = new Sys.Element({
            tag: "div",
            cls: b.HANDLE_CSS + " " + b[a + "_HANDLE_CSS"].close,
            renderTo: b.RENDER_TARGET
        });
        b.front = new Sys.Element({tag: "div", cls: b[a + "_FRONT_CSS"] + " " + b.SLIDER_BUTTON_URI});
        b.back = new Sys.Element({tag: "div", cls: b[a + "_BACK_CSS"] + " " + b.LANDSCAPE_BG_URI});
        b.icon = new Sys.Element({
            tag: "div",
            cls: b.ICON_BASE_CSS + " " + b[a + "_ICON_CSS"] + " " + b.ICON_CLOSE_CSS + " " + b.ICON_URI
        });
        b.childrenContainer = new Sys.Element({tag: "div", cls: b.BASE_CHILDREN_CSS + " " + b[a + "_CHILDREN_CSS"]});
        b.autoPlaySlide = new Sys.Element({
            tag: "div",
            cls: b.BASE_SLIDE_CSS + " " + b[a + "_AUTOPLAY_SLIDE_CSS"] + " " + b.AUTOPLAY_SLIDE_CLOSE + " " + b.PORTRAIT_BG_URI
        });
        b.quickSpinSlide = new Sys.Element({
            tag: "div",
            cls: b.BASE_SLIDE_CSS + " " + b[a + "_QUICKSPIN_SLIDE_CSS"] + " " + b.QUICKSPIN_SLIDE_CLOSE + " " + b.PORTRAIT_BG_URI
        });
        b.updateOnOrientation = {
            front: "_FRONT_CSS",
            back: "_BACK_CSS",
            icon: "_ICON_CSS",
            autoPlaySlide: "_AUTOPLAY_SLIDE_CSS",
            quickSpinSlide: "_QUICKSPIN_SLIDE_CSS",
            childrenContainer: "_CHILDREN_CSS"
        };
        b.container.add(b.front);
        b.front.add(b.icon);
        b.container.add(b.back);
        b.container.add(b.childrenContainer);
        b.container.add(b.autoPlaySlide);
        b.container.add(b.quickSpinSlide);
        b.positionMenu(b.model.readData("leftHandMode"))
    },
    setupAnimations: function () {
        var a = this;
        a.animations = {};
        a.setupLandscapeAnimations();
        a.setupPortraitAnimation();
        a.model.storeData("animationReady", true)
    },
    setupLandscapeAnimations: function () {
        var l = this, h = l.LANDSCAPE_CLOSEDSIZE, j = l.LANDSCAPE_FRONTSTARTPOS, d = l.LANDSCAPE_FRONTENDPOS,
            n = l.LANDSAPE_BACKSTARTPOS, k = l.LANDSCAPE_BACKENDPOS, g = l.LANDSCAPE_OPENSIZE,
            f = new Interface.utils.CSSAnimation({
                name: "interface-quickSettingsMenu_openFrontLandscape",
                frames: {"0%": {left: j}, "100%": {left: d}},
                duration: 50,
                delay: 4,
                fillMode: "both"
            }), o = new Interface.utils.CSSAnimation({
                name: "interface-quickSettingsMenu_closeFrontLandscape",
                frames: {"0%": {left: d}, "100%": {left: j}},
                duration: 124,
                delay: 126,
                fillMode: "both"
            }), c = new Interface.utils.CSSAnimation({
                name: "interface-quickSettingsMenu_openBackLandscape",
                frames: {"0%": {width: n}, "100%": {width: k}},
                duration: 5,
                delay: 45,
                fillMode: "both"
            }), e = new Interface.utils.CSSAnimation({
                name: "interface-quickSettingsMenu_closeBackLandscape",
                frames: {"0%": {width: k}, "100%": {width: n}},
                duration: 20,
                delay: 109,
                fillMode: "both"
            }), p = new Interface.utils.CSSAnimation({
                name: "interface-quickSettingsMenu_openAnimationLandscape",
                frames: {"0%": {width: h}, "100%": {width: g}},
                duration: 250,
                fillMode: "both"
            }), m = new Interface.utils.CSSAnimation({
                name: "interface-quickSettingsMenu_closeAnimationLandscape",
                frames: {"0%": {width: g}, "100%": {width: h}},
                duration: 250,
                fillMode: "both"
            }), i = new Interface.utils.CSSAnimation({
                name: "interface-quickSettingsMenu_activateLandscape",
                frames: {"0%": {width: "0.00rem"}, "100%": {width: h}},
                duration: 100,
                fillMode: "both"
            }), a = new Interface.utils.CSSAnimation({
                name: "interface-quickSettingsMenu_itemInLandscape",
                frames: {"0%": {opacity: 0, visibility: "visible"}, "100%": {opacity: 1}},
                duration: 150,
                delay: 200,
                fillMode: "both"
            }), b = new Interface.utils.CSSAnimation({
                name: "interface-quickSettingsMenu_itemOutLandscape",
                frames: {"0%": {opacity: 1}, "100%": {opacity: 0, visibility: "hidden"}},
                duration: 50,
                fillMode: "both"
            });
        l.animations.LANDSCAPE = {
            open: p,
            close: m,
            openChild: a,
            closeChild: b,
            activate: i,
            openFront: f,
            closeFront: o,
            openBack: c,
            closeBack: e
        }
    },
    setupPortraitAnimation: function () {
        var a = this, b = new Interface.utils.CSSAnimation({
            name: "interface-quickSettingsMenu_activatePortrait",
            frames: {"0%": {height: "0.00rem"}, "100%": {height: "1.60rem"}},
            duration: 200,
            fillMode: "both"
        });
        a.animations.PORTRAIT = {activate: b}
    },
    positionMenu: function (b) {
        var c = this, d = c.handle, a = c.container;
        if (b) {
            d.addCSSClass(c.HANDLE_LEFT_SIDE_CSS);
            a.addCSSClass(c.MENU_LEFT_SIDE_CSS)
        } else {
            d.removeCSSClass(c.HANDLE_LEFT_SIDE_CSS);
            a.removeCSSClass(c.MENU_LEFT_SIDE_CSS)
        }
    },
    removeSettingSlide: function (a) {
        this.container.remove(a)
    },
    removeAndDisableSetting: function (a) {
        var b = this;
        a += "Slide";
        if (b.hasOwnProperty(a)) {
            b.removeSettingSlide(b[a])
        }
    },
    addSettingSlide: function (a) {
        this.container.add(a)
    },
    addAndEnableSetting: function (a) {
        a += "Slide";
        if (this.hasOwnProperty(a)) {
            this.addSettingSlide(this[a])
        }
    }
};
Interface.QuickSettingsMenuBaseView = Sys.extend(Core.View, Interface.QuickSettingsMenuBaseView, "Interface.QuickSettingsMenuBaseView");
Sys.ns("Interface");
Interface.QuickSettingsMenuTabletView = {
    BASE_CSS: "interface-quickSettingsMenu_base",
    PORTRAIT_CSS: "interface-quickSettingsMenu_landscape",
    LANDSCAPE_CSS: "interface-quickSettingsMenu_landscape_tablet",
    LANDSCAPE_BG_URI: "interface-quickSettingsMenu_sliderBg_landscape_uri",
    PORTRAIT_BG_URI: "interface-quickSettingsMenu_sliderBg_landscape_uri",
    LANDSCAPE_FRONT_CSS: "interface-quickSettingsMenu_front_landscape_tablet",
    PORTRAIT_FRONT_CSS: "interface-quickSettingsMenu_front_landscape",
    LANDSCAPE_BACK_CSS: "interface-quickSettingsMenu_back_landscape",
    PORTRAIT_BACK_CSS: "interface-quickSettingsMenu_back_landscape",
    HANDLE_CSS: "interface-quickSettingsMenu_handle",
    SLIDER_BUTTON_URI: "interface-quickSettingsMenu_sliderButton_uri",
    ICON_BASE_CSS: "interface-quickSettingsMenu_icon_base",
    LANDSCAPE_ICON_CSS: "interface-quickSettingsMenu_icon_landscape",
    PORTRAIT_ICON_CSS: "interface-quickSettingsMenu_icon_landscape",
    ICON_CLOSE_CSS: "interface-quickSettingsMenu_icon_close",
    ICON_OPEN_CSS: "interface-quickSettingsMenu_icon_open",
    ICON_URI: "interface-quickSettingsMenu_icon_uri",
    BASE_SLIDE_CSS: "interface-quickSettingsMenu_portraitSlide",
    LANDSCAPE_AUTOPLAY_SLIDE_CSS: "interface-quickSettingsMenu_autoPlaySlide_landscape",
    PORTRAIT_AUTOPLAY_SLIDE_CSS: "interface-quickSettingsMenu_autoPlaySlide_landscape",
    AUTOPLAY_SLIDE_CLOSE: "interface-quickSettingsMenu_autoPlaySlide_close",
    AUTOPLAY_SLIDE_OPEN: "interface-quickSettingsMenu_autoPlaySlide_open",
    LANDSCAPE_QUICKSPIN_SLIDE_CSS: "interface-quickSettingsMenu_quickSpinSlide_landscape",
    PORTRAIT_QUICKSPIN_SLIDE_CSS: "interface-quickSettingsMenu_quickSpinSlide_landscape",
    QUICKSPIN_SLIDE_CLOSE: "interface-quickSettingsMenu_quickSpinSlide_close",
    QUICKSPIN_SLIDE_OPEN: "interface-quickSettingsMenu_quickSpinSlide_open",
    BASE_CHILDREN_CSS: "interface-quickSettingsMenu_children_base",
    LANDSCAPE_CHILDREN_CSS: "interface-quickSettingsMenu_children_landscape_base",
    PORTRAIT_CHILDREN_CSS: "interface-quickSettingsMenu_children_landscape_base",
    CHILD_CSS: "interface-quickSettingsMenu_child_base",
    PORTRAIT_CHILD_CSS: "interface-quickSettingsMenu_child_landscape",
    LANDSCAPE_CHILD_CSS: "interface-quickSettingsMenu_child_landscape",
    LANDSCAPE_HANDLE_CSS: {
        open: "interface-quickSettingsMenu_handle_open_landscape_tablet",
        close: "interface-quickSettingsMenu_handle_close_landscape"
    },
    PORTRAIT_HANDLE_CSS: {
        open: "interface-quickSettingsMenu_handle_open_landscape",
        close: "interface-quickSettingsMenu_handle_close_landscape"
    },
    LANDSCAPE_FRONTSTARTPOS: "-1.06rem",
    LANDSAPE_BACKSTARTPOS: "-0.40rem",
    moveChildren: function () {
    },
    append: function (c, b) {
        var a = this;
        a.childrenContainer.add(b)
    },
    updateStyle: function () {
        var a = this;
        a.resetPosition()
    },
    setHandlePostion: function () {
    },
    openPORTRAIT: function () {
        var c = this, a = c.model.readData("status"), b = c.getNewStatus(a);
        c.back.el.style.display = "block";
        c.childrenContainer.el.style.display = "block";
        Sys.iterate(c.children, function (d) {
            c.animations.PORTRAIT.openChild.run(c.children[d].el)
        });
        c.handle.replaceCSSClass(c.PORTRAIT_HANDLE_CSS[a], c.PORTRAIT_HANDLE_CSS[b]);
        c.animations.PORTRAIT.open.run(c.container.el);
        c.animations.PORTRAIT.openFront.run(c.front.el);
        c.animations.PORTRAIT.openBack.run(c.back.el)
    },
    closePORTRAIT: function (c) {
        var d = this, a = d.model.readData("status"), b = (a === "close") ? "open" : "close";
        Sys.iterate(d.children, function (e) {
            d.animations.PORTRAIT.closeChild.run(d.children[e].el)
        });
        d.handle.replaceCSSClass(d.PORTRAIT_HANDLE_CSS[a], d.PORTRAIT_HANDLE_CSS[b]);
        d.animations[c].close.run(d.container.el);
        d.animations[c].closeFront.run(d.front.el);
        d.animations[c].closeBack.run(d.back.el)
    },
    onPortrait: function () {
        var d = this, b = d.model.readData("status"), c = Sys.utils.pollyFill("animation"),
            a = Sys.isDefined(d.animations) && d.model.readData("activated");
        if (Environment.getViewportOrientation() !== this.currentOrientation) {
            d.adaptToOrientation("PORTRAIT");
            if (a) {
                d.container.el.style[c] = "none";
                if (b === "close") {
                    d.animations.PORTRAIT.activate.run(d.container.el);
                    d.back.el.style.display = "none"
                } else {
                    d.childrenContainer.el.style.display = "block";
                    d.open()
                }
                d.animations.PORTRAIT[b + "Front"].run(d.front.el);
                d.animations.PORTRAIT[b + "Back"].run(d.back.el)
            }
            d.currentOrientation = "PORTRAIT"
        }
    },
    setupPortraitAnimation: function () {
        var i = this, f = "0.00rem", h = "-0.64rem", d = new Interface.utils.CSSAnimation({
            name: "interface-quickSettingsMenu_openFrontPortrait",
            frames: {"0%": {left: h}, "100%": {left: "-0.24rem"}},
            duration: 50,
            delay: 4,
            fillMode: "both"
        }), k = new Interface.utils.CSSAnimation({
            name: "interface-quickSettingsMenu_closeFrontPortrait",
            frames: {"0%": {left: "-0.24rem"}, "100%": {left: h}},
            duration: 124,
            delay: 126,
            fillMode: "both"
        }), c = new Interface.utils.CSSAnimation({
            name: "interface-quickSettingsMenu_openBackPortrait",
            frames: {"0%": {width: "0.00rem"}, "100%": {width: "0.50rem"}},
            duration: 5,
            delay: 40,
            fillMode: "both"
        }), e = new Interface.utils.CSSAnimation({
            name: "interface-quickSettingsMenu_closeBackPortrait",
            frames: {"0%": {width: "0.50rem"}, "100%": {width: "0.00rem"}},
            duration: 20,
            delay: 111,
            fillMode: "both"
        }), l = new Interface.utils.CSSAnimation({
            name: "interface-quickSettingsMenu_openAnimationPortrait",
            frames: {"0%": {width: f}, "100%": {width: "2.70rem"}},
            duration: 250,
            fillMode: "both"
        }), j = new Interface.utils.CSSAnimation({
            name: "interface-quickSettingsMenu_closeAnimationPortrait",
            frames: {"0%": {width: "2.70rem"}, "100%": {width: f}},
            duration: 250,
            fillMode: "both"
        }), g = new Interface.utils.CSSAnimation({
            name: "interface-quickSettingsMenu_activatePortrait",
            frames: {"0%": {width: "0.00rem"}, "100%": {width: f}},
            duration: 100,
            fillMode: "both"
        }), a = new Interface.utils.CSSAnimation({
            name: "interface-quickSettingsMenu_itemInPortrait",
            frames: {"0%": {opacity: 0}, "100%": {opacity: 1}},
            duration: 100,
            delay: 125,
            fillMode: "both"
        }), b = new Interface.utils.CSSAnimation({
            name: "interface-quickSettingsMenu_itemOutLPortrait",
            frames: {"0%": {opacity: 1}, "100%": {opacity: 0}},
            duration: 50,
            fillMode: "both"
        });
        i.animations.PORTRAIT = {
            open: l,
            close: j,
            openChild: a,
            closeChild: b,
            activate: g,
            openFront: d,
            closeFront: k,
            openBack: c,
            closeBack: e
        }
    }
};
Interface.QuickSettingsMenuTabletView = Sys.extend(Interface.QuickSettingsMenuBaseView, Interface.QuickSettingsMenuTabletView, "Interface.QuickSettingsMenuTabletView");
Sys.ns("Operations");
Operations.Base = {
    constructor: function () {
        this.operation = "base"
    }, performAction: function (l, k) {
        var g = this, d = g.operation, b = l.prop.operations[d], j = g.getCurrentOperationStep(l, d), f = b[j],
            h = j + 1, c = b.length, i, a, e = 1;
        Animation.utils.increaseTimeBuffer(l, g.operation, k);
        a = l.prop.operations[d].timeBuffer;
        if (c > h) {
            i = b[h];
            if (a >= i.time) {
                g.handleCallback(f);
                g.handleEvents(f);
                g.restoreCallbackOnIterations(f);
                j = g.getNewKeyFrameIndex(l, i);
                f = b[j];
                h = j + 1;
                if (c > h) {
                    i = b[h]
                } else {
                    i = f;
                    e = 0
                }
            }
            g.handleCallback(f);
            g.handleEvents(f);
            g.calculate(l, b.timeBuffer, f, i);
            return e
        }
        return 0
    }, calculate: function (e, d, b, a) {
        var c = this;
        c.time = c.calculateTime(d, b, a);
        c.from = b.value;
        c.to = a.value
    }, updateProperties: function () {
    }, applyDefaultValuesToOperation: function () {
    }, handleCallback: function (a) {
        var b = a.callback;
        if (Sys.isDefined(b) && !a.callbackCompleted) {
            b.callbackFunction.apply(b.scope, b.args);
            a.callbackCompleted = true
        }
    }, handleEvents: function (c) {
        var b = c.fireEvent, a = Game.stage.view.animationManager.renderLoopEndEvents;
        if (Sys.isDefined(b) && !c.eventFired) {
            a.push(b);
            c.eventFired = true
        }
    }, restoreEventOnIterations: function (a) {
        var b = a.fireEvent;
        if (Sys.isDefined(b) && Sys.isDefined(b.iterations)) {
            if (!Sys.isDefined(b.remainingIterations)) {
                b.remainingIterations = b.iterations
            }
            b.remainingIterations--;
            if (b.remainingIterations > 0) {
                a.eventFired = false;
                a.callbackCompleted = false
            }
        }
    }, restoreCallbackOnIterations: function (a) {
        var b = a.callback;
        if (Sys.isDefined(b) && b.looping === true) {
            a.callbackCompleted = false
        }
    }, getCurrentOperationStep: function (c, b) {
        var a = c.prop.operationSteps;
        if (!a[b]) {
            a[b] = 0
        }
        return a[b]
    }, calculateTime: function (d, b, a) {
        var e = d - b.time, c = a.time - b.time;
        return c !== 0 ? e / c : 1
    }, getNewKeyFrameIndex: function (i, f) {
        var e = this, j = i.prop, a = f.goTo, b = Sys.isDefined(a) ? e.getIterations(f) : false, g = e.operation,
            c = j.operations[g], h = j.operationSteps[g], d;
        if (Sys.isDefined(a) && (b > 1)) {
            Animation.utils.setTimeBuffer(i, g, c[a].time);
            e.restoreEventOnIterations(c[a]);
            d = a;
            e.handleEvents(f)
        } else {
            d = h + 1
        }
        j.operationSteps[g] = d;
        return d
    }, getIterations: function (a) {
        if (Sys.isDefined(a.iterations)) {
            if (!Sys.isDefined(a.remainingIterations)) {
                a.remainingIterations = a.iterations
            }
            return --a.remainingIterations
        }
        return 2
    }, applyDefaultValuesToItem: function () {
    }
};
Operations.Base = Sys.extend(Sys.Observable, Operations.Base, "Operations.Base");
Sys.ns("Operations");
Operations.ColorBlend = {
    constructor: function () {
        Operations.ColorBlend.superclass.constructor.call(this);
        this.operation = "colorBlend"
    }, calculate: function (f, e, c, a) {
        var d = this, b = {r: 0, g: 0, b: 0};
        Operations.ColorBlend.superclass.calculate(f, e, c, a);
        Sys.iterate(b, function (g) {
            b[g] = Sys.utils.toInt(Animation.utils.getInterpolationValue(d.from[g], d.to[g], d.time))
        });
        f.prop.color = b
    }, updateProperties: function (b, a) {
        a.globalAlpha = b.prop.opacity;
        b.prop.reset = true
    }, applyDefaultValuesToItem: function (a) {
        if (!Sys.isDefined(a.prop.color)) {
            a.prop.color = {}
        }
    }, calculateColorSupport: function (b, a) {
        return {
            r: ((a.value.r - b.value.r) / 2) + b.value.r,
            g: ((a.value.g - b.value.g) / 2) + b.value.g,
            b: ((a.value.b - b.value.b) / 2) + b.value.b
        }
    }
};
Operations.ColorBlend = Sys.extend(Operations.Base, Operations.ColorBlend, "Operations.ColorBlend");
Sys.ns("Operations");
Operations.Fade = {
    constructor: function () {
        Operations.Fade.superclass.constructor.call(this);
        this.operation = "fade"
    }, calculate: function (g, f, b, a) {
        var e = this, d, c;
        Operations.Fade.superclass.calculate(g, f, b, a);
        if (Sys.isDefined(b.support)) {
            d = b.support;
            c = "bezier"
        }
        g.prop.ownOpacity = Animation.utils.getInterpolationValue(e.from, e.to, e.time, {support: d, type: c})
    }, applyDefaultValuesToItem: function (a) {
        if (!Sys.isNumber(a.prop.opacity)) {
            a.prop.opacity = 1
        }
    }
};
Operations.Fade = Sys.extend(Operations.Base, Operations.Fade, "Operations.Fade");
Sys.ns("Operations");
Operations.Orbit = {
    constructor: function () {
        Operations.Orbit.superclass.constructor.call(this);
        this.operation = "orbit"
    }, calculate: function (e, d, b, a) {
        var c = this;
        Operations.Orbit.superclass.calculate(e, d, b, a);
        e.prop.rotation = Animation.utils.getInterpolationValue(c.from, c.to, c.support, c.time)
    }, updateProperties: function (c, a) {
        var b = c.prop, d = b.rotation - 90;
        b.left = (Sys.Math.cos(d) * b.radius) + b.center.left - b.width / 2;
        b.top = (Sys.Math.sin(d) * b.radius) + b.center.top - b.height / 2
    }, applyDefaultValuesToItem: function (a) {
        var b = a.prop;
        if (!Sys.isNumber(b.rotation)) {
            b.rotation = 0
        }
        if (!Sys.isNumber(b.radius)) {
            b.radius = 0
        }
        if (!Sys.isDefined(b.center)) {
            b.center = {left: 0, top: 0}
        }
    }
};
Operations.Orbit = Sys.extend(Operations.Base, Operations.Orbit, "Operations.Orbit");
Sys.ns("Operations");
Operations.Path = {
    constructor: function (a) {
        Operations.Path.superclass.constructor.call(this);
        this.operation = "path"
    }, calculate: function (d, c, b, a) {
        Operations.Path.superclass.calculate(d, c, b, a);
        d.prop.path.push({left: d.prop.left, top: d.prop.top})
    }, updateProperties: function (c, a) {
        var h = c.prop, g = c.prop.path, f = g[0].top, e = g[0].left, b = g[g.length - 1].top, d = g[g.length - 1].left;
        h.width = Sys.utils.toInt(Math.abs(d - e) + h.lineHeight);
        h.height = Sys.utils.toInt(Math.abs(b - f) + h.lineWidth);
        h.left = Sys.utils.toInt(e - (h.lineHeight / 2));
        h.top = Sys.utils.toInt(b - (h.lineWidth / 2))
    }, applyDefaultValuesToItem: function (a) {
        var b = a.prop;
        if (!Sys.isNumber(b.lineHeight)) {
            b.lineHeight = 0
        }
        if (!Sys.isNumber(b.lineWidth)) {
            b.lineWidth = 0
        }
        if (!Sys.isDefined(b.path)) {
            b.path = []
        }
    }
};
Operations.Path = Sys.extend(Operations.Base, Operations.Path, "Operations.Path");
Sys.ns("Operations");
Operations.Rotate = {
    constructor: function () {
        Operations.Rotate.superclass.constructor.call(this);
        this.operation = "rotate"
    }, calculate: function (g, f, b, a) {
        var e = this, d, c;
        Operations.Rotate.superclass.calculate(g, f, b, a);
        if (Sys.isDefined(b.support)) {
            d = b.support;
            c = "bezier";
            if (Sys.isArray(d) && d.length === 2) {
                c = "cubic"
            }
        }
        g.prop.rotation = Animation.utils.getInterpolationValue(e.from, e.to, e.time, {support: d, type: c})
    }, applyDefaultValuesToItem: function (a) {
        if (!Sys.isNumber(a.prop.rotation)) {
            a.prop.rotation = 0
        }
    }
};
Operations.Rotate = Sys.extend(Operations.Base, Operations.Rotate, "Operations.Rotate");
Sys.ns("Operations");
Operations.Scale = {
    constructor: function () {
        Operations.Scale.superclass.constructor.call(this);
        this.operation = "scale"
    }, calculate: function (l, c, a, f) {
        var k = this, g = a.value.scaleX, e = a.value.scaleY, i = f.value.scaleX, h = f.value.scaleY, d, b, j;
        k.time = k.calculateTime(c, a, f);
        if (Sys.isDefined(a.value.width)) {
            g = a.value.width / l.prop.width;
            i = f.value.width / l.prop.width
        }
        if (Sys.isDefined(a.value.height)) {
            e = a.value.height / l.prop.height;
            h = f.value.height / l.prop.height
        }
        if (Sys.isDefined(a.support)) {
            d = a.support.scaleX;
            b = a.support.scaleY;
            j = "bezier"
        }
        l.prop.scaleX = Animation.utils.getInterpolationValue(g, i, k.time, {support: d, type: j});
        l.prop.scaleY = Animation.utils.getInterpolationValue(e, h, k.time, {support: b, type: j})
    }
};
Operations.Scale = Sys.extend(Operations.Base, Operations.Scale, "Operations.Scale");
Sys.ns("Operations");
Operations.Translate = {
    constructor: function () {
        Operations.Translate.superclass.constructor.call(this);
        this.operation = "translate"
    }, calculate: function (l, d, a, e) {
        var h = this, k = Animation.utils, j = a.value.left, m = a.value.top, f = e.value.left, i = e.value.top, c, b,
            g;
        h.time = h.calculateTime(d, a, e);
        if (Sys.isDefined(a.support)) {
            c = a.support.left;
            b = a.support.top;
            g = "bezier";
            if (Sys.isArray(c) && c.length === 2) {
                g = "cubic"
            }
        }
        l.prop.left = k.getInterpolationValue(j, f, h.time, {support: c, type: g});
        l.prop.top = k.getInterpolationValue(m, i, h.time, {support: b, type: g})
    }, applyDefaultValuesToOperation: function (c) {
        var f = c.prop, b = f.operations[this.operation], e = b.length, d, a;
        for (a = -1; ++a < e;) {
            d = b[a];
            if (!Sys.isNumber(d.value.left)) {
                d.value.left = f.left
            }
            if (!Sys.isNumber(d.value.top)) {
                d.value.top = f.top
            }
        }
    }
};
Operations.Translate = Sys.extend(Operations.Base, Operations.Translate, "Operations.Translate");
Sys.ns("Operations");
Operations.DisplayArea = {
    constructor: function (a) {
        Operations.DisplayArea.superclass.constructor.call(this);
        this.operation = "displayArea"
    }, calculate: function (l, c, b, d) {
        var f = this, k = Animation.utils,
            i = {sx: b.value.startX, sy: b.value.startY, sWidth: b.value.width, sHeight: b.value.height},
            j = {sx: d.value.startX, sy: d.value.startY, sWidth: d.value.width, sHeight: d.value.height}, a = l.prop,
            h = Environment.getVirtualToWindowScale(3), e, g;
        Operations.DisplayArea.superclass.calculate(l, c, b, d);
        a.SX = Math.round(k.toNthDecimalPlace(k.getInterpolationValue(i.sx, j.sx, f.time), 3) * h);
        a.SY = Math.round(k.toNthDecimalPlace(k.getInterpolationValue(i.sy, j.sy, f.time), 3) * h);
        g = k.toNthDecimalPlace(k.getInterpolationValue(i.sWidth, j.sWidth, f.time), 3);
        e = k.toNthDecimalPlace(k.getInterpolationValue(i.sHeight, j.sHeight, f.time), 3);
        a.SWidth = Math.round(g * h);
        a.SHeight = Math.round(e * h);
        a.width = g;
        a.height = e
    }
};
Operations.DisplayArea = Sys.extend(Operations.Base, Operations.DisplayArea, "Operations.DisplayArea");
Sys.ns("Operations");
Operations.Sprite = {
    constructor: function (a) {
        Operations.Sprite.superclass.constructor.call(this, a);
        this.operation = "sprite"
    }, calculate: function (e, d, b, a) {
        var c = this, g = e.prop, f;
        Operations.Sprite.superclass.calculate(e, d, b, a);
        f = Math.round(Animation.utils.getInterpolationValue(c.from, c.to, c.time));
        g.SX = g.spriteArray[f] * g.frameWidth;
        e.prop.SY = 0;
        if (g.SX >= g.totalSpriteWidth) {
            g.SY = Math.floor(g.SX / g.totalSpriteWidth) * g.frameHeight;
            g.SX = g.SX % g.totalSpriteWidth
        }
        g.SWidth = g.frameWidth;
        g.SHeight = g.frameHeight;
        c.fireEventOnFrame(f, b)
    }, applyDefaultValuesToItem: function (a) {
        var b = a.prop;
        if (Sys.isString(b.spriteSequence)) {
            b.spriteArray = Resources.readData("sprites")[b.spriteSequence]
        }
    }, fireEventOnFrame: function (c, b) {
        var a = Game.stage.view.animationManager.renderLoopEndEvents;
        Sys.each(b.events, function (d) {
            if (c >= d.onFrame && !d.fired) {
                a.push(d);
                d.fired = true
            }
        })
    }
};
Operations.Sprite = Sys.extend(Operations.Base, Operations.Sprite, "Operations.Sprite");
Sys.ns("Operations");
Operations.TranslateCurve = {
    constructor: function () {
        Operations.TranslateCurve.superclass.constructor.call(this);
        this.operation = "translateCurve"
    }, calculate: function (j, b, a, d) {
        var g = a.value.point || a.value, f = d.value.point || d.value, i = a.value.support || a.value,
            h = d.value.support || d.value, c = this.calculateTime(b, a, d), e;
        j.curve = {p1: g, p2: f, s1: i, s2: h};
        if (c > 1) {
            c = 1
        } else {
            if (c < 0) {
                c = 0
            }
        }
        e = Animation.utils.calculateCurveLocation(j.curve, c);
        j.prop.left = Animation.utils.toNthDecimalPlace(e.left, 10);
        j.prop.top = Animation.utils.toNthDecimalPlace(e.top, 10)
    }
};
Operations.TranslateCurve = Sys.extend(Operations.Base, Operations.TranslateCurve, "Operations.TranslateCurve");
Sys.ns("Operations");
Operations.Value = {
    constructor: function (a) {
        Operations.Value.superclass.constructor.call(this);
        this.operation = "value"
    }, calculate: function (i, c, a, e) {
        var f = this, h, g, b, d = 3;
        Operations.Value.superclass.calculate(i, c, a, e);
        if (Sys.isDefined(a.support)) {
            h = a.support;
            g = "bezier"
        }
        if (Sys.isDefined(a.numDecimals)) {
            d = a.numDecimals
        }
        b = Animation.utils.getInterpolationValue(f.from, f.to, f.time, {support: h, type: g});
        i.prop.value = Animation.utils.toNthDecimalPlace(b, d)
    }
};
Operations.Value = Sys.extend(Operations.Base, Operations.Value, "Operations.Value");
Sys.ns("Animation.Operations");
Animation.Operations = {};
(function () {
    Sys.iterate(Operations, function (c, b) {
        var a = new b();
        Animation.Operations[a.operation] = a
    })
}());
Sys.ns("Animation");
Animation.CanvasAnimationManager = {
    constructor: function (a) {
        var b = this;
        Animation.CanvasAnimationManager.superclass.constructor.call(b);
        b.canvasList = {};
        b.activeCanvas = b.addCanvas(a);
        b.currentTime = 0;
        b.timeFromStart = 0;
        b.paused = false;
        b.currentStepTime = 0;
        b.setupImages(a.images, "notify:animationManager.allImagesLoaded");
        b.setupSprites(a.sprites);
        b.setupScenes(a.scenes);
        b.renderBuffer = [];
        b.activeRenderBuffer = [];
        b.renderLoopEndEvents = [];
        b.isRunning = false;
        b.selectRenderFunction()
    }, start: function (b) {
        var a = this;
        a.currentScene = b;
        a.isRunning = true;
        a.currentTime = 0;
        a.lastTimeStepOccured = Date.now();
        a.paused = false;
        a.requestNextAnimationStep()
    }, switchScenes: function (a) {
        this.currentScene = a
    }, clearScene: function (a) {
        if (Sys.isDefined(a)) {
            this.scenes[a].lists = []
        }
    }, addToRenderLoop: function (c, b) {
        var a = Sys.isDefined(b) ? b : this.currentScene;
        if (!this.isInScene(c, a)) {
            this.scenes[a].listsToAdd.push(c)
        } else {
            c.prop.running = true
        }
    }, isInScene: function (c, d) {
        var b = Sys.isDefined(d) ? d : this.currentScene, a = this.scenes[b];
        return (a.lists.contains(c) || a.listsToAdd.contains(c) || a.nonActiveLists.contains(c))
    }, isRunningRendering: function () {
        return this.isRunning
    }, removeList: function (g, h) {
        var e = this, c = Sys.isDefined(h) ? h : e.currentScene, d = e.scenes[c], a = d.lists.indexOf(g),
            b = d.listsToAdd.indexOf(g), f = d.nonActiveLists.indexOf(g);
        if (a > -1) {
            d.lists[a].prop.running = false
        } else {
            if (f > -1) {
                d.nonActiveLists[f].prop.running = false
            } else {
                if (b > -1) {
                    d.listsToAdd.splice(b, 1)
                }
            }
        }
    }, restore: function (c) {
        var a, b = this;
        if (Sys.isDefined(c.canvas)) {
            a = b.canvasList[c.canvas]
        } else {
            a = b.canvasList[b.defaultCanvas]
        }
        if (c.prop.reset) {
            a.restore();
            a.globalAlpha = 1
        }
        if (Sys.isDefined(c.prop.globalCompositeOperation)) {
            a.globalCompositeOperation = "source-over"
        }
        a.fillStyle = "";
        a.strokeStyle = "";
        a.shadowColor = "";
        a.strokeStyle = "";
        a.shadowBlur = ""
    }, pauseAnimation: function () {
        this.paused = true;
        clearTimeout(this.renderTimeout)
    }, continueAnimation: function () {
        this.paused = false;
        this.run()
    }, getSpriteSequence: function (a) {
        return this.sprites[a]
    }, addImages: function (a) {
        Sys.apply(this.images, a)
    }, shouldRenderNextFrame: function () {
        return (!this.paused)
    }, run: function () {
        var a = this;
        a.renderLoopEndEvents.length = 0;
        a.calculate();
        a.render(a.renderBuffer, a.activeCanvas);
        if (a.renderLoopEndEvents.length > 0) {
            a.fireLoopEndEvents()
        }
        if (a.shouldRenderNextFrame()) {
            a.lastTimeStepOccured = a.updateTime();
            a.requestNextAnimationStep()
        } else {
            a.isRunning = false
        }
    }, fireLoopEndEvents: function () {
        var c = this, b = c.renderLoopEndEvents.length, a, d;
        for (a = -1; ++a < b;) {
            d = c.renderLoopEndEvents[a];
            d.scope.fireEvent(d.event, d.argument)
        }
    }, calculate: function () {
        var b = this, a = this.scenes[this.currentScene];
        b.clear();
        if (Sys.isDefined(a)) {
            b.renderBuffer.push.apply(b.renderBuffer, a.run({timeStep: b.currentStepTime, time: b.currentTime}));
            b.renderBuffer.sort(function (d, c) {
                return (d.prop.depth - c.prop.depth)
            })
        } else {
        }
    }, render: function (f, d) {
        var p = this, c = d.ctx, q = f.length, k, b, n, o, e, g, l, h, a;
        for (l = 0; l < q; l++) {
            k = f[l];
            o = k.prop;
            e = o.matrix;
            if (Sys.isDefined(o.operations)) {
                b = Object.keys(o.operations);
                n = b.length;
                h = 0;
                while (h < n) {
                    Animation.Operations[b[h]].updateProperties(k, c);
                    ++h
                }
            }
            if (o.opacity > 0) {
                if (Sys.isDefined(o.globalCompositeOperation)) {
                    c.globalCompositeOperation = o.globalCompositeOperation
                } else {
                    c.globalCompositeOperation = "source-over"
                }
                if (o.opacity !== 1) {
                    c.globalAlpha = o.opacity;
                    o.contextProperties.globalAlpha = true
                }
                c.setTransform(e[0], e[1], e[2], e[3], e[4], e[5]);
                if (Sys.isDefined(o.func)) {
                    g = o.tempMatrix;
                    g.set(e);
                    Animation.utils.multiplyMatrix(g, [1, 0, 0, 1, o.pivot.x - o.left, o.pivot.y - o.top], e);
                    c.setTransform(e[0], e[1], e[2], e[3], e[4], e[5]);
                    o.func(c, d.config, p.images, k);
                    c.setTransform(g[0], g[1], g[2], g[3], g[4], g[5])
                }
                if (Sys.isDefined(o.executeBefore)) {
                    o.executeBefore(c, d.config, p.images, k)
                }
                if (Sys.isDefined(o.image)) {
                    a = Sys.isDefined(p.images[o.image]) ? p.images[o.image] : o.image;
                    if (o.reelSym) {
                        c.drawImage(a, 0, o.clipY, a.width, o.clipHeight, o.xPos, o.yPos, o.width, o.renderHeight)
                    } else {
                        if (Sys.isDefined(o.SX) && Sys.isDefined(o.SY) && Sys.isDefined(o.SWidth) && Sys.isDefined(o.SHeight)) {
                            c.drawImage(a, o.SX, o.SY, o.SWidth, o.SHeight, o.pivot.x, o.pivot.y, o.width, o.height)
                        } else {
                            c.drawImage(a, o.pivot.x, o.pivot.y, o.width, o.height)
                        }
                    }
                }
                if (Sys.isDefined(o.afterDraw)) {
                    g = o.tempMatrix;
                    g.set(e);
                    Animation.utils.multiplyMatrix(g, [1, 0, 0, 1, o.pivot.x - o.left, o.pivot.y - o.top], e);
                    c.setTransform(e[0], e[1], e[2], e[3], e[4], e[5]);
                    o.afterDraw(c, d.config, p.images, k);
                    c.setTransform(g[0], g[1], g[2], g[3], g[4], g[5])
                }
                if (Sys.isDefined(o.executeAfter)) {
                    o.executeAfter(c, d.config, p.images, k)
                }
            }
            p.restoreContextProperties(c, o.contextProperties)
        }
    }, clear: function () {
        this.renderBuffer.length = 0;
        this.clearCanvas(this.activeCanvas)
    }, clearCanvas: function (a) {
        a.ctx.setTransform(1, 0, 0, 1, 0, 0);
        a.ctx.clearRect(0, 0, a.config.width, a.config.height)
    }, restoreContextProperties: function (b, a) {
        if (!Sys.isDefined(a)) {
            return
        }
        if (a.globalCompositeOperation) {
            b.globalCompositeOperation = "source-over";
            a.globalCompositeOperation = false
        }
        if (a.globalAlpha) {
            b.globalAlpha = 1;
            a.globalAlpha = false
        }
    }, requestNextAnimationStep: function () {
        var a = this;
        a.animationFunction.call(window, function () {
            a.run()
        })
    }, updateTime: function () {
        var b = this, a = Date.now(), c = a - b.lastTimeStepOccured;
        if (c > 250) {
            c = 1000 / 60
        }
        b.currentStepTime = c | 0;
        b.currentTime += b.currentStepTime;
        return a
    }, updateActiveRenderContextSize: function (b) {
        var c = this.activeCanvas.config, a = this.activeCanvas.canvas;
        c.width = b.width;
        c.height = b.height;
        a.width = c.width;
        a.height = c.height;
        this.scenes[this.currentScene].updateScaleValue()
    }, setContextProperty: function (a) {
        Sys.iterate(a, function (b) {
            this.ctx[b] = a[b]
        })
    }, getItemPos: function (a) {
        return {left: a.prop.left, top: a.prop.top}
    }, selectRenderFunction: function () {
        var a = this;
        this.animationFunction = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (b) {
            clearTimeout(a.renderTimeout);
            a.renderTimeout = setTimeout(b, Math.round(1000 / 60))
        }
    }, addCanvas: function (b) {
        var c = this, d = {}, a;
        a = c.applyDefaultCanvasConf(b);
        d.canvas = document.createElement("canvas");
        d.canvas.id = a.id;
        d.canvas.width = a.width;
        d.canvas.height = a.height;
        d.canvas.style.position = a.position;
        d.canvas.style.top = a.top;
        d.canvas.style.left = a.left;
        d.canvas.style.zIndex = a.zIndex;
        d.canvas.style.transform = a.transform;
        d.canvas.imageRendering = a.imageRendering;
        a.parent.appendChild(d.canvas);
        d.ctx = d.canvas.getContext("2d");
        d.ctx.textBaseline = a.ctxTextBaseline;
        d.ctx.textAlign = a.ctxTextAlign;
        d.config = a;
        c.canvasList[a.id] = d;
        return d
    }, applyDefaultCanvasConf: function (a) {
        var b = {};
        if (Sys.isDefined(a)) {
            Sys.apply(b, a)
        }
        Sys.applyPropertiesIf(b, {
            parent: document.getElementById("uicard"),
            id: "canvasAnimationManager",
            width: 1280,
            height: 720,
            position: "absolute",
            top: 0,
            left: 0,
            zIndex: "220",
            transform: Platform.isDesktopDevice ? "translateX(0)" : undefined,
            ctxTextBaseline: "middle",
            ctxTextAlign: "center"
        });
        return b
    }, setupScenes: function (b) {
        var c = Sys.isDefined(b) ? b : [], a = {};
        c.push("base");
        Sys.each(c, function (d) {
            a[d] = new Animation.CanvasAnimationScene({})
        });
        this.scenes = a;
        this.scenes.base.play();
        this.currentScene = "base"
    }, setupImages: function (c, g) {
        var e = this, f = Sys.isDefined(c.files) ? c.files : c, a = Resources.readData("animationImages") || {},
            b = Resources.readData("spriteConfigurations") || {}, d = {};
        e.imageReadyEvent = g;
        e.imagesRemaining = [];
        e.remainingImages = 0;
        Sys.iterate(f, function (h, j) {
            var i = new Image();
            i.onload = function () {
                e.remainingImages--;
                e.imagesLoaded()
            };
            i.src = j;
            a[h] = i;
            e.imagesRemaining.push(i);
            e.remainingImages++
        });
        e.images = a;
        Resources.storeData("animationImages", a);
        if (Sys.isDefined(c.spriteConfigurations)) {
            Sys.iterate(c.spriteConfigurations, function (h, i) {
                if (i.sequence) {
                    d[h] = {sequence: i.sequence}
                }
                b[h] = i
            })
        }
        e.spriteConfigurations = b;
        Resources.storeData("spriteConfigurations", b);
        e.setupSprites(d)
    }, imagesLoaded: function () {
        if (this.remainingImages < 1) {
            this.canImagesBeUsed()
        }
    }, canImagesBeUsed: function () {
        var d = this, b = d.imagesRemaining, a = b.length, c;
        for (c = -1; ++c < a;) {
            if (b[c].width > 0 && b[c].height > 0) {
                b.splice(c, 1);
                --c;
                --a
            }
        }
        clearTimeout(d.tryToDrawImagesTimeout);
        if (b.length > 1) {
            d.tryToDrawImagesTimeout = setTimeout(function () {
                d.canImagesBeUsed()
            }, 50)
        } else {
            d.fireEvent(d.imageReadyEvent);
            d.fireEvent("notify:animationManager.animationLoopInitialized");
            if (Platform.hasWebGLContext) {
                Animation.PixiAdapter.performOverrides()
            }
        }
    }, setupSprites: function (e) {
        var g = this, a, b, f, k, h, j, d, c;
        g.sprites = Resources.readData("sprites") || {};
        if (Sys.isDefined(e)) {
            Sys.iterate(e, function (l, i) {
                b = [];
                Sys.each(i.sequence, function (n, m) {
                    f = new RegExp("\\*").test(n);
                    a = new RegExp("-").test(n);
                    if (a) {
                        k = n.split("-");
                        j = Sys.utils.toInt(k[0]);
                        d = Sys.utils.toInt(k[1]);
                        if (j < d) {
                            d++;
                            for (c = j; c < d; c++) {
                                b.push(c)
                            }
                        } else {
                            d--;
                            for (c = j; c > d; c--) {
                                b.push(c)
                            }
                        }
                    } else {
                        if (f) {
                            k = n.split("*");
                            j = 0;
                            d = Sys.utils.toInt(k[1]);
                            h = Sys.utils.toInt(k[0]);
                            for (c = j; c < d; c++) {
                                b.push(h)
                            }
                        } else {
                            b.push(Sys.utils.toInt(n))
                        }
                    }
                });
                g.sprites[l] = b
            })
        }
        Resources.storeData("sprites", g.sprites)
    }
};
Animation.CanvasAnimationManager = Sys.extend(Sys.Observable, Animation.CanvasAnimationManager, "Animation.CanvasAnimationManager");
Sys.ns("Animation");
Animation.CanvasAnimationList = {
    constructor: function (a) {
        var c = this, b;
        Animation.CanvasAnimationList.superclass.constructor.apply(c, arguments);
        a = a || {};
        c.items = [];
        c.id = a.id;
        c.endDurationItems = [];
        b = {
            top: 0,
            left: 0,
            width: 0,
            height: 0,
            delay: 0,
            depth: 0,
            hasEnded: false,
            running: true,
            operations: {},
            operationSteps: {},
            operationEnded: {},
            operationsRunning: true,
            parentMatrix: new Float32Array([1, 0, 0, 1, 0, 0]),
            matrix: new Float32Array([1, 0, 0, 1, 0, 0]),
            tempMatrix: new Float32Array([1, 0, 0, 1, 0, 0]),
            opacity: 1,
            ownOpacity: 1
        };
        a = Sys.apply(b, a);
        a = Animation.utils.parseItemConfig(a);
        c.prop = Sys.apply(c.prop, a);
        c.prop.localTime = 0;
        c.endEvent = a.endEvent || undefined
    }, run: function (l, f) {
        var k = this, a = k.prop, j = [], g = k.items.length, m = Animation.utils, h, c, b, e, d;
        a.localTime += l.timeStep;
        if (a.localTime >= a.delay) {
            a.parentMatrix.set(f.matrix);
            m.performAction(k, l.timeStep);
            m.updateMatrix(a);
            a.opacity = a.ownOpacity * f.opacity;
            if (a.pivot.x !== 0 || a.pivot.y !== 0) {
                k.adjustForPivot(a)
            }
            h = false;
            for (e = -1; ++e < g;) {
                c = k.items[e];
                if (c.prop.running) {
                    b = c.run(l, {matrix: a.matrix, opacity: a.opacity});
                    if (b === true) {
                        j.push(c);
                        h = true
                    } else {
                        if (b !== false && Sys.isArray(b)) {
                            j = j.concat(b);
                            h = true
                        }
                    }
                }
            }
            a.running = a.running === false ? false : h;
            if (!a.running && k.endEvent && !k.endFrameFired) {
                k.endFrameFired = true;
                if (Sys.isObj(k.endEvent)) {
                    d = Game.stage.view.animationManager.renderLoopEndEvents;
                    d.push(k.endEvent)
                }
            }
        }
        return j
    }, adjustForPivot: function (a) {
        a.parentMatrix.set([1, 0, 0, 1, a.pivot.x, a.pivot.y]);
        a.tempMatrix.set(a.matrix);
        Animation.utils.multiplyMatrix(a.tempMatrix, a.parentMatrix, a.matrix)
    }, clearAnimationList: function () {
        var c = this, b = c.items.length, a;
        for (a = -1; ++a < b;) {
            c.items[a].finished()
        }
    }, restore: function (b) {
        var a = this, c = a.prop;
        c.running = true;
        c.hasEnded = false;
        c.localTime = 0;
        a.endFrameFired = false;
        Animation.utils.restoreOperations(c);
        if (Sys.isDefined(b)) {
            if (Sys.isObj(b)) {
                b.restore()
            } else {
                if (Sys.isArray(b)) {
                    a.handleItems("restore", b)
                }
            }
        } else {
            a.handleItems("restore")
        }
    }, add: function (a) {
        Animation.utils.insertInOrder(a, this.items)
    }, removeItems: function () {
        this.items = []
    }, setProperty: function (e, d) {
        var a = this.items, c = a.length, b;
        for (b = -1; ++b < c;) {
            a[b].prop[e] = d
        }
    }, addItems: function (a) {
        var c = a.length, b;
        for (b = -1; ++b < c;) {
            this.add(a[b])
        }
    }, isRunning: function () {
        return this.prop.running
    }, stopItemInList: function (c) {
        var b = this, a = Sys.utils.containsObject(c, b.items);
        if (a.found) {
            b.items[a.index].finished()
        } else {
        }
    }, play: function (a) {
        if (!this.prop.running) {
            this.restore(a)
        } else {
            if (Sys.isDefined(a)) {
                if (Sys.isObj(a)) {
                    a.play()
                } else {
                    if (Sys.isArray(a)) {
                        this.handleItems("play", a)
                    }
                }
            } else {
                this.handleItems("play")
            }
        }
    }, pause: function () {
        this.handleItems("pause")
    }, stop: function () {
        this.handleItems("stop")
    }, restoreList: function () {
        var a = this.prop;
        a.running = true;
        a.hasEnded = false;
        a.localTime = 0;
        this.endFrameFired = false
    }, handleItems: function (e, d) {
        var a = (Sys.isDefined(d)) ? d : this.items, c = a.length, b;
        for (b = -1; ++b < c;) {
            a[b][e]()
        }
    }
};
Animation.List = Animation.CanvasAnimationList = Sys.extend(Sys.Observable, Animation.CanvasAnimationList, "Animation.CanvasAnimationList");
Sys.ns("Animation");
Animation.MaskedAnimationList = {
    constructor: function (a) {
        Animation.MaskedAnimationList.superclass.constructor.apply(this, arguments);
        this.setupMaskingCanvas()
    }, run: function (l, f) {
        var k = this, a = k.prop, j = [], g = k.items.length, m = Animation.utils, h, c, b, e, d;
        a.localTime += l.timeStep;
        if (a.localTime >= a.delay) {
            a.parentMatrix.set(f.matrix);
            m.performAction(k, l.timeStep);
            m.updateMatrix(a);
            a.opacity = a.ownOpacity * f.opacity;
            if (a.pivot.x !== 0 || a.pivot.y !== 0) {
                k.adjustForPivot(a)
            }
            h = false;
            for (e = -1; ++e < g;) {
                c = k.items[e];
                if (c.prop.running) {
                    b = c.run(l, {matrix: [1, 0, 0, 1, 0, 0], opacity: a.opacity});
                    if (b === true) {
                        j.push(c);
                        h = true
                    } else {
                        if (b !== false && Sys.isArray(b)) {
                            j = j.concat(b);
                            h = true
                        }
                    }
                }
            }
            j = k.maskList(j);
            a.running = a.running === false ? false : h;
            if (!a.running && k.endEvent && !k.endFrameFired) {
                k.endFrameFired = true;
                if (Sys.isObj(k.endEvent)) {
                    d = Game.stage.view.animationManager.renderLoopEndEvents;
                    d.push(k.endEvent)
                }
            }
        }
        return j
    }, maskList: function (d) {
        var e = this, a = e.prop, g = Resources.readData("animationImages"), f = d.length, k = e.maskContext, j, b, h,
            c;
        k.setTransform(1, 0, 0, 1, 0, 0);
        k.clearRect(0, 0, a.maskWidth, a.maskHeight);
        a.width = a.maskWidth;
        a.height = a.maskHeight;
        for (c = -1; ++c < f;) {
            j = d[c].prop;
            h = j.matrix;
            b = g[j.image];
            if (j.opacity !== 1) {
                k.globalAlpha = j.opacity
            }
            k.setTransform(h[0], h[1], h[2], h[3], h[4] - a.left, h[5] - a.top);
            if (Sys.isDefined(j.operations.sprite)) {
                k.drawImage(b, j.SX, j.SY, j.SWidth, j.SHeight, j.pivot.x, j.pivot.y, j.width, j.height)
            } else {
                k.drawImage(b, j.pivot.x, j.pivot.y, j.width, j.height)
            }
            if (j.opacity !== 1) {
                k.globalAlpha = 1
            }
        }
        a.image = e.maskCanvas;
        return [e]
    }, setupMaskingCanvas: function () {
        var c = this, b = document.createElement("canvas"), a = b.getContext("2d");
        b.width = c.prop.maskWidth;
        b.height = c.prop.maskHeight;
        c.maskCanvas = b;
        c.maskContext = a
    }
};
Animation.MaskedAnimationList = Sys.extend(Animation.CanvasAnimationList, Animation.MaskedAnimationList, "Animation.MaskedAnimationList");
Sys.ns("Animation");
Animation.CanvasAnimationItem = {
    constructor: function (a) {
        var c = this, b = {
            top: 0,
            left: 0,
            width: 0,
            height: 0,
            depth: 0,
            delay: 0,
            reset: false,
            paused: false,
            fullScreen: false,
            operations: {},
            operationSteps: {},
            operationEnded: {},
            customProps: {},
            running: true,
            skip: false,
            operationsRunning: true,
            opacity: 1,
            ownOpacity: 1,
            parentMatrix: new Float32Array([1, 0, 0, 1, 0, 0]),
            matrix: new Float32Array([1, 0, 0, 1, 0, 0]),
            tempMatrix: new Float32Array([1, 0, 0, 1, 0, 0]),
            contextProperties: {globalCompositeOperation: false, globalAlpha: false}
        };
        c.setSizeDefaultProperties(a);
        a = Sys.apply(b, a);
        a = Animation.utils.parseItemConfig(a);
        c.prop = Sys.apply(c.prop, a);
        c.prop.localTime = 0;
        c.setOperationDefaultProperties();
        c._defaultProp = Sys.copyObject(c.prop);
        c._stateOperations = {"default": c.prop.operations}
    }, run: function (d, c) {
        var b = this, e = b.prop, a = Animation.utils;
        if (!e.paused) {
            e.localTime += d.timeStep
        }
        e.reset = false;
        if (e.localTime >= e.delay) {
            e.parentMatrix.set(c.matrix);
            a.performAction(b, d.timeStep);
            a.updateMatrix(e);
            e.opacity = e.ownOpacity * c.opacity;
            return !e.skip
        }
        return false
    }, play: function (a) {
        if (Sys.isDefined(a)) {
            this.reset();
            this.prop.operations = this._stateOperations[a]
        }
        if (!this.isRunning()) {
            this.restore()
        }
        this.prop.paused = false
    }, pause: function () {
        this.prop.paused = true
    }, stop: function () {
        this.prop.running = false
    }, setImage: function (a) {
        if (typeof a !== "string") {
            throw new Error("Value must be a string.")
        }
        this.prop.image = a
    }, setWidth: function (a) {
        if (typeof a !== "number") {
            throw new Error("Value must be a number.")
        }
        this.prop.width = a
    }, setHeight: function (a) {
        if (typeof a !== "number") {
            throw new Error("Value must be a number.")
        }
        this.prop.height = a
    }, setLeft: function (a) {
        if (typeof a !== "number") {
            throw new Error("Value must be a number.")
        }
        this.prop.left = a
    }, setTop: function (a) {
        if (typeof a !== "number") {
            throw new Error("Value must be a number.")
        }
        this.prop.top = a
    }, updatePivot: function () {
        this.prop.pivot.x = -this.prop.width / 2;
        this.prop.pivot.y = -this.prop.height / 2
    }, restore: function () {
        var a = this.prop;
        a.localTime = 0;
        a.timeBuffer = 0;
        a.skip = false;
        a.running = true;
        Animation.utils.restoreOperations(a)
    }, reset: function () {
        this.prop = Sys.copyObject(this._defaultProp)
    }, setOperationState: function (b, a) {
        if (typeof b !== "string") {
            throw new Error("State value must be a string.")
        } else {
            if (typeof a !== "object") {
                throw new Error("Operations value must be an object.")
            }
        }
        this._stateOperations[b] = a
    }, isRunning: function () {
        return this.prop.running
    }, updateOperation: function (a, b) {
        var c = this, d = {};
        Animation.Operations[a].applyDefaultValuesToItem(c);
        d[a] = b;
        d = Animation.utils.parseItemConfig(d);
        c.prop.operations[a] = d.operations[a];
        Animation.Operations[a].applyDefaultValuesToOperation(c)
    }, finished: function () {
        this.prop.running = false
    }, setOperationDefaultProperties: function () {
        var a = Object.keys(this.prop.operations), c = a.length, b = 0;
        while (b < c) {
            Animation.Operations[a[b]].applyDefaultValuesToItem(this);
            Animation.Operations[a[b]].applyDefaultValuesToOperation(this);
            ++b
        }
    }, setSizeDefaultProperties: function (a) {
        var b = ["width", "height"];
        b.forEach(function (c) {
            if (!Sys.isDefined(a[c]) && !a.fullScreen) {
                if (a.image instanceof HTMLCanvasElement) {
                    a[c] = a.image[c]
                } else {
                    if (Sys.isString(a.image)) {
                        a[c] = Resources.readData("animationImages")[a.image][c]
                    }
                }
            }
        })
    }
};
Animation.Item = Animation.CanvasAnimationItem = Sys.extend(Sys.Observable, Animation.CanvasAnimationItem, "Animation.CanvasAnimationItem");
(function () {
    var a = Object.keys(Animation.Operations), e = a.length, d = 0, c, b = function (f) {
        return function (g) {
            this.updateOperation(f, g)
        }
    };
    while (d < e) {
        c = a[d];
        Animation.CanvasAnimationItem.prototype[c] = b(c);
        ++d
    }
}());
Sys.ns("Animation");
Animation.utils = {
    calculateCurveLocation: function (d, a) {
        var c = Sys.utils.toInt(Math.pow(1 - a, 3) * d.p1.left + 3 * a * Math.pow(1 - a, 2) * d.s1.left + 3 * Math.pow(a, 2) * (1 - a) * d.s2.left + Math.pow(a, 3) * d.p2.left),
            b = Sys.utils.toInt(Math.pow(1 - a, 3) * d.p1.top + 3 * a * Math.pow(1 - a, 2) * d.s1.top + 3 * Math.pow(a, 2) * (1 - a) * d.s2.top + Math.pow(a, 3) * d.p2.top);
        return {left: c, top: b}
    }, getPositions: function (a) {
        var c = a.length,
            d = {p1: {left: 0, top: 0}, p2: {left: 0, top: 0}, s1: {left: 0, top: 0}, s2: {left: 0, top: 0}}, b, e;
        d.p1.left = a[0].left;
        d.p1.top = a[0].top;
        d.p2.left = a[(c - 1)].left;
        d.p2.top = a[(c - 1)].top;
        e = 142 / 160;
        b = Math.abs((a[0].left * e + a[(c - 1)].left * e) / (a[0].top + a[(c - 1)].top));
        d.s1.left = a[0].left;
        d.s1.top = a[1].top;
        d.s2.left = a[(c - 1)].left;
        d.s2.top = a[1].top;
        if (b === 1) {
            d.s1.left = a[1].left;
            d.s2.left = a[1].left
        }
        if (c > 3) {
            d.s1.top = Math.min(a[1].top, a[2].top);
            d.s2.top = Math.min(a[1].top, a[2].top)
        }
        return d
    }, degToRad: function (b, c) {
        var a = Sys.isDefined(c) ? c : 8;
        return Animation.utils.toNthDecimalPlace(b * 0.017453292519943295, a)
    }, radToDeg: function (b, c) {
        var a = Sys.isDefined(c) ? c : 8;
        return Animation.utils.toNthDecimalPlace(b * (360 / (Math.PI * 2)), a)
    }, setOperationValues: function (a) {
        Sys.iterate(a.operations, function (c, b) {
            Sys.each(b.frames, function (e) {
                var d;
                if (Sys.isObj(e.frame)) {
                    d = e.frame.name;
                    if (Sys.isDefined(e.frame.offset)) {
                        e.frame = a[d] + e.frame.offset
                    } else {
                        e.frame = a[d]
                    }
                }
                if (Sys.isObj(e.value)) {
                    d = e.value.name;
                    if (Sys.isDefined(d)) {
                        e.value = a[d]
                    }
                }
            })
        })
    }, copyProperties: function (b, a) {
        var c = Sys.clone(Object.getPrototypeOf(b));
        Sys.apply(b, c);
        Sys.apply(b, a)
    }, insertInOrder: function (e, f) {
        var b = 0, g, c, d = f.length, a = e.prop.depth;
        if (d > 0) {
            if (a < f[0].prop.depth) {
                f.unshift(e);
                return
            } else {
                if (a >= f[d - 1].prop.depth) {
                    f.push(e);
                    return
                }
            }
            for (b; b < d; b++) {
                g = f[b].prop.depth;
                if (d > b + 1) {
                    c = f[b + 1].prop.depth
                } else {
                    c = g
                }
                if (a > g && a < c) {
                    f.splice(b + 1, 0, e);
                    return
                } else {
                    if (a < g) {
                        f.splice(b, 0, e);
                        return
                    }
                }
            }
        } else {
            f.push(e)
        }
    }, toNthDecimalPlace: function (a, d) {
        var c = Sys.isDefined(d) ? d : 1, b = Math.pow(10, c);
        return Math.round(a * b) / b
    }, getInterpolationValue: function (g, h, b, m) {
        var l, j, e, c, a, d, f = "linear";
        if (Sys.isDefined(m) && Sys.isDefined(m.support)) {
            l = m.support;
            if (Sys.isArray(l)) {
                f = l.length === 2 ? "cubic" : "nNumber"
            } else {
                f = Sys.isDefined(m.type) ? m.type : "bezier"
            }
        }
        if (b > 1) {
            b = 1
        } else {
            if (b < 0) {
                b = 0
            }
        }
        switch (f) {
            case"linear":
                j = g + b * (h - g);
                break;
            case"bezier":
                j = ((1 - b) * (1 - b)) * g + 2 * b * (1 - b) * l + (b * b) * h;
                break;
            case"cubic":
                j = Math.pow(1 - b, 3) * g + 3 * b * Math.pow(1 - b, 2) * l[0] + 3 * Math.pow(b, 2) * (1 - b) * l[1] + Math.pow(b, 3) * h;
                break;
            case"nNumber":
                a = l.length;
                d = [];
                d.push(g);
                for (e = 0; e < a; e++) {
                    d.push(l[e])
                }
                d.push(h);
                a = d.length;
                for (c = 1; c < a; c++) {
                    for (e = 0; e < (a - c); e++) {
                        d[e] = (1 - b) * d[e] + b * d[e + 1]
                    }
                }
                j = d[0];
                break;
            case"none":
                j = b === 1 ? h : g;
                break;
            default:
        }
        return j
    }, getCubiqInterpolationValue: function (e, d, b, a, c) {
        if (c > 1) {
            c = 1
        } else {
            if (c < 0) {
                c = 0
            }
        }
        return Math.pow(1 - c, 3) * e + 3 * c * Math.pow(1 - c, 2) * b + 3 * Math.pow(c, 2) * (1 - c) * a + Math.pow(c, 3) * d
    }, randomBetween: function (b, a) {
        return b + (a - b) * Math.random()
    }, parseItemConfig: function (d) {
        var b = {operations: {}}, a = Object.keys(Animation.Operations), q = Object.keys(d), m = q.length, k = 0,
            o = function (j, i) {
                return (j.time - i.time)
            }, n, f, l, c, p, h, g, e;
        while (k < m) {
            p = q[k];
            if (a.contains(p)) {
                f = d[p];
                n = Object.keys(f);
                l = n.length;
                g = 0;
                b.operations[p] = [];
                while (g < l) {
                    c = f[n[g]];
                    h = {time: Sys.utils.toInt(n[g])};
                    if (Sys.isObj(c) && Sys.isDefined(c.value)) {
                        h = Sys.apply(h, c)
                    } else {
                        h.value = c
                    }
                    b.operations[p].push(h);
                    ++g
                }
                b.operations[p].sort(o)
            } else {
                b[p] = d[p]
            }
            ++k
        }
        if (!Sys.isDefined(d.pivot)) {
            b.pivot = {x: 0, y: 0};
            if (Sys.isDefined(b.width)) {
                b.pivot.x = -b.width / 2
            }
            if (Sys.isDefined(b.height)) {
                b.pivot.y = -b.height / 2
            }
        }
        if (d.fullScreen) {
            e = Environment.getStageResolution();
            b.width = e.width;
            b.height = e.height
        }
        return b
    }, makeMotionBlur: function (m, s, u) {
        var t = document.createElement("canvas"), q = t.getContext("2d"), j = 0, c = 0,
            o = Sys.isDefined(m.naturalWidth) ? m.naturalWidth : m.width,
            k = Sys.isDefined(m.naturalHeight) ? m.naturalHeight : m.height, n, p, l, w, b, i, g, r, v, f, e, h, a, d;
        if (s === "horizontal") {
            j = (u * 2)
        } else {
            c = (u * 2)
        }
        t.width = o + j;
        t.height = k + c;
        q.drawImage(m, 0, 0, o, k);
        n = q.getImageData(0, 0, o + j, k + c);
        p = u;
        l = 1 / p;
        r = q.createImageData(n);
        o = n.width;
        k = n.height;
        v = n.data;
        f = r.data;
        for (i = -1; ++i < o;) {
            for (g = -1; ++g < k;) {
                e = 0;
                h = 0;
                a = 0;
                d = 0;
                for (w = -1; ++w < p;) {
                    b = (~~(g - p / 2) + w + k) % k;
                    e += v[((o * b) + i) * 4];
                    h += v[((o * b) + i) * 4 + 1];
                    a += v[((o * b) + i) * 4 + 2];
                    d += v[((o * b) + i) * 4 + 3]
                }
                f[((o * g) + i) * 4] = e * l;
                f[((o * g) + i) * 4 + 1] = h * l;
                f[((o * g) + i) * 4 + 2] = a * l;
                f[((o * g) + i) * 4 + 3] = d * l
            }
        }
        q.putImageData(r, 0, 0);
        return t
    }, multiplyMatrix: function (d, c, e) {
        e[0] = d[0] * c[0] + d[2] * c[1];
        e[2] = d[0] * c[2] + d[2] * c[3];
        e[4] = d[0] * c[4] + d[2] * c[5] + Number(d[4]);
        e[1] = d[1] * c[0] + d[3] * c[1];
        e[3] = d[1] * c[2] + d[3] * c[3];
        e[5] = d[1] * c[4] + d[3] * c[5] + Number(d[5])
    }, updateMatrix: function (h) {
        var e = this, a = h.matrix, d = h.tempMatrix, f, g, b;
        if (Sys.isDefined(h.changeMatrix)) {
            e.multiplyMatrix(h.parentMatrix, h.changeMatrix, a);
            return
        }
        a.set([1, 0, 0, 1, h.left - h.pivot.x, h.top - h.pivot.y]);
        d.set(a);
        if (Sys.isDefined(h.rotation)) {
            f = h.rotation * 0.017453292519943295;
            g = Math.cos(f);
            b = Math.sin(f);
            e.multiplyMatrix(d, [g, b, -b, g, 0, 0], a)
        }
        if (Sys.isDefined(h.scaleX) && Sys.isDefined(h.scaleY)) {
            d.set(a);
            e.multiplyMatrix(d, [h.scaleX, 0, 0, h.scaleY, 0, 0], a)
        }
        d.set(a);
        e.multiplyMatrix(h.parentMatrix, d, a)
    }, performAction: function (d, a) {
        var g = d.prop, f = 0, c = Object.keys(g.operations), e = c.length, b = 0;
        if (e === 0) {
            return
        }
        while (b < e) {
            f += Animation.Operations[c[b]].performAction(d, a);
            ++b
        }
        if (f === 0 || (Sys.isDefined(g.duration) && g.localTime >= g.delay + g.duration)) {
            d.prop.running = false
        }
    }, addOperation: function (c, a) {
        var b = this.parseItemConfig(a).operations;
        c.prop.operations = Sys.apply(c.prop.operations, b);
        Sys.iterate(b, function (d) {
            if (Sys.isDefined(c.prop.operationSteps[d])) {
                c.prop.operationSteps[d] = 0
            }
            Animation.Operations[d].applyDefaultValuesToItem(c);
            Animation.Operations[d].applyDefaultValuesToOperation(c)
        })
    }, removeOperation: function (b, a) {
        if (Sys.isArray(a)) {
            Sys.each(a, function (c) {
                if (Sys.isDefined(b.prop.operations[c])) {
                    delete b.prop.operations[c];
                    delete b.prop.operationSteps[c]
                }
            })
        } else {
            if (Sys.isDefined(b.prop.operations[a])) {
                delete b.prop.operations[a];
                delete b.prop.operationSteps[a]
            }
        }
    }, restoreOperations: function (b) {
        var a = Object.keys(b.operations), f = a.length, g = 0, l, m, h, c, n, e, d;
        while (g < f) {
            n = a[g];
            h = b.operations[n];
            l = h.length;
            b.operationSteps[n] = 0;
            h.timeBuffer = 0;
            for (e = -1; ++e < l;) {
                c = h[e];
                if (Sys.isDefined(c.fireEvent)) {
                    c.eventFired = false;
                    if (Sys.isDefined(c.iterations)) {
                        c.remainingIterations = c.iterations
                    }
                }
                if (Sys.isDefined(c.events)) {
                    m = c.events.length;
                    for (d = -1; ++d < m;) {
                        c.events[d].fired = false
                    }
                }
                if (Sys.isDefined(c.callback)) {
                    c.callbackCompleted = false
                }
            }
            ++g
        }
        if (f === 0) {
            if (Object.keys(b.operationSteps).length > 0) {
                b.operationSteps = {}
            }
        }
    }, increaseTimeBuffer: function (b, a, c) {
        var d = b.prop;
        if (!Sys.isDefined(d.operations[a].timeBuffer)) {
            d.operations[a].timeBuffer = 0
        }
        if (!d.paused) {
            d.operations[a].timeBuffer += c
        }
    }, setTimeBuffer: function (b, a, c) {
        var d = b.prop;
        if (!Sys.isDefined(d.operations[a].timeBuffer)) {
            d.operations[a].timeBuffer = 0
        }
        d.operations[a].timeBuffer = c
    }, getInMemoryCanvas: function (d, a) {
        var c = document.createElement("canvas"), b = c.getContext("2d");
        c.width = d;
        c.height = a;
        return {canvas: c, ctx: b}
    }, isAnimationItem: function (a) {
        if (!Sys.isDefined(Animation.CanvasAnimationItem)) {
            return false
        }
        return a instanceof Animation.CanvasAnimationItem
    }
};
Sys.ns("Animation");
Animation.Emitter = {
    constructor: function (b) {
        var d = this, e = document.createElement("canvas"), a = e.getContext("2d"), c = {
            top: 0,
            left: 0,
            width: 1280,
            height: 720,
            depth: 0,
            delay: 0,
            reset: false,
            paused: false,
            fullScreen: false,
            image: e,
            operations: {},
            operationSteps: {},
            operationEnded: {},
            customProps: {},
            running: true,
            skip: false,
            operationsRunning: true,
            opacity: 1,
            ownOpacity: 1,
            parentMatrix: new Float32Array([1, 0, 0, 1, 0, 0]),
            matrix: new Float32Array([1, 0, 0, 1, 0, 0]),
            tempMatrix: new Float32Array([1, 0, 0, 1, 0, 0]),
            contextProperties: {globalCompositeOperation: false, globalAlpha: false},
            emitterProps: {
                maximumParticles: 1000,
                numParticles: 50,
                delayInterval: 4000,
                duration: 3000,
                durationOffset: 1000,
                constantFlow: false,
                deleteOutsideScreen: true,
                fadeIn: false,
                fadeInTime: 500,
                fadeOut: false,
                fadeOutTime: 1000,
                orginPosX: 640,
                orginPosY: 733,
                emitterArea: false,
                orginMaxPosX: 1280,
                orginMaxPosY: 753,
                targetPosX: 640,
                targetPosY: 867,
                targetArea: false,
                targetMaxPosX: 1280,
                targetMaxPosY: 733,
                restrictedFromOrginX: false,
                restrictedFromOrginY: false,
                acceptableOffsetX: 400,
                acceptableOffsetY: 13,
                timeMaxToTarget: 2000,
                timeMinToTarget: 1000,
                usingGravity: false,
                gravity: 2,
                minStartVel: -93,
                maxStartVel: -200,
                maxVel: 200,
                particleImage: "mintLeaf",
                particleWidth: 90,
                particleHeight: 90,
                differInSize: false,
                sizeDifferFactorLow: 0.5,
                sizeDifferFactorHigh: 1.5,
                numberOfSizeDifferences: 3,
                turning: false,
                imageAngles: 18,
                minTurnSpeed: 1000,
                maxTurnSpeed: 3000,
                animating: true,
                animatingBothWays: true,
                animationTurning: true,
                particleFrameRate: 20,
                particleFrameRateVaried: true,
                particleMaxFrameRate: 50,
                imageFrames: 30,
                imageFramesForRotation: 0,
                totalSpriteWidth: 2700,
                orginSize: 1,
                targetSize: 1,
                bounceBox: false,
                bounceBoxDrawn: false,
                bounceBoxLeft: 1000,
                bounceBoxRight: 1040,
                bounceBoxTop: 507,
                bounceBoxBottom: 600,
                bounceBoxGravity: 2,
                bounceBoxStartVel: -20,
                movingEmitter: false
            }
        };
        d.flowOn = true;
        d.emitterCanvas = e;
        d.emitterCanvas.width = 1280;
        d.emitterCanvas.height = 720;
        d.emitterContext = a;
        Sys.iterate(b, function (f, g) {
            if (Sys.isObj(g)) {
                Sys.iterate(b[f], function (i, h) {
                    c[f][i] = b[f][i]
                })
            } else {
                c[f] = b[f]
            }
        });
        b = c;
        b = Animation.utils.parseItemConfig(b);
        d.prop = Sys.apply(d.prop, b);
        d.prop.localTime = 0;
        d.setOperationDefaultProperties();
        d.setUpEmitter()
    }, setUpEmitter: function () {
        var c = this, b = Game.stage.view.animationManager.images, a = b[c.prop.emitterProps.particleImage];
        if (c.prop.emitterProps.turning && !c.prop.emitterProps.animating) {
            c.particleImages = c.createImagesRotated(a)
        } else {
            if (c.prop.emitterProps.animating && !c.prop.emitterProps.turning) {
                c.particleImages = c.createSpriteSheetImages(a)
            }
        }
        c.particles = c.createParticles();
        if (!c.prop.emitterProps.constantFlow) {
            c.restoreExplodingParticles()
        }
        if (c.prop.emitterProps.bounceBoxDrawn) {
            c.bounceBoxDrawn = true
        }
    }, createImagesRotated: function (e) {
        var f = this, d, b = 0, h, g = [], a = f.prop.emitterProps.particleWidth,
            j = f.prop.emitterProps.particleHeight, c, k;
        for (d = -1; ++d < f.prop.emitterProps.imageAngles;) {
            c = document.createElement("canvas");
            k = c.getContext("2d");
            c.width = a;
            c.height = j;
            h = f.radiansFromDegrees(b);
            k.translate(a / 2, j / 2);
            k.rotate(h);
            k.drawImage(e, -(a / 2), -(j / 2), a, j);
            k.rotate(-h);
            k.translate(-(a / 2), -(j / 2));
            g.push(c);
            b += (360 / f.prop.emitterProps.imageAngles)
        }
        return g
    }, createSpriteSheetImages: function (f) {
        var h = this, d, j = [], e, a = h.prop.emitterProps.particleWidth, l = h.prop.emitterProps.particleHeight,
            b = 0, k, c, m, g;
        if (h.prop.emitterProps.imageFramesForRotation > 0) {
            h.usedFrames = h.prop.emitterProps.imageFramesForRotation
        } else {
            h.usedFrames = h.prop.emitterProps.imageFrames
        }
        for (d = 0; d < h.usedFrames; d++) {
            c = document.createElement("canvas");
            m = c.getContext("2d");
            g = d % h.prop.emitterProps.imageFrames;
            c.width = a;
            c.height = l;
            e = h.getFramePosition(g, a, l, h.prop.emitterProps.totalSpriteWidth);
            if (h.prop.emitterProps.animationTurning) {
                k = h.radiansFromDegrees(b);
                m.translate(a / 2, l / 2);
                m.rotate(k);
                m.drawImage(f, e.x, e.y, a, l, -(a / 2), -(l / 2), a, l);
                m.rotate(-k);
                m.translate(-(a / 2), -(l / 2));
                b += (360 / h.usedFrames)
            } else {
                m.drawImage(f, e.x, e.y, a, l, 0, 0, a, l)
            }
            j.push(c)
        }
        return j
    }, createParticles: function () {
        var c = this, b, a = [];
        if (c.prop.emitterProps.differInSize) {
            c.sizeDifferences = c.createDifferences(c.prop.emitterProps.sizeDifferFactorLow, c.prop.emitterProps.sizeDifferFactorHigh, c.prop.emitterProps.numberOfSizeDifferences)
        }
        for (b = -1; ++b < c.prop.emitterProps.maximumParticles;) {
            a.push(c.updateParticle({}))
        }
        return a
    }, turnOffBounceBox: function () {
        var b = this, a;
        for (a = -1; ++a < b.prop.emitterProps.numParticles;) {
            b.particles[a].bounceBox = false
        }
        b.prop.emitterProps.bounceBox = false;
        b.bounceBoxDrawn = false
    }, turnOnBounceBox: function () {
        var b = this, a;
        for (a = -1; ++a < b.prop.emitterProps.numParticles;) {
            b.particles[a].bounceBox = true
        }
        b.prop.emitterProps.bounceBox = true;
        if (b.prop.emitterProps.bounceBoxDrawn) {
            b.bounceBoxDrawn = true
        }
    }, createDifferences: function (a, e, b) {
        var f = [], d = (e - a) / b, c;
        for (c = 0; c < b; c++) {
            f.push((a + (d * c)))
        }
        return f
    }, restoreExplodingParticles: function () {
        var b = this, a;
        for (a = -1; ++a < b.prop.emitterProps.numParticles;) {
            b.updateParticle(b.particles[a]);
            b.particles[a].explosionTriggered = true
        }
        b.emittStarted = false;
        b.flowOn = true
    }, restoreParticles: function () {
        var b = this, a;
        for (a = -1; ++a < b.prop.emitterProps.numParticles;) {
            b.updateParticle(b.particles[a])
        }
    }, randomBetweenNotRounded: function (b, a) {
        return (Math.random() * (a - b)) + b
    }, randomBetween: function (b, a) {
        return Math.floor(Math.random() * (a - b)) + b
    }, radiansFromDegrees: function (a) {
        return (Math.PI / 180) * a
    }, getFramePosition: function (f, d, e, c) {
        var b = f * d, a = {};
        if (b >= c) {
            a.x = b % c;
            a.y = (Math.floor(b / c) * e)
        } else {
            a.x = b;
            a.y = 0
        }
        return a
    }, updateParticle: function (c) {
        var a = this, b = a.prop;
        if (!a.prop.emitterProps.emitterArea) {
            c.x = b.emitterProps.orginPosX;
            c.y = b.emitterProps.orginPosY
        } else {
            c.x = a.randomBetween(b.emitterProps.orginPosX, b.emitterProps.orginMaxPosX);
            c.y = a.randomBetween(b.emitterProps.orginPosY, b.emitterProps.orginMaxPosY)
        }
        if (!a.prop.emitterProps.targetArea) {
            c.endPosX = a.randomBetweenNotRounded(b.emitterProps.targetPosX - b.emitterProps.acceptableOffsetX, b.emitterProps.targetPosX + b.emitterProps.acceptableOffsetX);
            c.endPosY = a.randomBetweenNotRounded(b.emitterProps.targetPosY - b.emitterProps.acceptableOffsetY, b.emitterProps.targetPosY + b.emitterProps.acceptableOffsetY)
        } else {
            if (a.prop.emitterProps.restrictedFromOrginX) {
                c.endPosX = a.randomBetweenNotRounded(c.x - b.emitterProps.acceptableOffsetX, c.x + b.emitterProps.acceptableOffsetX)
            } else {
                c.endPosX = a.randomBetweenNotRounded(b.emitterProps.targetPosX - b.emitterProps.acceptableOffsetX, b.emitterProps.targetMaxPosX + b.emitterProps.acceptableOffsetX)
            }
            c.endPosY = a.randomBetweenNotRounded(b.emitterProps.targetPosY - b.emitterProps.acceptableOffsetY, b.emitterProps.targetMaxPosY + b.emitterProps.acceptableOffsetY)
        }
        c.width = b.emitterProps.particleWidth;
        c.height = b.emitterProps.particleHeight;
        c.timeToTarget = a.randomBetweenNotRounded(b.emitterProps.timeMinToTarget, b.emitterProps.timeMaxToTarget);
        if (!b.emitterProps.animating && b.emitterProps.turning) {
            c.image = a.randomBetween(0, b.emitterProps.imageAngles)
        } else {
            if (b.emitterProps.animating && b.emitterProps.animatingBothWays) {
                c.image = a.randomBetween(0, a.usedFrames - 1)
            } else {
                c.image = 0
            }
        }
        c.delay = a.randomBetween(0, b.emitterProps.delayInterval);
        c.timer = 0;
        c.emitted = false;
        c.alpha = (b.emitterProps.fadeIn) ? 0 : 1;
        c.fadingIn = b.emitterProps.fadeIn;
        c.fadeOut = b.emitterProps.fadeOut;
        c.fadingOut = false;
        c.fadeInTime = b.emitterProps.fadeInTime;
        c.fadeOutTime = b.emitterProps.fadeOutTime;
        c.deleteOutsideScreen = b.emitterProps.deleteOutsideScreen;
        c.explosionTriggered = false;
        c.goingLeft = (c.x >= c.endPosX);
        c.falling = (c.y < c.endPosY);
        c.durationLimit = a.randomBetween(b.emitterProps.duration - b.emitterProps.durationOffset, b.emitterProps.duration + b.emitterProps.durationOffset);
        c.duration = 0;
        c.gravityOn = b.emitterProps.usingGravity;
        if (c.gravityOn) {
            c.curVel = a.randomBetweenNotRounded(b.emitterProps.minStartVel, b.emitterProps.maxStartVel)
        } else {
            if (c.falling) {
                c.secondSpeedY = ((c.endPosY - c.y) / (c.timeToTarget / 1000));
                if (c.secondSpeedY === 0) {
                    c.secondSpeedY = 0.1
                }
            } else {
                c.secondSpeedY = ((c.y - c.endPosY) / (c.timeToTarget / 1000));
                if (c.secondSpeedY === 0) {
                    c.secondSpeedY = -0.1
                }
            }
        }
        if (!c.goingLeft) {
            c.secondSpeedX = ((c.endPosX - c.x) / (c.timeToTarget / 1000));
            if (c.secondSpeedX === 0) {
                c.secondSpeedX = 0.1
            }
        } else {
            c.secondSpeedX = ((c.x - c.endPosX) / (c.timeToTarget / 1000));
            if (c.secondSpeedX === 0) {
                c.secondSpeedX = -0.1
            }
        }
        if (b.emitterProps.bounceBox) {
            c.bounceBox = true;
            c.bounceBoxLeft = b.emitterProps.bounceBoxLeft;
            c.bounceBoxRight = b.emitterProps.bounceBoxRight;
            c.bounceBoxTop = b.emitterProps.bounceBoxTop;
            c.bounceBoxBottom = b.emitterProps.bounceBoxBottom;
            c.bounced = false;
            c.bounceBoxStartVel = b.emitterProps.bounceBoxStartVel;
            if (!c.gravityOn) {
                b.emitterProps.gravity = b.emitterProps.bounceBoxGravity
            }
        }
        c.drawn = 0;
        if (b.emitterProps.turning) {
            c.turning = true;
            c.turnSpeed = a.randomBetween(b.emitterProps.minTurnSpeed, b.emitterProps.maxTurnSpeed);
            c.nextRotationAt = c.turnSpeed / b.emitterProps.imageAngles;
            if (a.turnLeft) {
                c.turnLeft = true;
                a.turnLeft = false
            } else {
                c.turnLeft = false;
                a.turnLeft = true
            }
        } else {
            c.turning = false
        }
        if (b.emitterProps.animating) {
            c.animating = true;
            if (b.emitterProps.particleFrameRateVaried) {
                c.frameRate = a.randomBetween(b.emitterProps.particleFrameRate, b.emitterProps.particleMaxFrameRate)
            } else {
                c.frameRate = b.emitterProps.particleFrameRate
            }
            if (b.emitterProps.animatingBothWays) {
                if (a.animateLeft) {
                    c.animateLeft = true;
                    a.animateLeft = false
                } else {
                    c.animateLeft = false;
                    a.animateLeft = true
                }
            }
        } else {
            c.animating = false
        }
        if (b.emitterProps.differInSize) {
            c.sizeFactor = a.sizeDifferences[a.randomBetween(0, a.sizeDifferences.length)]
        } else {
            c.sizeFactor = 1
        }
        return c
    }, run: function (f, e) {
        var d = this, h, g, b, c, a = false;
        Animation.Emitter.superclass.run.apply(this, arguments);
        if (!d.emittStarted) {
            d.emittTime = Date.now();
            d.emittStarted = true
        }
        h = Date.now() - d.emittTime;
        d.emitterContext.clearRect(0, 0, d.prop.width, d.prop.height);
        for (b = -1; ++b < d.prop.emitterProps.numParticles;) {
            g = d.particles[b];
            if (d.flowOn && ((!g.emitted && d.prop.emitterProps.constantFlow) || (!d.prop.emitterProps.constantFlow && g.explosionTriggered))) {
                g.timer += h;
                if (g.delay > g.timer) {
                    continue
                }
                if (d.prop.emitterProps.movingEmitter) {
                    if (!d.prop.emitterProps.emitterArea) {
                        g.x = d.prop.emitterProps.orginPosX;
                        g.y = d.prop.emitterProps.orginPosY
                    } else {
                        g.x = d.randomBetween(d.prop.emitterProps.orginPosX, d.prop.emitterProps.orginMaxPosX);
                        g.y = d.randomBetween(d.prop.emitterProps.orginPosY, d.prop.emitterProps.orginMaxPosY)
                    }
                    if (!d.prop.emitterProps.targetArea) {
                        g.endPosX = d.randomBetweenNotRounded(d.prop.emitterProps.targetPosX - d.prop.emitterProps.acceptableOffsetX, d.prop.emitterProps.targetPosX + d.prop.emitterProps.acceptableOffsetX);
                        g.endPosY = d.randomBetweenNotRounded(d.prop.emitterProps.targetPosY - d.prop.emitterProps.acceptableOffsetY, d.prop.emitterProps.targetPosY + d.prop.emitterProps.acceptableOffsetY)
                    } else {
                        if (d.prop.emitterProps.restrictedFromOrginX) {
                            g.endPosX = d.randomBetweenNotRounded(g.x - d.prop.emitterProps.acceptableOffsetX, g.x + d.prop.emitterProps.acceptableOffsetX)
                        } else {
                            g.endPosX = d.randomBetweenNotRounded(d.prop.emitterProps.targetPosX - d.prop.emitterProps.acceptableOffsetX, d.prop.emitterProps.targetMaxPosX + d.prop.emitterProps.acceptableOffsetX)
                        }
                        g.endPosY = d.randomBetweenNotRounded(d.prop.emitterProps.targetPosY - d.prop.emitterProps.acceptableOffsetY, d.prop.emitterProps.targetMaxPosY + d.prop.emitterProps.acceptableOffsetY)
                    }
                }
                g.emitted = true
            }
            if (g.emitted) {
                a = true;
                g.duration += h;
                c = h * 0.001;
                if (g.fadingIn) {
                    g.alpha += h / g.fadeInTime;
                    if (g.alpha >= 1) {
                        g.alpha = 1;
                        g.fadingIn = false
                    }
                }
                if (g.duration > g.durationLimit) {
                    if (g.fadeOut) {
                        g.fadingOut = true
                    } else {
                        d.updateParticle(g);
                        continue
                    }
                }
                if (g.fadingOut) {
                    g.alpha -= h / g.fadeOutTime;
                    if (g.alpha <= 0) {
                        d.updateParticle(g);
                        continue
                    }
                }
                if ((!g.goingLeft && g.x < g.endPosX) || (!g.goingLeft && g.x >= g.endPosX)) {
                    g.x += g.secondSpeedX * c
                } else {
                    if ((g.goingLeft && g.x > g.endPosX) || (g.goingLeft && g.x <= g.endPosX)) {
                        g.x -= g.secondSpeedX * c
                    }
                }
                if (g.bounceBox && !g.bounced) {
                    if (!g.goingLeft && g.x > g.bounceBoxLeft && g.x < g.bounceBoxRight && g.y > g.bounceBoxTop && g.y < g.bounceBoxBottom) {
                        g.bounced = true;
                        g.gravityOn = true;
                        g.curVel = g.bounceBoxStartVel;
                        g.goingLeft = true
                    } else {
                        if (g.goingLeft && g.x < g.bounceBoxLeft && g.x > g.bounceBoxRight && g.y > g.bounceBoxTop && g.y < g.bounceBoxBottom) {
                            g.bounced = true;
                            g.gravityOn = true;
                            g.curVel = g.bounceBoxStartVel;
                            g.goingLeft = false
                        }
                    }
                }
                if (!g.gravityOn) {
                    if (g.falling) {
                        g.y += g.secondSpeedY * c;
                        if (g.y >= d.emitterCanvas.height && g.deleteOutsideScreen) {
                            d.updateParticle(g);
                            continue
                        }
                    } else {
                        g.y -= g.secondSpeedY * c;
                        if (g.y >= d.emitterCanvas.height && g.deleteOutsideScreen) {
                            d.updateParticle(g);
                            continue
                        }
                    }
                } else {
                    g.curVel += d.prop.emitterProps.gravity * (c * 100);
                    if (d.prop.emitterProps.gravity > 0) {
                        if (g.curVel > d.prop.emitterProps.maxVel) {
                            g.curVel = d.prop.emitterProps.maxVel
                        }
                    } else {
                        if (g.curVel < d.prop.emitterProps.maxVel) {
                            g.curVel = d.prop.emitterProps.maxVel
                        }
                    }
                    if (g.curVel > 0 && g.y >= d.emitterCanvas.height && g.deleteOutsideScreen) {
                        d.updateParticle(g);
                        continue
                    }
                    g.y += g.curVel * (c * 10)
                }
                if (g.turning) {
                    g.drawn += h;
                    if (g.drawn >= g.nextRotationAt) {
                        if (g.turnLeft) {
                            g.image -= 1;
                            if (g.image < 0) {
                                g.image = d.prop.emitterProps.imageAngles - 1
                            }
                        } else {
                            g.image += 1;
                            if (g.image >= d.prop.emitterProps.imageAngles) {
                                g.image = 0
                            }
                        }
                        g.drawn = g.drawn % g.nextRotationAt
                    }
                }
                if (g.animating) {
                    g.drawn += h;
                    if (g.drawn >= (1000 / g.frameRate)) {
                        g.drawn = g.drawn % (1000 / g.frameRate);
                        if (g.animateLeft) {
                            g.image -= 1;
                            if (g.image < 0) {
                                g.image = d.usedFrames - 1
                            }
                        } else {
                            g.image += 1;
                            if (g.image >= d.usedFrames) {
                                g.image = 0
                            }
                        }
                    }
                }
                d.emitterContext.globalAlpha = g.alpha;
                d.emitterContext.drawImage(d.particleImages[g.image], 0, 0, g.width, g.height, g.x - (g.width / 2), g.y - (g.height / 2), g.width * g.sizeFactor, g.height * g.sizeFactor);
                d.emitterContext.globalAlpha = 1
            }
        }
        if (d.bounceBoxDrawn) {
            d.emitterContext.globalAlpha = 0.5;
            d.emitterContext.beginPath();
            d.emitterContext.lineWidth = "3";
            d.emitterContext.strokeStyle = "red";
            d.emitterContext.rect(d.prop.emitterProps.bounceBoxLeft, d.prop.emitterProps.bounceBoxTop, d.prop.emitterProps.bounceBoxRight - d.prop.emitterProps.bounceBoxLeft, d.prop.emitterProps.bounceBoxBottom - d.prop.emitterProps.bounceBoxTop);
            d.emitterContext.stroke();
            d.emitterContext.globalAlpha = 1
        }
        d.emittTime = Date.now();
        if (!d.flowOn && !a) {
            d.finished()
        }
        return true
    }, play: function () {
        if (!this.isRunning()) {
            this.restore()
        }
        this.prop.paused = false
    }, pause: function () {
        this.prop.paused = true
    }, stop: function () {
        this.prop.running = false
    }, restore: function () {
        Animation.Emitter.superclass.restore.apply(this, arguments);
        this.restoreExplodingParticles()
    }, isRunning: function () {
        return this.prop.running
    }, finished: function () {
        this.prop.running = false
    }, stopFlow: function () {
        this.flowOn = false
    }
};
Animation.Emitter = Sys.extend(Animation.CanvasAnimationItem, Animation.Emitter, "Animation.Emitter");
(function () {
    var a = Object.keys(Animation.Operations), e = a.length, d = 0, c, b = function (f) {
        return function (g) {
            this.updateOperation(f, g)
        }
    };
    while (d < e) {
        c = a[d];
        Animation.Emitter.prototype[c] = b(c);
        ++d
    }
}());
Sys.ns("Animation");
Animation.utils.stackBlur = {
    mulTable: [512, 512, 456, 512, 328, 456, 335, 512, 405, 328, 271, 456, 388, 335, 292, 512, 454, 405, 364, 328, 298, 271, 496, 456, 420, 388, 360, 335, 312, 292, 273, 512, 482, 454, 428, 405, 383, 364, 345, 328, 312, 298, 284, 271, 259, 496, 475, 456, 437, 420, 404, 388, 374, 360, 347, 335, 323, 312, 302, 292, 282, 273, 265, 512, 497, 482, 468, 454, 441, 428, 417, 405, 394, 383, 373, 364, 354, 345, 337, 328, 320, 312, 305, 298, 291, 284, 278, 271, 265, 259, 507, 496, 485, 475, 465, 456, 446, 437, 428, 420, 412, 404, 396, 388, 381, 374, 367, 360, 354, 347, 341, 335, 329, 323, 318, 312, 307, 302, 297, 292, 287, 282, 278, 273, 269, 265, 261, 512, 505, 497, 489, 482, 475, 468, 461, 454, 447, 441, 435, 428, 422, 417, 411, 405, 399, 394, 389, 383, 378, 373, 368, 364, 359, 354, 350, 345, 341, 337, 332, 328, 324, 320, 316, 312, 309, 305, 301, 298, 294, 291, 287, 284, 281, 278, 274, 271, 268, 265, 262, 259, 257, 507, 501, 496, 491, 485, 480, 475, 470, 465, 460, 456, 451, 446, 442, 437, 433, 428, 424, 420, 416, 412, 408, 404, 400, 396, 392, 388, 385, 381, 377, 374, 370, 367, 363, 360, 357, 354, 350, 347, 344, 341, 338, 335, 332, 329, 326, 323, 320, 318, 315, 312, 310, 307, 304, 302, 299, 297, 294, 292, 289, 287, 285, 282, 280, 278, 275, 273, 271, 269, 267, 265, 263, 261, 259],
    shgTable: [9, 11, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24],
    stackBlurImage: function (e, d, i, a) {
        var f = e, j = f.naturalWidth, g = d, c = document.createElement("canvas"), b = c.getContext("2d");
        c.style.width = j + "px";
        c.style.height = g + "px";
        c.width = j;
        c.height = g;
        b.clearRect(0, 0, j, g);
        b.drawImage(f, 0, (g - f.naturalHeight) / 2, j, f.naturalHeight);
        if (isNaN(i) || i < 1) {
            return undefined
        }
        if (a) {
            return Animation.utils.stackBlur.stackBlurCanvasRGBA(c, 0, 0, j, g, i)
        }
        return Animation.utils.stackBlur.stackBlurCanvasRGB(c, 0, 0, j, g, i)
    },
    stackBlurCanvasRGBA: function (R, m, l, a, b, K) {
        var f = R, Y = f.getContext("2d"), P, d, j, J, I, U, O, q, u, Q, r, n, S, H, F, E, G, c, t, N, o, k, s, v, w, B,
            W, M, h, L, A, z, T, D, C, g;
        if (isNaN(K) || K < 1) {
            return undefined
        }
        K |= 0;
        try {
            try {
                P = Y.getImageData(m, l, a, b)
            } catch (X) {
                try {
                    netscape.security.PrivilegeManager.enablePrivilege("UniversalBrowserRead");
                    P = Y.getImageData(m, l, a, b)
                } catch (V) {
                    throw new Error("unable to access local image data: " + V)
                }
            }
        } catch (X) {
            throw new Error("unable to access image data: " + X)
        }
        d = P.data;
        W = K + K + 1;
        M = b - 1;
        h = K + 1;
        L = h * (h + 1) / 2;
        A = new Animation.utils.stackBlur.BlurStack();
        z = A;
        for (U = 1; U < W; U++) {
            z = z.next = new Animation.utils.stackBlur.BlurStack();
            if (U === h) {
                j = z
            }
        }
        z.next = A;
        C = Animation.utils.stackBlur.mulTable[K];
        g = Animation.utils.stackBlur.shgTable[K];
        for (J = 0; J < a; J++) {
            t = N = o = c = r = n = S = Q = 0;
            u = J << 2;
            H = h * (k = d[u]);
            F = h * (s = d[u + 1]);
            E = h * (v = d[u + 2]);
            G = h * (w = d[u + 3]);
            Q += L * k;
            r += L * s;
            n += L * v;
            S += L * w;
            z = A;
            for (U = 0; U < h; U++) {
                z.r = k;
                z.g = s;
                z.b = v;
                z.a = w;
                z = z.next
            }
            q = a;
            for (U = 1; U <= K; U++) {
                u = (q + J) << 2;
                Q += (z.r = (k = d[u])) * (B = h - U);
                r += (z.g = (s = d[u + 1])) * B;
                n += (z.b = (v = d[u + 2])) * B;
                S += (z.a = (w = d[u + 3])) * B;
                c += k;
                t += s;
                N += v;
                o += w;
                z = z.next;
                if (U < M) {
                    q += a
                }
            }
            u = J;
            T = A;
            D = j;
            for (I = 0; I < b; I++) {
                O = u << 2;
                d[O + 3] = w = (S * C) >> g;
                if (w > 0) {
                    w = 255 / w;
                    d[O] = ((Q * C) >> g) * w;
                    d[O + 1] = ((r * C) >> g) * w;
                    d[O + 2] = ((n * C) >> g) * w
                } else {
                    d[O] = d[O + 1] = d[O + 2] = 0
                }
                Q -= H;
                r -= F;
                n -= E;
                S -= G;
                H -= T.r;
                F -= T.g;
                E -= T.b;
                G -= T.a;
                O = (J + (((O = I + h) < M ? O : M) * a)) << 2;
                Q += (c += (T.r = d[O]));
                r += (t += (T.g = d[O + 1]));
                n += (N += (T.b = d[O + 2]));
                S += (o += (T.a = d[O + 3]));
                T = T.next;
                H += (k = D.r);
                F += (s = D.g);
                E += (v = D.b);
                G += (w = D.a);
                c -= k;
                t -= s;
                N -= v;
                o -= w;
                D = D.next;
                u += a
            }
        }
        Y.putImageData(P, m, l);
        return f
    },
    stackBlurCanvasRGB: function (Q, o, n, a, b, J) {
        var f = Q, W = f.getContext("2d"), O, d, j, I, H, S, N, r, v, l, P, s, q, G, F, E, c, u, M, k, t, w, B, U, m, L,
            h, K, A, z, R, D, C, g;
        if (isNaN(J) || J < 1) {
            return undefined
        }
        J |= 0;
        try {
            try {
                O = W.getImageData(o, n, a, b)
            } catch (V) {
                try {
                    netscape.security.PrivilegeManager.enablePrivilege("UniversalBrowserRead");
                    O = W.getImageData(o, n, a, b)
                } catch (T) {
                    throw new Error("unable to access local image data: " + T)
                }
            }
        } catch (V) {
            throw new Error("unable to access image data: " + V)
        }
        d = O.data;
        U = J + J + 1;
        m = a - 1;
        L = b - 1;
        h = J + 1;
        K = h * (h + 1) / 2;
        A = new Animation.utils.stackBlur.BlurStack();
        z = A;
        for (S = 1; S < U; S++) {
            z = z.next = new Animation.utils.stackBlur.BlurStack();
            if (S === h) {
                j = z
            }
        }
        z.next = A;
        C = Animation.utils.stackBlur.mulTable[J];
        g = Animation.utils.stackBlur.shgTable[J];
        l = v = 0;
        for (H = 0; H < b; H++) {
            c = u = M = P = s = q = 0;
            G = h * (k = d[v]);
            F = h * (t = d[v + 1]);
            E = h * (w = d[v + 2]);
            P += K * k;
            s += K * t;
            q += K * w;
            z = A;
            for (S = 0; S < h; S++) {
                z.r = k;
                z.g = t;
                z.b = w;
                z = z.next
            }
            for (S = 1; S < h; S++) {
                N = v + ((m < S ? m : S) << 2);
                P += (z.r = (k = d[N])) * (B = h - S);
                s += (z.g = (t = d[N + 1])) * B;
                q += (z.b = (w = d[N + 2])) * B;
                c += k;
                u += t;
                M += w;
                z = z.next
            }
            R = A;
            D = j;
            for (I = 0; I < a; I++) {
                d[v] = (P * C) >> g;
                d[v + 1] = (s * C) >> g;
                d[v + 2] = (q * C) >> g;
                P -= G;
                s -= F;
                q -= E;
                G -= R.r;
                F -= R.g;
                E -= R.b;
                N = (l + ((N = I + J + 1) < m ? N : m)) << 2;
                c += (R.r = d[N]);
                u += (R.g = d[N + 1]);
                M += (R.b = d[N + 2]);
                P += c;
                s += u;
                q += M;
                R = R.next;
                G += (k = D.r);
                F += (t = D.g);
                E += (w = D.b);
                c -= k;
                u -= t;
                M -= w;
                D = D.next;
                v += 4
            }
            l += a
        }
        for (I = 0; I < a; I++) {
            u = M = c = s = q = P = 0;
            v = I << 2;
            G = h * (k = d[v]);
            F = h * (t = d[v + 1]);
            E = h * (w = d[v + 2]);
            P += K * k;
            s += K * t;
            q += K * w;
            z = A;
            for (S = 0; S < h; S++) {
                z.r = k;
                z.g = t;
                z.b = w;
                z = z.next
            }
            r = a;
            for (S = 1; S <= J; S++) {
                v = (r + I) << 2;
                P += (z.r = (k = d[v])) * (B = h - S);
                s += (z.g = (t = d[v + 1])) * B;
                q += (z.b = (w = d[v + 2])) * B;
                c += k;
                u += t;
                M += w;
                z = z.next;
                if (S < L) {
                    r += a
                }
            }
            v = I;
            R = A;
            D = j;
            for (H = 0; H < b; H++) {
                N = v << 2;
                d[N] = (P * C) >> g;
                d[N + 1] = (s * C) >> g;
                d[N + 2] = (q * C) >> g;
                P -= G;
                s -= F;
                q -= E;
                G -= R.r;
                F -= R.g;
                E -= R.b;
                N = (I + (((N = H + h) < L ? N : L) * a)) << 2;
                P += (c += (R.r = d[N]));
                s += (u += (R.g = d[N + 1]));
                q += (M += (R.b = d[N + 2]));
                R = R.next;
                G += (k = D.r);
                F += (t = D.g);
                E += (w = D.b);
                c -= k;
                u -= t;
                M -= w;
                D = D.next;
                v += a
            }
        }
        W.putImageData(O, o, n);
        return f
    },
    BlurStack: function () {
        this.r = 0;
        this.g = 0;
        this.b = 0;
        this.a = 0;
        this.next = null
    }
};
Sys.ns("Animation.utils");
Animation.utils.text = {
    measureText: function (e, c, d, b) {
        var a = Animation.utils.text.getHeightOfFont(c) * 1.5;
        d = d || 0;
        b.font = c;
        return {width: Math.ceil(b.measureText(e).width) + d * 2, height: a + d * 2}
    }, getHeightOfFont: function (a) {
        return parseInt(/(\d*)px/.exec(a)[1], 10)
    }, drawText: function (i, k, e, c, h, a) {
        var d, b, j, g, f;
        k = k || 50;
        e = e || "Verdana";
        c = c || 0;
        a = a || [{}];
        a[0] = a[0] || {};
        b = document.createElement("canvas");
        j = b.getContext("2d");
        d = Animation.utils.text.shrinkFont(i, k, e, c, h, j);
        b.width = d.dimensions.width;
        b.height = d.dimensions.height;
        g = c;
        f = d.dimensions.height / 2;
        Animation.utils.text.performOperations(i, d.font, g, f, a, j);
        return b
    }, createText: function (h, d, e, b) {
        var a, c, i, g, f;
        d = d || "50px Verdana";
        e = e || 0;
        b = b || [{}];
        b[0] = b[0] || {};
        c = document.createElement("canvas");
        i = c.getContext("2d");
        a = Animation.utils.text.measureText(h, d, e, i);
        c.width = a.width;
        c.height = a.height;
        g = e;
        f = a.height / 2;
        Animation.utils.text.performOperations(h, d, g, f, b, i);
        return c
    }, createCharacterSet: function (e, d, b, f, a) {
        var i, h, c, m, l, k, g;
        c = document.createElement("canvas");
        c.width = b * e.length;
        c.height = f;
        m = c.getContext("2d");
        for (g = 0; g < e.length; g++) {
            i = e[g];
            h = Animation.utils.text.measureText(i, d, 0, m);
            l = g * b + b / 2 - h.width / 2;
            k = f / 2;
            Animation.utils.text.performOperations(i, d, l, k, a, m)
        }
        return c
    }, performOperations: function (i, d, g, f, b, j, h) {
        var e, c, a;
        j.shadowOffsetX = 0;
        j.textBaseline = "middle";
        j.font = d;
        Sys.each(b, function (k) {
            e = k.drawType || "fill";
            Sys.iterate(k, function (l, o) {
                var n, m;
                if (l !== "drawType") {
                    if (l === "fillStyle" && Sys.isObj(o)) {
                        if (o.type === "linearGradient") {
                            n = o.linearGradient;
                            m = j.createLinearGradient(n[0], n[1], n[2], n[3]);
                            Sys.each(o.colorStop, function (p) {
                                m.addColorStop(p.pos, p.rgb)
                            });
                            j.fillStyle = m
                        }
                    } else {
                        j[l] = o
                    }
                }
            });
            c = Sys.isDefined(k.offsetX) ? g + k.offsetX : g;
            a = Sys.isDefined(k.offsetY) ? f + k.offsetY : f;
            if (Sys.isDefined(h)) {
                j[e + "Text"](i, c, a, h)
            } else {
                j[e + "Text"](i, c, a)
            }
            j.shadowBlur = null
        })
    }, drawTextFromImage: function (o, g, m, l, a, e, j, k, d, p, b) {
        var n, h, c, f;
        o = o.toString();
        n = o.length;
        if (a) {
            m = m - (n * k + g * (n - 1)) / 2;
            l = l - d / 2
        }
        if (Sys.isiPhone) {
            p.save();
            p.scale(1000000, 1000000);
            p.drawImage(e, 0, 0, 1e-7, 1e-7, 0, 0, 1e-7, 1e-7);
            p.restore()
        }
        for (f = 0; f < n; f++) {
            h = o[f];
            c = j[h] * k;
            p.drawImage(e, c, (b || 0), k, d, m, l, k, d);
            m = m + k + g
        }
    }, createNumberDrawingProperties: function (a) {
        var c, b;
        if (Sys.isDefined(a.NUMBER_IMAGE)) {
            b = a.NUMBER_CHAR_MAP || Sys.range(0, 9);
            c = Resources.readData("animationImages")[a.NUMBER_IMAGE]
        } else {
            b = Sys.range(0, 9);
            c = Animation.utils.text.createCharacterSet("0123456789", a.NUMBER_FONT, a.NUMBER_WIDTH, a.NUMBER_HEIGHT, a.NUMBER_TEXT_OPERATIONS)
        }
        return {image: c, width: a.NUMBER_WIDTH, height: a.NUMBER_HEIGHT, charMap: b}
    }, wrapCanvasText: function (m, d, h, f, k, j, a, o, i, b) {
        var c, g = Sys.isDefined(b) ? m.split(b) : this.wrapCanvasTextSplitInRows(m, k, o), e = g.length,
            l = o.canvas.height / 2, p = l - (e / 2 - 0.5) * j;
        if (i) {
            f = p;
            o.textBaseline = "center"
        }
        for (c = 0; c < e; c++) {
            this.performOperations(g[c], d, h, f, a, o, k);
            f += j
        }
    }, wrapCanvasTextSplitInRows: function (g, f, i) {
        var d = g.trim().split(" "), j = "", a, e = [], b, c, h;
        for (a = 0; a < d.length; a++) {
            b = j === "" ? d[a] : j + " " + d[a];
            c = i.measureText(b);
            h = c.width;
            if (d[a] === "") {
                continue
            }
            if (h > f) {
                e.push(j);
                j = a < d.length - 1 ? "" : d[a]
            } else {
                j = b
            }
        }
        e.push(j);
        return e
    }, shrinkFont: function (f, h, d, c, e, g) {
        var i = h, b, a;
        do {
            b = h + "px " + d;
            a = Animation.utils.text.measureText(f, b, c, g);
            h--
        } while (a.width > e);
        h++;
        return {font: b, fontSize: h, dimensions: a, sizeOffset: i - h}
    }
};
Sys.ns("Animation");
Animation.CanvasAnimationScene = {
    constructor: function (a) {
        var b = this, c = Environment.getVirtualToWindowScale(3);
        a = a || {};
        b.prop = {delay: 0, duration: 0, running: true, matrix: new Float32Array([c, 0, 0, c, 0, 0]), opacity: 1};
        b.prop = Sys.apply(b.prop, a);
        b.endEvent = a.endEvent || undefined;
        b.lists = [];
        b.listsToAdd = [];
        b.nonActiveLists = [];
        b.active = a.active || false
    }, updateScaleValue: function () {
        var a = Environment.getVirtualToWindowScale(3);
        this.prop.matrix[0] = a;
        this.prop.matrix[3] = a
    }, run: function (f) {
        var d = this, g = d.prop, b, a = [], e, c;
        if (f.time >= g.delay) {
            d.checkNonActiveLists();
            if (d.listsToAdd.length > 0) {
                d.addLists(d.listsToAdd);
                d.listsToAdd.length = 0
            }
            b = d.lists.length;
            for (c = -1; ++c < b;) {
                e = d.lists[c];
                if (e.prop.running) {
                    a.push.apply(a, e.run(f, {matrix: g.matrix, opacity: g.opacity}))
                } else {
                    d.nonActiveLists.push(e);
                    d.lists.splice(c, 1);
                    b--;
                    c--
                }
            }
        }
        return a
    }, add: function (a) {
        a.prop.running = true;
        Animation.utils.insertInOrder(a, this.lists)
    }, addLists: function (a) {
        var b = a.length, c;
        for (c = -1; ++c < b;) {
            this.add(a[c])
        }
    }, play: function () {
        this.prop.running = true
    }, stop: function () {
        this.prop.running = false
    }, isActive: function () {
        return this.active
    }, checkNonActiveLists: function () {
        var a = this.nonActiveLists, b = a.length, c;
        for (c = -1; ++c < b;) {
            if (a[c].prop.running) {
                this.listsToAdd.push(a[c]);
                a.splice(c, 1);
                b--;
                c--
            }
        }
    }
};
Animation.CanvasAnimationScene = Sys.extend(Sys.Observable, Animation.CanvasAnimationScene, "Animation.CanvasAnimationScene");
Sys.ns("Animation");
Animation.VideoItem = {
    constructor: function (a) {
        var b = this;
        Animation.VideoItem.superclass.constructor.call(b, a);
        b.setupVideo(a);
        b.setupEvents(a.callbacks)
    }, setupVideo: function (b) {
        var d = this, a = document.createElement("video"), c = Resources.readData("videos");
        a.src = c[b.src];
        a.preload = "auto";
        a.loop = Sys.isDefined(b.loop) ? b.loop : true;
        a.autoplay = Sys.isDefined(b.autoplay) ? b.autoplay : true;
        a.type = Sys.isDefined(b.type) ? b.type : undefined;
        a.style.display = "none";
        document.body.appendChild(a);
        d.prop.image = a;
        d.videoEl = a
    }, setupEvents: function (c) {
        var b = this, a;
        if (Sys.isDefined(c)) {
            a = Sys.isDefined(c.canPlayThrough) ? c.canPlayThrough : undefined
        }
        b.videoEl.addEventListener("canplaythrough", b.onCanPlayThrough(a))
    }, onCanPlayThrough: function (b) {
        var a = this;
        if (Sys.isDefined(b)) {
            b()
        }
        a.videoEl.removeEventListener("canplaythrough", a.onCanPlayThrough)
    }, toggleSound: function (a) {
        this.videoEl.muted = Sys.isDefined(a) ? a : !this.videoEl.muted
    }, play: function () {
        var a = this;
        if (!a.isRunning()) {
            a.restore();
            a.videoEl.load()
        }
        a.prop.paused = false;
        a.videoEl.style.display = "block";
        a.videoEl.play();
        setTimeout(function () {
            a.videoEl.style.display = "none"
        }, 0)
    }, restore: function () {
        if (this.videoEl.currentTime > 0) {
            this.videoEl.currentTime = 0
        }
        Animation.VideoItem.superclass.restore.apply(this, arguments)
    }, pause: function () {
        Animation.VideoItem.superclass.pause.apply(this, arguments);
        this.videoEl.pause()
    }, stop: function () {
        var a = this;
        Animation.VideoItem.superclass.stop.apply(a, arguments);
        a.videoEl.pause();
        if (a.videoEl.currentTime > 0) {
            a.videoEl.currentTime = 0
        }
    }
};
Animation.VideoItem = Sys.extend(Animation.CanvasAnimationItem, Animation.VideoItem, "Animation.VideoItem");
Sys.ns("Animation");
Animation.BufferedReelList = {
    constructor: function (a) {
        var c = this, b;
        Animation.BufferedReelList.superclass.constructor.call(c, {});
        b = c.applyConfig(a);
        c.model = c.createModel(b);
        c.id = b.id;
        c.hasSignaledReelStop = true;
        c.animationItems = c.createAnimationItems();
        c.depthDistributionArray = c.calculateDepthDistributionArray();
        c.symbolsWithSpecialEffects = {}
    }, applyConfig: function (a) {
        var c = this, b;
        b = c.applyDefaultsToConfig(a);
        c.symbolWidths = b.symbolWidths;
        c.symbolHeights = b.symbolHeights;
        c.blurredSymbolWidths = b.blurredSymbolWidths;
        c.blurredSymbolHeights = b.blurredSymbolHeights;
        c.maxBlurredSymbolHeight = 0;
        c.baseDepth = b.baseDepth;
        c.depthDistribution = b.depthDistribution;
        c.symbolSpecificDepthModifiers = b.symbolSpecificDepthModifiers;
        c.left = b.left;
        c.top = b.top;
        Sys.iterate(b.blurredSymbolHeights, function (e, d) {
            c.maxBlurredSymbolHeight = Math.max(c.maxBlurredSymbolHeight, d)
        });
        c.maxBlurredSymbolWidth = 0;
        Sys.iterate(b.blurredSymbolWidths, function (e, d) {
            c.maxBlurredSymbolWidth = Math.max(c.maxBlurredSymbolWidth, d)
        });
        if (b.orientation === "vertical") {
            c.left -= (c.maxBlurredSymbolWidth - c.symbolWidths.standard) / 2
        } else {
            c.top -= (c.maxBlurredSymbolHeight - c.symbolHeights.standard) / 2
        }
        c.orientation = b.orientation;
        c.reelAreaLength = b.visibleLength;
        c.spinDirection = b.spinDirection;
        c.blurOffsetFromStart = b.blurOffsetFromStart;
        c.blurOffsetFromEnd = b.blurOffsetFromEnd;
        c.maxTimeStep = Math.round(b.timeToMoveOneSlot * 0.75);
        return b
    }, applyDefaultsToConfig: function (a) {
        var b = {
            id: "UnidentifiedReelList",
            symbolWidths: 150,
            symbolHeights: 150,
            blurredSymbolWidths: undefined,
            blurredSymbolHeights: undefined,
            symbolCenterToCenter: 150,
            baseDepth: 0,
            depthDistribution: {type: "increasing", step: 1},
            symbolSpecificDepthModifiers: {},
            numberOfOutcomeSymbols: 3,
            top: 0,
            left: 0,
            orientation: "vertical",
            visibleLength: undefined,
            outcomeOffset: 0,
            spinDirection: "positive",
            timeToMoveOneSlot: 1000,
            startBounceSupportPointOffset: undefined,
            endBounceSupportPointOffsets: [],
            endBounceDurations: [],
            symbolRetrievalFunction: function () {
            },
            reelStartCallback: function () {
            },
            reelStartCompleteCallback: function () {
            },
            reelStartedStoppingCallback: function () {
            },
            reelBounceStartCallback: function () {
            },
            reelStoppedCallback: function () {
            }
        };
        Sys.applyProperties(b, a);
        if (Sys.isNumber(b.symbolWidths)) {
            b.symbolWidths = {standard: b.symbolWidths}
        }
        if (Sys.isNumber(b.symbolHeights)) {
            b.symbolHeights = {standard: b.symbolHeights}
        }
        if (!Sys.isDefined(b.blurredSymbolWidths)) {
            b.blurredSymbolWidths = b.symbolWidths
        } else {
            if (Sys.isNumber(b.blurredSymbolWidths)) {
                b.blurredSymbolWidths = {standard: b.blurredSymbolWidths}
            }
        }
        if (!Sys.isDefined(b.blurredSymbolHeights)) {
            b.blurredSymbolHeights = b.symbolHeights
        } else {
            if (Sys.isNumber(b.blurredSymbolHeights)) {
                b.blurredSymbolHeights = {standard: b.blurredSymbolHeights}
            }
        }
        if (!Sys.isDefined(b.visibleLength)) {
            b.visibleLength = b.numberOfOutcomeSymbols * b.symbolCenterToCenter
        }
        if (!Sys.isDefined(b.startBounceSupportPointOffset)) {
            b.startBounceSupportPointOffset = -2 * b.symbolCenterToCenter
        }
        return b
    }, refresh: function (a) {
        var b = this;
        b.applyConfig(a);
        b.updateModel(a);
        if (b.model.getState() === "stopping") {
            b.rotatedDuringSpinStop = true
        }
        b.depthDistributionArray = b.calculateDepthDistributionArray()
    }, correctMisalignedOutcomeOnDeviceRotate: function () {
        var a = this;
        if (a.rotatedDuringSpinStop) {
            a.presentOutcome();
            a.rotatedDuringSpinStop = false
        }
    }, updateModel: function (d) {
        var g = this, c = g.model, f = d.orientation === "vertical",
            e = f ? g.maxBlurredSymbolHeight : g.maxBlurredSymbolWidth,
            a = f ? g.symbolHeights.standard : g.symbolWidths.standard, h = d.symbolCenterToCenter - e,
            b = d.outcomeOffset - (e - a) / 2;
        c.refresh({
            symbolLength: e,
            symbolSpacing: h,
            numberOfOutcomeSymbols: d.numberOfOutcomeSymbols,
            visibleWindowLength: d.visibleLength,
            outcomeOffset: b,
            startBounceSupportPointOffset: d.startBounceSupportPointOffset,
            endBounceSupportPointOffsets: d.endBounceSupportPointOffsets,
            endBounceDurations: d.endBounceDurations,
            timeToMoveOneSlot: d.timeToMoveOneSlot
        })
    }, getSymbolLayout: function () {
        var d = this, c = [], b, a, e = 0;
        if (d.indexOfFirstOutcomeItem) {
            e = d.indexOfFirstOutcomeItem
        }
        for (a = 0; a < d.model.numberOfOutcomeSymbols; ++a) {
            b = d.animationItems[e + a];
            c.push({
                top: b.prop.top,
                left: b.prop.left,
                width: b.prop.width,
                height: b.prop.height,
                depth: b.prop.depth
            })
        }
        return c
    }, createModel: function (c) {
        var f = this, e = c.orientation === "vertical", d = e ? f.maxBlurredSymbolHeight : f.maxBlurredSymbolWidth,
            a = e ? f.symbolHeights.standard : f.symbolWidths.standard, g = c.symbolCenterToCenter - d,
            b = c.outcomeOffset - (d - a) / 2;
        return new Animation.BufferedReelModel({
            id: c.id,
            symbolLength: d,
            symbolSpacing: g,
            numberOfOutcomeSymbols: c.numberOfOutcomeSymbols,
            visibleWindowLength: c.visibleLength,
            outcomeOffset: b,
            startBounceSupportPointOffset: c.startBounceSupportPointOffset,
            endBounceSupportPointOffsets: c.endBounceSupportPointOffsets,
            endBounceDurations: c.endBounceDurations,
            timeToMoveOneSlot: c.timeToMoveOneSlot,
            symbolRetrievalFunction: c.symbolRetrievalFunction,
            reelStartCallback: c.reelStartCallback,
            reelStartCompleteCallback: c.reelStartCompleteCallback,
            reelStartedStoppingCallback: c.reelStartedStoppingCallback,
            reelBounceStartCallback: c.reelBounceStartCallback,
            reelStoppedCallback: c.reelStoppedCallback,
            reelStartSpinParameters: c.reelStartSpinParameters,
            reelStopVelocityFactor: c.reelStopVelocityFactor
        })
    }, reset: function () {
        this.model.reset()
    }, createAnimationItems: function () {
        var d = this, b = [], a = d.model.visibleSymbolsCount, c;
        for (c = 0; c < a; c++) {
            b.push(new Animation.CanvasAnimationItem({}))
        }
        return b
    }, calculateDepthDistributionArray: function () {
        var f = this, g = f.model.visibleSymbolsCount, e = f.depthDistribution.type, d = f.depthDistribution.step, c, h,
            a = Math.floor(g / 2), b = [];
        for (c = 0; c < g; c++) {
            if (e === "increasing") {
                h = c
            } else {
                if (e === "decreasing") {
                    h = g - c
                } else {
                    if (e === "curve-out") {
                        h = Math.abs(a - Math.abs(a - c))
                    } else {
                        if (e === "curve-in") {
                            h = Math.abs(a - c)
                        }
                    }
                }
            }
            b.push(h * d)
        }
        return b
    }, startSpin: function (a) {
        this.model.start(a)
    }, stopSpin: function (a) {
        this.model.storeSpinOutcome(a.symbols);
        this.model.stop()
    }, isStopping: function () {
        return this.model.isStopping()
    }, presentOutcome: function () {
        this.model.presentOutcome()
    }, setAllReelSymbols: function (a) {
        this.model.setInitialOutcome(a.symbols)
    }, setReelSymbol: function (b, a) {
        this.model.updateOutcome(a, b)
    }, setSymbols: function (b) {
        var c = -1, a = this.model.numberOfOutcomeSymbols;
        for (; ++c < a;) {
            if (Sys.isDefined(b[c])) {
                this.model.updateOutcome(c, b[c])
            }
        }
    }, run: function (e, c) {
        var b = this, d = Math.min(e.timeStep, b.maxTimeStep), a, f;
        b.model.move(d);
        a = b.model.getSymbolsToRender();
        f = b.getReelItemsForRendering(a, e, c);
        b.addDepthModifiers(f);
        return f
    }, getReelItemsForRendering: function (w, j, p) {
        var C = this, z = C.shouldUseMotionBlur(), o = C.maxBlurredSymbolWidth, a = C.maxBlurredSymbolHeight,
            m = C.orientation === "vertical" ? a : o, u, v, y, h = [], r, t, d, b, q,
            B = z ? C.blurredSymbolWidths : C.symbolWidths, g = z ? C.blurredSymbolHeights : C.symbolHeights, l, A, k,
            c, n, x, s, e = Environment.getVirtualToWindowScale(3), f = w.length;
        C.indexOfFirstOutcomeItem = C.animationItems.length - 1;
        for (v = -1; ++v < f;) {
            if (w[v].isOutcomeSymbol && v < C.indexOfFirstOutcomeItem) {
                C.indexOfFirstOutcomeItem = v
            }
            y = C.animationItems[v];
            r = w[v].symbol;
            b = Sys.isDefined(B[r]) ? r : "standard";
            q = Sys.isDefined(g[r]) ? r : "standard";
            t = w[v].position;
            d = m;
            l = B[b];
            A = g[q];
            n = C.orientation === "vertical" ? A : l;
            x = (m - n) / 2;
            s = 0;
            if (z) {
                r += "-BLURRED"
            } else {
                if (C.shouldUseSpecialEffect(r)) {
                    r += "-SPECIAL_EFFECT"
                }
            }
            k = Game.stage.view.animationManager.images[r];
            c = k.width / Math.round(l * e);
            if (t < 0) {
                s = -t;
                t = 0;
                d -= s
            }
            if (x > 0) {
                if (s > x) {
                    s -= x;
                    d -= x
                } else {
                    if (s + d < x) {
                        s = 0;
                        d = 0
                    } else {
                        d += (x - s);
                        t += (x - s);
                        s = 0
                    }
                }
                if (s + d > n) {
                    d = n - s
                }
            }
            u = (t + d) - C.reelAreaLength;
            if (u > 0) {
                d -= u
            }
            if (y.isRunning() && d > 0) {
                t = Math.floor(t);
                d = Math.ceil(d);
                s = Math.floor(s);
                if (C.spinDirection === "negative") {
                    t = C.reelAreaLength - t;
                    t -= d;
                    s = s === 0 ? n - d : 0
                }
                if (C.orientation === "vertical") {
                    y.prop = Sys.applyProperties(y.prop, {
                        image: r,
                        SX: 0,
                        SY: Math.floor(s * e),
                        SWidth: Math.floor(l * e),
                        SHeight: Math.floor(d * e),
                        left: Math.floor(C.left + (o - l) / 2),
                        top: C.top + t,
                        width: l,
                        height: d,
                        depth: C.baseDepth,
                        pivot: {x: -(l / 2), y: -(d / 2)}
                    })
                } else {
                    y.prop = Sys.applyProperties(y.prop, {
                        image: r,
                        SX: Math.floor(s * e),
                        SY: 0,
                        SWidth: Math.floor(d * e),
                        SHeight: Math.floor(A * e),
                        left: C.left + t,
                        top: Math.floor(C.top + (a - A) / 2),
                        width: d,
                        height: A,
                        depth: C.baseDepth,
                        pivot: {x: -(d / 2), y: -(A / 2)}
                    })
                }
                if (c !== 1) {
                    y.prop.SWidth = y.prop.SWidth * c;
                    y.prop.SHeight = y.prop.SHeight * c;
                    y.prop.SX = y.prop.SX * c;
                    y.prop.SY = y.prop.SY * c
                }
                if (y.prop.SWidth > 0 && y.prop.SHeight > 0) {
                    y.run(j, p);
                    h.push(y)
                } else {
                    y.prop.image = undefined
                }
            } else {
                y.prop.image = undefined
            }
        }
        return h
    }, shouldUseMotionBlur: function () {
        var e = this, f = e.model.getState(), d = Date.now(), c = e.model.getStartTime(),
            a = e.model.getStartedStoppingTime(), b = e.model.getStopDuration();
        if (Sys.isNumber(e.blurOffsetFromStart) && (f === "starting" || f === "windingDown")) {
            return d >= (c + e.blurOffsetFromStart)
        } else {
            if (Sys.isNumber(e.blurOffsetFromEnd) && f === "stopping" && a !== null) {
                return d < (a + (b - e.blurOffsetFromEnd))
            }
        }
        return e.model.isSpinning()
    }, addDepthModifiers: function (g) {
        var e = this, c = e.getReelPositionDepthOffsets(g.length), b = e.symbolSpecificDepthModifiers, f, d, a;
        Sys.each(g, function (i, h) {
            a = c[h];
            f = i.prop.image;
            if (Sys.isString(f)) {
                d = f.match(/SYM\d+/);
                if (Sys.isArray(d) && Sys.isDefined(b[d[0]])) {
                    a += b[d[0]]
                } else {
                    if (Sys.isDefined(b[f])) {
                        a += b[f]
                    }
                }
            }
            i.prop.depth += a
        })
    }, getReelPositionDepthOffsets: function (a) {
        var c = this, b = c.depthDistributionArray;
        if (c.depthDistribution === "increasing" || c.depthDistribution === "decreasing") {
            return b
        }
        return b.slice(Math.floor((b.length - a) / 2))
    }, hideSymbols: function (a) {
        this.setPlayingStateForSymbols(a, false)
    }, showSymbols: function (a) {
        this.setPlayingStateForSymbols(a, true)
    }, setPlayingStateForSymbols: function (b, d) {
        var a, c;
        if (Sys.isArray(b)) {
            a = b.length;
            for (c = -1; ++c < a;) {
                this.setPlayingStateForSymbol(b[c], d)
            }
        } else {
            this.setPlayingStateForSymbol(b, d)
        }
    }, setPlayingStateForSymbol: function (b, c) {
        var a = this.animationItems;
        b += this.indexOfFirstOutcomeItem;
        if (Sys.isNumber(b) && Sys.isDefined(a[b])) {
            if (c) {
                a[b].play()
            } else {
                a[b].stop()
            }
        }
    }, shouldUseSpecialEffect: function (a) {
        return this.symbolsWithSpecialEffects[a] === true
    }, getSlotLength: function () {
        return this.model.slotLength
    }, getVisibleSymbolsCount: function () {
        return this.model.visibleSymbolsCount
    }, getBufferOffset: function () {
        return this.model.windowToBufferOffset
    }, setBufferOffset: function (a) {
        this.model.setBufferOffset(a)
    }, getTimeToMoveOneSlot: function () {
        return this.model.timeToMoveOneSlot
    }, setTimeToMoveOneSlot: function (a) {
        this.maxTimeStep = Math.round(a * 0.75);
        this.model.setTimeToMoveOneSlot(a)
    }, setReelStartSpinParameters: function (a) {
        this.model.setReelStartSpinParameters(a)
    }, setBlurOffsetFromStart: function (a) {
        this.blurOffsetFromStart = a
    }, setEndBounceSupportPointOffsets: function (a) {
        this.model.setEndBounceSupportPointOffsets(a)
    }, setEndBounceDurations: function (a) {
        this.model.setEndBounceDurations(a)
    }
};
Animation.BufferedReelList = Sys.extend(Animation.CanvasAnimationList, Animation.BufferedReelList, "Animation.BufferedReelList");
Sys.ns("Animation");
Animation.BufferedReelModel = function (a) {
    var b = this;
    Sys.applyProperties(b, a);
    b.slotLength = b.symbolLength + b.symbolSpacing;
    b.visibleSymbolsCount = Math.ceil(b.visibleWindowLength / b.slotLength) + 1;
    if (b.symbolSpacing < 0) {
        b.leadingSymbolsCount = Math.ceil(b.symbolLength / b.slotLength);
        b.visibleSymbolsCount += b.leadingSymbolsCount
    } else {
        b.leadingSymbolsCount = 0
    }
    b.symbolBufferMaxLength = b.calculateSymbolBufferSize();
    b.recalculateStartDuration();
    b.reset()
};
Animation.BufferedReelModel.prototype = {
    calculateSymbolBufferSize: function () {
        var b = this, c = 0, a;
        for (a = 0; a < b.endBounceSupportPointOffsets.length; a++) {
            c = Math.max(c, Math.abs(b.endBounceSupportPointOffsets[a]))
        }
        if (b.startBounceSupportPointOffset < 0) {
            c = Math.max(c, Math.abs(b.startBounceSupportPointOffset))
        } else {
            if (b.startBounceSupportPointOffset > b.visibleWindowLength) {
                c = Math.max(c, b.startBounceSupportPointOffset - b.visibleWindowLength)
            }
        }
        return b.visibleSymbolsCount + Math.ceil(c / b.slotLength)
    }, refresh: function (a) {
        var b = this;
        Sys.applyProperties(b, a);
        b.slotLength = b.symbolLength + b.symbolSpacing;
        b.visibleSymbolsCount = Math.ceil(b.visibleWindowLength / b.slotLength) + 1;
        if (b.symbolSpacing < 0) {
            b.leadingSymbolsCount = Math.ceil(b.symbolLength / b.slotLength);
            b.visibleSymbolsCount += b.leadingSymbolsCount
        } else {
            b.leadingSymbolsCount = 0
        }
        b.windowToBufferOffset = b.symbolLength;
        if (b.getState() === "stopping") {
            b.targetOffset = b.getDistanceToStopPosition();
            b.stopDuration = Math.round(b.timeToMoveOneSlot * (b.targetOffset / b.slotLength));
            b.usedDuration = 0
        }
    }, reset: function () {
        var a = this;
        a.symbolBuffer = [];
        a.targetOffset = 0;
        a.usedDuration = 0;
        a.stopDuration = 0;
        a.startedStoppingAt = null;
        a.spinStartedAt = 0;
        a.currentBounce = a.endBounceSupportPointOffsets.length;
        a.hasCompletedSpin = true;
        a.hasCompletedBounce = true;
        a.outcomeVisibleOnReel = true;
        a.state = "stopping";
        a.moveToInitialPosition()
    }, moveToInitialPosition: function () {
        var a = this;
        a.windowToBufferOffset = 0;
        a.moveDistance(a.symbolBufferMaxLength * a.slotLength + a.outcomeOffset)
    }, setInitialOutcome: function (a) {
        var b = this;
        b.moveDistance(b.symbolBufferMaxLength * b.slotLength);
        b.nextOutcomeSymbols = a;
        b.outcomeSymbolsInserted = 0;
        b.moveDistance(b.numberOfOutcomeSymbols * b.slotLength);
        b.moveDistance(b.getDistanceToStopPosition())
    }, updateOutcome: function (b, c) {
        var a = this.getFirstOutcomeSymbolIndex() + b;
        if (b >= 0 && b < this.numberOfOutcomeSymbols && !isNaN(a) && a >= 0) {
            this.symbolBuffer[a].symbol = c
        }
    }, setBufferOffset: function (c) {
        var a = this, b = Math.round((c - a.windowToBufferOffset) / a.slotLength);
        if (b > 0) {
            a.addSymbolsToBuffer(b, true)
        }
        a.windowToBufferOffset = c
    }, getFirstOutcomeSymbolIndex: function () {
        var c = this, b, a = false;
        for (b = -1; ++b <= c.symbolBuffer.length;) {
            if (c.symbolBuffer[b] && c.symbolBuffer[b].isOutcomeSymbol) {
                a = true
            } else {
                if (a) {
                    return b - c.numberOfOutcomeSymbols
                }
            }
        }
        return NaN
    }, storeSpinOutcome: function (a) {
        this.nextOutcomeSymbols = a
    }, start: function (a) {
        this.spinStartedAt = Date.now() + (a || 0);
        this.startedStoppingAt = null;
        this.usedDuration = 0;
        this.targetOffset = this.visibleWindowLength + this.slotLength * this.leadingSymbolsCount;
        this.state = "starting";
        this.reelStarted = false;
        this.hasCompletedSpin = false;
        this.hasCompletedBounce = false;
        this.hasBeenToldToStop = false;
        if (Sys.isObj(this.reelStartSpinParameters)) {
            this.state = "windingUp";
            this.spinningSpeed = this.slotLength / this.timeToMoveOneSlot;
            this.windDownAcceleration = this.spinningSpeed / this.reelStartSpinParameters.windDownDuration
        }
    }, stop: function () {
        this.hasBeenToldToStop = true
    }, getDistanceToStopPosition: function () {
        var a = this, c = a.getFirstOutcomeSymbolIndex() * a.slotLength,
            b = Sys.Math.absoluteDifference(c, a.windowToBufferOffset);
        if (c > a.windowToBufferOffset) {
            b *= -1
        }
        return b + a.outcomeOffset
    }, move: function (a) {
        if (Date.now() >= this.spinStartedAt) {
            if (!this.reelStarted) {
                this.reelStarted = true;
                this.reelStartCallback()
            }
            this.moveDistance(this.getDistance(a))
        }
    }, moveDistance: function (d) {
        var c = this, b, a;
        c.windowToBufferOffset -= d;
        if (c.windowToBufferOffset < c.slotLength * c.leadingSymbolsCount) {
            b = Math.ceil(Math.abs(c.windowToBufferOffset) / c.slotLength);
            a = c.addSymbolsToBuffer(b, c.state === "stopping");
            c.windowToBufferOffset += b * c.slotLength;
            if (c.containsOutcome(a) && c.state === "spinning") {
                c.handleOutcomeEnteredReelEvent()
            }
        }
    }, presentOutcome: function () {
        var a = this, b;
        a.hasCompletedSpin = true;
        a.state = "presenting";
        b = a.getDistanceToStopPosition();
        while (isNaN(b)) {
            a.moveDistance(a.slotLength);
            b = a.getDistanceToStopPosition()
        }
        a.moveDistance(b);
        a.state = "stopping"
    }, addSymbolsToBuffer: function (d, c) {
        var b = this, a = b.symbolRetrievalFunction(d, c);
        b.symbolBuffer = a.concat(b.symbolBuffer.splice(0, b.symbolBufferMaxLength - d));
        return a
    }, containsOutcome: function (b) {
        var a;
        for (a = -1; ++a < b.length;) {
            if (b[a].isOutcomeSymbol) {
                return true
            }
        }
        return false
    }, handleOutcomeEnteredReelEvent: function () {
        var a = this;
        a.startedStoppingAt = Date.now();
        a.usedDuration = 0;
        a.currentBounce = 0;
        a.state = "stopping";
        a.targetOffset = a.getDistanceToStopPosition();
        a.stopDuration = Math.round(a.timeToMoveOneSlot * (a.targetOffset / a.slotLength));
        if (Sys.isNumber(this.reelStopVelocityFactor)) {
            this.reelStopVelocityFactor = this.reelStopVelocityFactor < 0.1 ? 0.1 : this.reelStopVelocityFactor;
            this.targetOffset += this.endBounceSupportPointOffsets[0];
            this.stopVelocity = this.reelStopVelocityFactor * this.spinningSpeed;
            this.stopDeceleration = this.calculateAcceleration(this.stopVelocity, this.spinningSpeed, this.targetOffset);
            this.currentStopDistance = 0;
            this.currentVelocity = this.spinningSpeed;
            this.stopDuration = Math.round((this.stopVelocity - this.spinningSpeed) / this.stopDeceleration)
        }
        a.outcomeVisibleOnReel = false
    }, calculateAcceleration: function (a, b, c) {
        return ((a * a) - (b * b)) / (2 * c)
    }, calculateDistance: function (b, a, c) {
        return (b * c) + (0.5 * a * c * c)
    }, getDistance: function (a) {
        switch (this.state) {
            case"windingUp":
                return this.getWindingUpDistance(a);
            case"windingDown":
                return this.getWindingDownDistance(a);
            case"starting":
                return this.getStartingDistance(a);
            case"stopping":
                return this.getStoppingDistance(a);
            default:
                return this.getSpinningDistance(a)
        }
    }, getWindingUpDistance: function (a) {
        var b = this.reelStartSpinParameters,
            c = this.getInterpolatedDistance(b.windUpDistance, b.windUpDistance, this.usedDuration, a, b.windUpDuration);
        this.usedDuration += a;
        if (c.progressAfterTime === 1) {
            this.state = "windingDown";
            this.usedDuration = 0;
            this.currentVelocity = 0
        }
        return c.distance
    }, getWindingDownDistance: function (a) {
        var b = this.calculateDistance(this.currentVelocity, this.windDownAcceleration, a);
        this.currentVelocity = this.currentVelocity + (this.windDownAcceleration * a);
        if (this.currentVelocity >= this.spinningSpeed) {
            this.state = "spinning";
            this.reelStartCompleteCallback()
        }
        return b
    }, getStartingDistance: function (b) {
        var a = this,
            c = a.getInterpolatedDistance(a.targetOffset, a.startBounceSupportPointOffset, a.usedDuration, b, a.startDuration);
        a.usedDuration += b;
        if (c.progressAfterTime === 1) {
            a.state = "spinning";
            a.reelStartCompleteCallback()
        }
        return c.distance
    }, getStoppingDistance: function (e) {
        var d = this, g, f, b = Sys.clone(this.endBounceSupportPointOffsets), a = Sys.clone(this.endBounceDurations),
            c = Sys.utils.initArray(b.length, 0);
        if (Sys.isNumber(this.reelStopVelocityFactor)) {
            c[0] = b[0] * -1;
            b[0] = c[0] / 2;
            a[0] = a[0] / 2
        }
        if (!d.hasCompletedSpin) {
            if (Sys.isNumber(this.reelStopVelocityFactor)) {
                f = this.calculateDistance(this.currentVelocity, this.stopDeceleration, e);
                this.usedDuration += e;
                if ((this.currentStopDistance + f) > this.targetOffset) {
                    f = (this.targetOffset - this.currentStopDistance) > 0 ? (this.targetOffset - this.currentStopDistance) : 0
                }
                this.currentVelocity = this.currentVelocity + (this.stopDeceleration * e);
                this.currentStopDistance += f;
                if (this.currentVelocity <= this.stopVelocity && this.currentStopDistance === this.targetOffset) {
                    this.hasCompletedSpin = true;
                    this.usedDuration = 0;
                    this.reelBounceStartCallback()
                }
            } else {
                g = d.getInterpolatedDistance(d.targetOffset, d.targetOffset / 2, d.usedDuration, e, d.stopDuration);
                f = g.distance;
                d.usedDuration += e;
                if (g.progressAfterTime === 1) {
                    d.hasCompletedSpin = true;
                    d.usedDuration = 0;
                    d.reelBounceStartCallback()
                }
            }
            return f
        } else {
            if (this.currentBounce < b.length && !this.hasCompletedBounce) {
                g = this.getInterpolatedDistance(c[this.currentBounce], b[this.currentBounce], this.usedDuration, e, a[this.currentBounce]);
                f = g.distance;
                d.usedDuration += e;
                if (g.progressAfterTime === 1) {
                    d.currentBounce++;
                    d.usedDuration = 0
                }
                return f
            }
        }
        if (!d.hasCompletedBounce) {
            d.hasCompletedBounce = true;
            d.reelStoppedCallback()
        }
        return 0
    }, getInterpolatedDistance: function (i, f, c, d, h) {
        var a = Math.min(1, c / h), b = Animation.utils.getInterpolationValue(0, i, a, {type: "bezier", support: f}),
            e = Math.min(1, (c + d) / h),
            g = Animation.utils.getInterpolationValue(0, i, e, {type: "bezier", support: f});
        return {distance: g - b, progressAfterTime: e}
    }, getSpinningDistance: function (b) {
        var a = b / this.timeToMoveOneSlot;
        return Math.round(a * this.slotLength)
    }, getSymbolsToRender: function () {
        var e = this, c = [], g = Math.floor(e.windowToBufferOffset / e.slotLength) - e.leadingSymbolsCount, a, d, b, f;
        g = Math.max(0, g);
        a = Math.min(e.visibleSymbolsCount, e.symbolBuffer.length - g);
        for (d = -1; ++d < a;) {
            b = g + d;
            f = e.symbolBuffer[b];
            f.position = b * e.slotLength - Math.round(e.windowToBufferOffset);
            c.push(f);
            if (!e.outcomeVisibleOnReel) {
                e.reelStartedStoppingCallback();
                e.outcomeVisibleOnReel = true
            }
        }
        return c
    }, getState: function () {
        return this.state
    }, getStartTime: function () {
        return this.spinStartedAt
    }, getStartedStoppingTime: function () {
        return this.startedStoppingAt
    }, getStopDuration: function () {
        return this.stopDuration
    }, isStopping: function () {
        return this.hasBeenToldToStop
    }, isSpinning: function () {
        return this.state === "spinning"
    }, setTimeToMoveOneSlot: function (a) {
        this.timeToMoveOneSlot = a;
        this.recalculateStartDuration()
    }, recalculateStartDuration: function () {
        var a = this;
        if (Sys.isObj(this.reelStartSpinParameters)) {
            return
        }
        a.startDuration = a.timeToMoveOneSlot * ((a.visibleWindowLength + Math.abs(a.startBounceSupportPointOffset) * 2) / a.slotLength)
    }, setReelStartSpinParameters: function (a) {
        this.reelStartSpinParameters = a
    }, setEndBounceSupportPointOffsets: function (a) {
        this.endBounceSupportPointOffsets = a
    }, setEndBounceDurations: function (a) {
        this.endBounceDurations = a
    }
};
Sys.ns("Animation");
Animation.PhysicsItem = {
    constructor: function (a) {
        var b = this;
        Animation.PhysicsItem.superclass.constructor.call(b, a);
        b.prop = b.prop || {};
        b.prop.timeSinceStart = 0
    }, restore: function () {
        var a = this;
        Animation.PhysicsItem.superclass.restore.call(a);
        a.prop.timeSinceStart = 0;
        a.prop.left = a.prop.startLeft;
        a.prop.top = a.prop.startTop
    }, run: function (i, h) {
        var g = this, e, b, c, f, j;
        g.prop.localTime += i.timeStep;
        g.prop.reset = false;
        if (g.prop.localTime >= g.prop.delay) {
            g.prop.timeStep = i.timeStep;
            g.prop.timeSinceStart += i.timeStep;
            e = g.prop.timeSinceStart / 1000 * 10;
            b = g.prop.gravity;
            c = g.prop.vy + (b * e);
            f = g.prop.vx;
            j = g.prop.direction;
            g.prop.top = g.prop.startTop - ((c * e) - (0.5 * b * Math.pow(e, 2))) * Sys.Math.sin(j);
            g.prop.left = g.prop.startLeft - ((f * e) - (0.5 * b * Math.pow(e, 2))) * Sys.Math.cos(j);
            g.prop.parentMatrix.set(h.matrix);
            g.performAction(i.timeStep);
            Animation.utils.updateMatrix(g.prop);
            g.prop.opacity = g.prop.ownOpacity * h.opacity;
            return !g.prop.skip
        }
        return true
    }, exceedingBounds: function (a) {
        if (!Sys.isDefined(a.bounds)) {
            return false
        }
        return a.left < a.bounds.x1 || a.left > a.bounds.x2 || a.top < a.bounds.y1 || a.top > a.bounds.y2
    }, performAction: function (a) {
        var f = 0, d = Object.keys(this.prop.operations), e = d.length, b = true, c = 0;
        while (c < e) {
            f += Animation.Operations[d[c]].performAction(this, a);
            ++c
        }
        if (this.exceedingBounds(this.prop) || this.prop.top > 600 || f === 0) {
            b = false
        }
        if (!b) {
            this.finished()
        }
        return b
    }, finished: function () {
        var a = this;
        Animation.PhysicsItem.superclass.finished.call(a);
        if (Sys.isFunc(a.prop.stopped)) {
            a.prop.stopped()
        }
    }
};
Animation.PhysicsItem = Sys.extend(Animation.CanvasAnimationItem, Animation.PhysicsItem, "Animation.PhysicsItem");
Sys.ns("Integration");
Integration.PluginMenu = {
    constructor: function () {
        Integration.PluginMenu.superclass.constructor.apply(this, arguments)
    }, getMixinDependencies: function () {
        return ["orientation"]
    }, getDefaultMVCClasses: function () {
        return {
            controller: Integration.PluginMenuController,
            view: Integration.PluginMenuBaseView,
            model: Integration.PluginMenuModel
        }
    }
};
Integration.PluginMenu = Sys.extend(Core.Module, Integration.PluginMenu, "Integration.PluginMenu");
Sys.ns("Integration");
Integration.PluginMenuController = {
    constructor: function () {
        Integration.PluginMenuController.superclass.constructor.apply(this, arguments)
    }, setupEvents: function () {
        var b = this, a = {
            "notify:stateHandler.enteringBeforeLoaderCloseState": b.onBeforeLoaderClose,
            "notify:settingsMenu.open": b.view.hideButton.bind(b.view),
            "notify:settingsMenu.closed": b.onSettingsMenuClosed,
            "notify:scaling.gameSizeChanged": b.onGameSizeChanged,
            "request:pluginMenu.init": b.initParams,
            "request:pluginMenu.activate": b.activate,
            "request:pluginMenu.deactivate": b.deactivate,
            "request:pluginMenu.notification": b.onNotification,
            "request:pluginMenu.changeMenuHeight": b.onChangeMenuHeight,
            "request:pluginMenu.enable": b.view.enableButton.bind(b.view, "PLUGIN_MENU"),
            "request:pluginMenu.disable": b.view.disableButton.bind(b.view, "PLUGIN_MENU"),
            "notify:stateHandler.enteringIdleState": b.view.enableButton.bind(b.view, "IDLE_STATE"),
            "notify:stateHandler.leavingIdleState": b.view.disableButton.bind(b.view, "IDLE_STATE"),
            "notify.fullscreen.enteringFullscreen": b.onEnteringFullscreen,
            "notify.fullscreen.leavingFullscreen": b.onLeavingFullscreen,
            "view:buttonClicked": b.onButtonClicked
        };
        a["notify:userInputManager." + b.MODULE_NAME + "ExclusiveStart"] = b.onUserInputStart;
        a["notify:userInputManager." + b.MODULE_NAME + "ExclusiveEnd"] = b.onUserInputEnd;
        b.on(a)
    }, initParams: function (b, a) {
        var c = this;
        if (b !== "" && b !== "default") {
            c.view.buttonImageExternalUrl = b
        }
        c.setMenuHeight(a);
        c.model.storeData("pluginMenuInitialized", true)
    }, setMenuHeight: function (c) {
        var b = this, a = b.view.getMaxHeight();
        if (!Sys.isDefined(c)) {
            return false
        }
        if (Sys.isObj(c)) {
            b.model.storeData("manualSetHeight", c);
            a = (b.model.readData("currentOrientation") === "PORTRAIT") ? c.portrait : c.landscape
        } else {
            if (Sys.isNumber(c) && c > 0) {
                b.model.storeData("manualSetHeight", c);
                a = c
            }
        }
        b.view.height = a;
        return true
    }, onBeforeLoaderClose: function () {
        this.view.setupContent();
        this.view.disableButton("IDLE_STATE")
    }, onChangeMenuHeight: function (b) {
        var a = this;
        if (a.setMenuHeight(b)) {
            a.view.refresh()
        }
    }, onButtonClicked: function () {
        var a = this;
        if (a.model.readData("pluginMenuActivated") === false) {
            a.activate()
        } else {
            a.deactivate()
        }
    }, activate: function () {
        var a = this;
        a.fireEvent("request:userInputManager.activateExclusivity", a.MODULE_NAME);
        a.fireEvent("request:quickSettingsMenu.externalDeactivate", a.MODULE_NAME);
        a.fireEvent("request:spinButton.hide", a.MODULE_NAME);
        a.view.activatePluginMenu();
        a.model.storeData("pluginMenuActivated", true);
        a.fireEvent("notify:pluginMenu.activated")
    }, deactivate: function () {
        var a = this;
        a.fireEvent("request:userInputManager.deactivateExclusivity", a.MODULE_NAME);
        a.fireEvent("request:quickSettingsMenu.externalActivate", a.MODULE_NAME);
        a.fireEvent("request:spinButton.show", a.MODULE_NAME);
        a.view.deactivatePluginMenu();
        a.model.storeData("pluginMenuActivated", false);
        a.fireEvent("notify:pluginMenu.deactivated")
    }, onEnteringFullscreen: function () {
        this.model.storeData("disableUserInteraction", false)
    }, onLeavingFullscreen: function () {
        this.model.storeData("disableUserInteraction", true)
    }, onUserInputStart: function (c) {
        var a = this, b;
        if (!a.model.readData("disableUserInteraction")) {
            b = !Sys.UserInputUtils.isCoordinateTarget(a.view.pluginIframe, c);
            a.model.storeData("clickedOutsideIframe", b)
        }
    }, onUserInputEnd: function (c) {
        var b = this, a;
        if (!b.model.readData("disableUserInteraction")) {
            a = !Sys.UserInputUtils.isCoordinateTarget(b.view.pluginIframe, c);
            if (b.model.readData("clickedOutsideIframe") && a) {
                b.deactivate()
            }
        }
    }, onNotification: function (a) {
        this.view.changeToNotificationImage(a)
    }, onInputFieldFocus: function () {
        window.scrollTo(0, 0);
        document.body.scrollTop = 0
    }, onGameSizeChanged: function () {
        var a = this;
        if (Sys.isFunc(a.view.refresh)) {
            a.model.storeData("gameSizeChangedTriggered", true);
            a.view.refresh()
        }
    }, onSettingsMenuClosed: function () {
        if (this.model.readData("pluginMenuInitialized") === true) {
            this.view.showButton()
        }
    }
};
Integration.PluginMenuController = Sys.extend(Core.Controller, Integration.PluginMenuController, "Integration.PluginMenuController");
Sys.ns("Integration");
Integration.PluginMenuBaseView = {
    HEIGHT: 0,
    PORTRAIT_TOP_OFFSET: 0,
    BUTTON_EXTERNAL_IMAGE_URL: "",
    BUTTON_DEFAULT_IMAGE_CSS: "integration-pluginMenu_button_uri",
    BUTTON_DEFAULT_NOTIFICATION_IMAGE_CSS: "integration-pluginMenu_button_notification_uri",
    BASE_BUTTON_CSS: "integration-pluginMenuButton_baseButton",
    PORTRAIT_CSS: "integration-pluginMenuButton_portraitBase",
    LANDSCAPE_CSS: "integration-pluginMenuButton_landscapeBase",
    DARK_OVERLAY_BASE_CSS: "integration-pluginMenuDarkOverlay_baseOverlay",
    DARK_OVERLAY_PORTRAIT_CSS: "integration-pluginMenuDarkOverlay_portraitBase",
    DARK_OVERLAY_LANDSCAPE_CSS: "integration-pluginMenuDarkOverlay_landscapeBase",
    RENDER_TARGET: "gameWrapper",
    constructor: function () {
        var a = this;
        Integration.PluginMenuBaseView.superclass.constructor.apply(a, arguments);
        a.height = a.HEIGHT;
        a.portraitTopOffset = a.PORTRAIT_TOP_OFFSET;
        a.buttonImageExternalUrl = a.BUTTON_EXTERNAL_IMAGE_URL;
        a.addScrollHandler()
    },
    setupContent: function () {
        var a = this;
        a.createDarkOverlay();
        a.createMenuButton();
        a.pluginIframe = document.getElementById("netEntExtendPlugin");
        if (a.height !== 0) {
            document.getElementById("gameWrapper").classList.add("pluginMenu");
            a.showButton()
        }
    },
    addScrollHandler: function () {
        var a = this;
        document.addEventListener("scroll", function () {
            if (!a.model.readData("disableUserInteraction") && a.model.readData("pluginMenuActive") && window.scrollY > 0) {
                window.scrollTo(0, 0);
                document.body.scrollTop = 0
            }
        })
    },
    createDarkOverlay: function () {
        var a = this;
        a.darkOverlay = new Sys.Element({
            tag: "div",
            id: "pluginMenuDarkOverlay",
            cls: a.DARK_OVERLAY_BASE_CSS,
            style: "display:none",
            renderTo: a.RENDER_TARGET
        })
    },
    createMenuButton: function () {
        var a = this;
        a.menuButton = new Interface.utils.DOMButton({
            id: "pluginMenuButton",
            baseCSS: a.BASE_BUTTON_CSS + " " + a.BUTTON_DEFAULT_IMAGE_CSS,
            renderTo: a.RENDER_TARGET,
            clickCallback: a.onButtonClick.bind(a)
        });
        a.hideButton();
        a.menuButtonSysElement = a.menuButton.getContainer();
        if (a.buttonImageExternalUrl !== "") {
            a.menuButtonSysElement.el.style["background-image"] = "url(" + a.buttonImageExternalUrl + ")"
        }
    },
    onButtonClick: function () {
        this.fireEvent("view:buttonClicked");
        this.changeToNormalImage()
    },
    activatePluginMenu: function () {
        var a = this;
        a.adjustHeight();
        a.adjustTopOffset();
        a.darkOverlay.el.style.display = "block";
        a.pluginIframe.height = a.height;
        a.pluginIframe.style.top = a.portraitTopOffset + "px";
        a.model.storeData("pluginMenuActive", true)
    },
    deactivatePluginMenu: function () {
        this.darkOverlay.el.style.display = "none";
        this.pluginIframe.height = 0;
        this.pluginIframe.style.top = 0;
        this.model.removeData("pluginMenuActive")
    },
    setStyle: function (d) {
        var e = this, c = d + "_CSS", f = d === "LANDSCAPE" ? "PORTRAIT_CSS" : "LANDSCAPE_CSS",
            b = "DARK_OVERLAY_" + d + "_CSS",
            a = "DARK_OVERLAY_" + d === "LANDSCAPE" ? "PORTRAIT_CSS" : "LANDSCAPE_CSS";
        if (Sys.isDefined(e.menuButtonSysElement) && Sys.isDefined(e[c])) {
            e.menuButtonSysElement.removeCls(e[f]);
            e.menuButtonSysElement.addCls(e[c])
        }
        if (Sys.isDefined(e.darkOverlay) && Sys.isDefined(e[b])) {
            e.darkOverlay.removeCls(e[a]);
            e.darkOverlay.addCls(e[b])
        }
    },
    showButton: function () {
        if (Resources.readData("pluginURL") && this.height !== 0) {
            this.menuButton.show(this.MODULE_NAME)
        }
    },
    hideButton: function () {
        this.menuButton.hide(this.MODULE_NAME)
    },
    enableButton: function (a) {
        this.menuButton.enable(a || this.MODULE_NAME)
    },
    disableButton: function (a) {
        this.menuButton.disable(a || this.MODULE_NAME)
    },
    adaptToOrientation: function (a) {
        var c = this, b = c.model;
        b.storeData("currentOrientation", a);
        c.setStyle(a);
        if (!b.readData("gameSizeChangedTriggered")) {
            c.refresh()
        }
    },
    refresh: function () {
        var a = this;
        a.adjustHeight();
        a.adjustTopOffset();
        if (Sys.isDefined(a.model.readData("pluginMenuActive"))) {
            a.pluginIframe.height = a.height;
            if (a.model.readData("currentOrientation") === "PORTRAIT") {
                a.pluginIframe.style.top = a.portraitTopOffset + "px"
            } else {
                a.pluginIframe.style.top = "0"
            }
        }
    },
    adjustHeight: function () {
        var d = this, c = d.getMaxHeight(), b = d.model.readData("manualSetHeight"),
            a = d.model.readData("currentOrientation");
        if (Sys.isObj(b)) {
            c = Math.min((a === "PORTRAIT") ? b.portrait : b.landscape, c)
        } else {
            if (Sys.isNumber(b) && b < c && b > 0) {
                c = Math.min(b, c)
            }
        }
        d.model.storeData("maxHeight", c);
        d.height = c
    },
    adjustTopOffset: function () {
        var b = this, a = b.getPortraitTopOffset();
        b.model.storeData("portraitTopOffset", a);
        b.portraitTopOffset = a
    },
    changeToNotificationImage: function (a) {
        var b = this;
        if (a !== "" && a !== "default") {
            b.menuButtonSysElement.el.style["background-image"] = "url(" + a + ")"
        } else {
            b.menuButtonSysElement.removeCls(b.BUTTON_DEFAULT_IMAGE_CSS);
            b.menuButtonSysElement.addCls(b.BUTTON_DEFAULT_NOTIFICATION_IMAGE_CSS)
        }
    },
    changeToNormalImage: function () {
        var a = this;
        if (a.buttonImageExternalUrl !== "") {
            a.menuButtonSysElement.el.style["background-image"] = "url(" + a.buttonImageExternalUrl + ")"
        } else {
            a.menuButtonSysElement.removeCls(a.BUTTON_DEFAULT_NOTIFICATION_IMAGE_CSS);
            a.menuButtonSysElement.addCls(a.BUTTON_DEFAULT_IMAGE_CSS)
        }
    },
    getMaxHeight: function () {
        var a = this, b;
        a.adjustTopOffset();
        if (a.model.readData("currentOrientation") === "PORTRAIT") {
            b = a.portraitTopOffset
        } else {
            b = document.getElementById("gameFooter").offsetHeight
        }
        return Sys.utils.toInt((Environment.getGameHeight() + Environment.getSpaceBelowGame()) - b)
    },
    getPortraitTopOffset: function () {
        var a = document.getElementById("settingsButtonBackground"), c = (a) ? a.offsetTop : 0,
            b = (a) ? a.offsetHeight : 0;
        return c + b
    }
};
Integration.PluginMenuBaseView = Sys.extend(Core.View, Integration.PluginMenuBaseView, "Integration.PluginMenuBaseView");
Sys.ns("Integration");
Integration.PluginMenuMobileView = {
    PORTRAIT_CSS: "integration-pluginMenuButton_portraitBase_mobile",
    LANDSCAPE_CSS: "integration-pluginMenuButton_landscapeBase_mobile",
    DARK_OVERLAY_PORTRAIT_CSS: "integration-pluginMenuDarkOverlay_portraitBase_mobile",
    DARK_OVERLAY_LANDSCAPE_CSS: "integration-pluginMenuDarkOverlay_landscapeBase_mobile",
    constructor: function () {
        Integration.PluginMenuMobileView.superclass.constructor.apply(this, arguments)
    }
};
Integration.PluginMenuMobileView = Sys.extend(Integration.PluginMenuBaseView, Integration.PluginMenuMobileView, "Integration.PluginMenuMobileView");
Sys.ns("Integration");
Integration.PluginMenuModel = {
    constructor: function () {
        Integration.PluginMenuModel.superclass.constructor.apply(this, arguments)
    }, setupData: function () {
        var a = this;
        a.storeData("pluginMenuActivated", false)
    }
};
Integration.PluginMenuModel = Sys.extend(Core.Model, Integration.PluginMenuModel, "Integration.PluginMenuModel");
if (Sys.isAndroidDevice && !Sys.isChrome) {
}
if (Sys.isAndroidDevice) {
    Sys.override(Interface.SettingsWindowBaseView, {
        open: function () {
            Game.stage.view.animationManager.pauseAnimation();
            this.container.el.style.display = "block";
            this.fireEvent("view:opened")
        }, close: function () {
            Game.stage.view.animationManager.continueAnimation();
            this.container.el.style.display = "none";
            this.fireEvent("view:closed")
        }
    });
    Sys.override(Core.ResourceLoaderController, {
        fetchAudioElementSource: function (e) {
            var d = this, f = document.createElement("audio"), c, b, a;
            c = function () {
                a();
                d.fetchedResource(e, f)
            };
            b = function () {
                a();
                d.failedToLoadResource(e)
            };
            a = function () {
                f.removeEventListener("canplaythrough", c, false);
                f.removeEventListener("error", b, false)
            };
            f.addEventListener("canplaythrough", c, false);
            f.addEventListener("error", b, false);
            f.src = e.url;
            f.load()
        }
    })
}
if (Sys.isiPhoneIOS8) {
    if (Sys.isDefined(Interface.HomeButtonController)) {
        Sys.override(Interface.HomeButtonController, {
            onUserInputEnd: function (c) {
                var b = this, a = Resources.readData("lobbyUrl");
                if (b.model.readData("activeInputTarget")) {
                    if (b.view.isInputTarget(c)) {
                        if (Sys.isDefined(a) && a !== "") {
                            b.fireEvent("request:slowRequestAnimation.show")
                        }
                        setTimeout(function () {
                            Environment.goToLobby(0)
                        }, 100)
                    }
                }
            }
        })
    }
    if (Sys.isDefined(Interface.SettingsWindowMobileView)) {
        Sys.override(Interface.SettingsWindowMobileView, {
            setHeight: function (b) {
                var a;
                if (b === "PORTRAIT") {
                    a = Environment.getGameHeight() + Environment.getSpaceBelowGame();
                    if (Sys.isIphone4Or4s) {
                        a = 1161
                    }
                    this.container.el.style.height = a + "px"
                } else {
                    this.container.el.style.height = ""
                }
            }
        })
    }
}
Sys.ns("Game");
Game.Logo = {
    constructor: function () {
        Game.Logo.superclass.constructor.apply(this, arguments)
    }, getMixinDependencies: function () {
        return ["animation"]
    }, getDefaultMVCClasses: function () {
        return {view: Game.LogoView, controller: Game.LogoController}
    }
};
Game.Logo = Sys.extend(Core.Module, Game.Logo, "Game.Logo");
Sys.ns("Game");
Game.LogoController = {
    constructor: function () {
        Game.LogoController.superclass.constructor.apply(this, arguments)
    }, setupEvents: function () {
        var a = this;
        a.on({
            "request:logo.hide": a.hide,
            "request:logo.show": a.show,
            "notify:scaling.gameSizeChanged": a.onGameSizeChanged
        })
    }, hide: function () {
        this.view.hide()
    }, show: function () {
        this.view.show()
    }, onGameSizeChanged: function () {
        if (Sys.isFunc(this.view.refresh)) {
            this.view.refresh()
        }
    }
};
Game.LogoController = Sys.extend(Core.Controller, Game.LogoController, "Game.LogoController");
Sys.ns("Game");
Game.LogoView = {
    IMAGE: "logo",
    OFFSET_LEFT: 0,
    OFFSET_TOP: 0,
    SIZE_WIDTH: 418,
    SIZE_HEIGHT: 89,
    constructor: function () {
        var a = {
            OFFSET_LEFT: this.OFFSET_LEFT,
            OFFSET_TOP: this.OFFSET_TOP,
            SIZE_WIDTH: this.SIZE_WIDTH,
            SIZE_HEIGHT: this.SIZE_HEIGHT
        };
        Game.LogoView.superclass.constructor.apply(this, arguments);
        this.CONFIG = this.CONFIG || {};
        this.CONFIG.DEFAULT = this.CONFIG.DEFAULT || {};
        Sys.applyProperties(this.CONFIG.DEFAULT, a)
    },
    hide: function () {
        this.item.stop()
    },
    show: function () {
        this.item.play()
    },
    initAnimations: function () {
        var c = this, a = c.getRenderingAttributes(), d = new Animation.CanvasAnimationList({}),
            b = new Animation.CanvasAnimationItem({
                left: a.left,
                top: a.top,
                width: a.width,
                height: a.height,
                depth: Layering.Game.Logo.image,
                image: c.IMAGE
            });
        d.add(b);
        c.list = d;
        c.item = b;
        Game.stage.view.addToRenderLoop(d)
    },
    getRenderingAttributes: function () {
        var c = this.getScaleFactor(), b = Environment.getStageResolution(),
            a = Environment.getOrientationSpecificConfig(this.CONFIG, true);
        return {
            left: ((b.width - a.SIZE_WIDTH * c) / 2) + a.OFFSET_LEFT * c,
            top: a.OFFSET_TOP * c,
            width: a.SIZE_WIDTH * c,
            height: a.SIZE_HEIGHT * c
        }
    },
    getScaleFactor: function () {
        return Resources.readData("config").mobileResourceToVirtualScale || 1
    },
    refresh: function () {
        var a = this.getRenderingAttributes(), b = this.item;
        if (Animation.utils.isAnimationItem(b)) {
            b.setImage(Game.stage.getOrientationSpecificImage(this.IMAGE));
            b.setLeft(a.left);
            b.setTop(a.top);
            b.setWidth(a.width);
            b.setHeight(a.height)
        }
    }
};
Game.LogoView = Sys.extend(Core.View, Game.LogoView, "Game.LogoView");
Sys.ns("Core");
Core.Fullscreen = {
    getDefaultMVCClasses: function () {
        var a;
        if (Platform.hasFullscreenAPI) {
            a = Core.FullscreenView
        } else {
            if (Platform.isIOSDevice && Platform.isMobileDevice && Sys.isSafari) {
                a = Core.FullscreenViewIOS
            }
        }
        if (Environment.isIniFrame || !Sys.isDefined(a)) {
            return {controller: Core.Controller}
        }
        return {controller: Core.FullscreenController, model: Core.FullscreenModel, view: a}
    }
};
Core.Fullscreen = Sys.extend(Core.Module, Core.Fullscreen, "Core.Fullscreen");
Sys.ns("Core");
Core.FullscreenController = {
    setupEvents: function () {
        if (Platform.hasFullscreenAPI) {
            this.setupFullscreenAPIEvents()
        } else {
            if (Platform.isIOSDevice && Platform.isMobileDevice && Sys.isSafari) {
                this.setupIOSEvents()
            }
        }
    }, handleInput: function (a) {
        var b = this;
        if (!b.view.isFullscreen() && !b.model.isInSafeArea(a)) {
            b.view.request()
        }
    }, setSafeArea: function (b, a) {
        this.model.setSafeArea(b, a)
    }, removeSafeArea: function (a) {
        this.model.removeSafeArea(a)
    }, onFullScreenTransitionComplete: function () {
        this.fireEvent("notify:fullscreen.fullScreenTransitionComplete")
    }, setupFullscreenAPIEvents: function () {
        var a = this;
        a.on({
            "notify:userInputManager.userInputEnded": a.handleInput,
            "request:fullscreen.request": a.view.request.bind(a.view),
            "request:fullscreen.exit": a.view.exit.bind(a.view),
            "request:fullscreen.setSafeArea": a.setSafeArea,
            "request:fullscreen.removeSafeArea": a.removeSafeArea,
            "view:fullScreenTransitionComplete": a.onFullScreenTransitionComplete
        })
    }, setupIOSEvents: function () {
        var a = this;
        a.on({
            "notify:viewport.scaled": a.view.onViewportScaled.bind(a.view),
            "notify:userInputManager.userInputEnded": a.view.onUserInputEnded.bind(a.view),
            "notify:orientation.changed": a.view.onOrientationChange.bind(a.view),
            "view:allowPropagation": a.fireEvent.bind(a, "request:userInputManager.allowPropagation"),
            "view:disallowPropagation": a.fireEvent.bind(a, "request:userInputManager.disAllowPropagation")
        })
    }
};
Core.FullscreenController = Sys.extend(Core.Controller, Core.FullscreenController, "Core.FullscreenController");
Sys.ns("Core");
Core.FullscreenModel = {
    constructor: function () {
        Core.FullscreenModel.superclass.constructor.apply(this, arguments)
    }, setupData: function () {
        this.storeData("safeAreas", {})
    }, setSafeArea: function (c, a) {
        var b = this.readData("safeAreas");
        b = b || {};
        b[c] = a;
        this.storeData("safeAreas", b)
    }, removeSafeArea: function (b) {
        var a = this.readData("safeAreas");
        a = a || {};
        a[b] = undefined;
        this.storeData("safeAreas", a)
    }, isInSafeArea: function (j) {
        var e = this.readData("safeAreas"), f, a, k, c, h, g, b, d;
        if (Sys.isDefined(j) && Sys.isDefined(e)) {
            f = Object.keys(e);
            a = f.length;
            k = Sys.UserInputUtils.getCoordinatesRelativeToElement(j, Game.stage.getGameContainer());
            c = Environment.getVirtualToWindowScale(3);
            h = k.x * c;
            g = k.y * c;
            for (d = -1; ++d < a;) {
                b = e[f[d]];
                if (Sys.isDefined(b.element)) {
                    if (Sys.UserInputUtils.isCoordinateTarget(b.element, j)) {
                        return true
                    }
                } else {
                    if (!Sys.isDefined(b.height)) {
                        if (Math.sqrt(Math.pow((h - b.x), 2) + Math.pow((g - b.y), 2)) < b.width) {
                            return true
                        }
                    } else {
                        if ((h >= b.x && h <= b.x + b.width && g >= b.y && g <= b.y + b.height)) {
                            return true
                        }
                    }
                }
            }
        }
        return false
    }
};
Core.FullscreenModel = Sys.extend(Core.Model, Core.FullscreenModel, "Core.FullscreenModel");
Sys.ns("Core");
Core.FullscreenView = {
    init: function () {
        var k = this, a = {},
            g = ["requestFullscreen", "exitFullscreen", "fullscreenElement", "fullscreenEnabled", "fullscreenchange", "fullscreenerror"],
            f = [["requestFullscreen", "exitFullscreen", "fullscreenElement", "fullscreenEnabled", "fullscreenchange", "fullscreenerror"], ["webkitRequestFullscreen", "webkitExitFullscreen", "webkitFullscreenElement", "webkitFullscreenEnabled", "webkitfullscreenchange", "webkitfullscreenerror"], ["webkitRequestFullScreen", "webkitCancelFullScreen", "webkitCurrentFullScreenElement", "webkitCancelFullScreen", "webkitfullscreenchange", "webkitfullscreenerror"], ["mozRequestFullScreen", "mozCancelFullScreen", "mozFullScreenElement", "mozFullScreenEnabled", "mozfullscreenchange", "mozfullscreenerror"], ["msRequestFullscreen", "msExitFullscreen", "msFullscreenElement", "msFullscreenEnabled", "MSFullscreenChange", "MSFullscreenError"]],
            c = f.length, b, h, e, d;
        for (e = 0; e < c; e++) {
            h = f[e];
            if (h[1] in document) {
                for (d = 0, b = h.length; d < b; d++) {
                    a[g[d]] = h[d]
                }
                break
            }
        }
        k.fullscreenAPI = a;
        Core.FullscreenView.superclass.init.apply(this, arguments)
    }, setupEvents: function () {
        var a = this;
        document.addEventListener(this.fullscreenAPI.fullscreenchange, function () {
            a.startTransitionChecker()
        })
    }, getScreenSize: function () {
        var b = Resources.readData("config"), a = Sys.isObj(b) && Boolean(b.useLetterboxing);
        return (Platform.hasFullscreenAPI || a) ? Environment.getInnerScreenSize() : Environment.getRealScreenSize()
    }, startTransitionChecker: function () {
        var a = this;
        Sys.utils.onTransitionCheck(function () {
            var c = a.getScreenSize(), b = c.width, d = c.height;
            if (a.lastWidth === b && a.lastHeight === d) {
                return true
            }
            a.lastWidth = b;
            a.lastHeight = d;
            return false
        }, function () {
            a.fireEvent("view:fullScreenTransitionComplete");
            a.fireEvent("request:viewport.resize")
        })
    }, request: function () {
        var a = false;
        if (!a) {
            document.documentElement[this.fullscreenAPI.requestFullscreen]()
        }
    }, exit: function () {
        document[this.fullscreenAPI.exitFullscreen]()
    }, isFullscreen: function () {
        return Boolean(document[this.fullscreenAPI.fullscreenElement])
    }
};
Core.FullscreenView = Sys.extend(Core.View, Core.FullscreenView, "Core.FullscreenView");
Sys.ns("Core");
Core.FullscreenViewIOS = {
    init: function (b) {
        var c = this, a;
        c._device = Resources.readData("screenSpecification");
        c.isIphone6PlusStandardMode = c._device && c._device[7] === "iPhone 6+";
        c.setupScrollOverlay();
        c.model = b.model;
        c.model.storeData("overlayVisible", false);
        if (c.isIphone6PlusStandardMode) {
            window.addEventListener("scroll", c.toggleOverlay.bind(c), false)
        }
        if (Sys.isGcmEnabled) {
            a = document.querySelector("iframe[name='commonUIIFrame']");
            if (a !== null) {
                a.style.position = "fixed"
            }
        }
    }, toggleOverlay: function () {
        document.documentElement.style.paddingBottom = "79px";
        if (Services.orientation.isLandscape() && this.isIphone6PlusStandardMode) {
            document.documentElement.style.paddingBottom = ""
        }
        if (this.isFullscreen()) {
            this.removeOverlay()
        } else {
            this.showOverlay()
        }
    }, onUserInputEnded: function () {
        this.toggleOverlay();
        if (!this.isFullscreen()) {
            this.resetGamePosition()
        }
    }, onOrientationChange: function () {
        this.toggleOverlay();
        if (!this.isFullscreen()) {
            this.resetGamePosition()
        }
    }, onViewportScaled: function () {
        this.toggleOverlay()
    }, showOverlay: function () {
        if (!this.model.readData("overlayVisible")) {
            this.fireEvent("view:allowPropagation");
            this.scrollOverlay.style.display = "block";
            this.animationContainer.style.visibility = "visible";
            this.model.storeData("overlayVisible", true)
        }
    }, resetGamePosition: function () {
        window.clearTimeout(this.removeOverlayTimeout);
        this.removeOverlayTimeout = window.setTimeout(function () {
            window.scrollTo(0, 0);
            document.getElementById("scrollup").scrollTo(0, 0)
        }, 300)
    }, removeOverlay: function () {
        this.resetGamePosition();
        if (this.model.readData("overlayVisible")) {
            this.fireEvent("view:disallowPropagation");
            this.scrollOverlay.style.display = "none";
            this.animationContainer.style.visibility = "hidden";
            this.model.storeData("overlayVisible", false);
            if (Services.orientation.isLandscape() && !Sys.isIphone5Or5sOr5c) {
                document.documentElement.style.paddingBottom = ""
            }
        }
    }, isFullscreen: function () {
        var a = Environment.getRealScreenSize();
        return a.height === window.innerHeight || window.innerHeight / a.height >= 0.9
    }, setupScrollOverlay: function () {
        this.scrollOverlay = document.createElement("div");
        this.scrollOverlay.className = "scrollup";
        this.scrollOverlay.setAttribute("id", "scrollup");
        this.scrollOverlay.style.height = "1000000px";
        this.scrollOverlay.style.display = "none";
        this.animationContainer = document.createElement("div");
        if (this.isIphone6PlusStandardMode && Services.orientation.isLandscape()) {
            this.animationContainer.style.position = "absolute"
        }
        this.animationContainer.className = "scrollAnimationContainer iOS_scrollup_uri";
        this.animationContainer.style.visibility = "hidden";
        document.body.appendChild(this.animationContainer);
        document.body.appendChild(this.scrollOverlay)
    }
};
Core.FullscreenViewIOS = Sys.extend(Core.FullscreenView, Core.FullscreenViewIOS, "Core.FullscreenViewIOS");
Sys.ns("Core");
Core.BonusMessage = {
    constructor: function () {
        Core.BonusMessage.superclass.constructor.apply(this, arguments)
    }, getDefaultMVCClasses: function () {
        return {model: Core.Model, controller: Core.BonusMessageController}
    }
};
Core.BonusMessage = Sys.extend(Core.Module, Core.BonusMessage, "Core.BonusMessage");
Sys.ns("Core");
Core.BonusMessageController = {
    constructor: function () {
        Core.BonusMessageController.superclass.constructor.apply(this, arguments)
    }, setupEvents: function () {
        this.on({
            "notify:responseParser.responseParsed": this.onServerResponse,
            "notify:stateHandler.enteringIdleState": this.showBonusMessageDialog
        })
    }, onServerResponse: function (a) {
        var b;
        if (Sys.isNumber(a.bonusAwarded)) {
            b = a.bonusAwarded.toFixed(2)
        }
        this.model.storeData("bonusAwarded", b)
    }, showBonusMessageDialog: function () {
        var a = this.model.readData("bonusAwarded");
        if (Sys.isDefined(a)) {
            this.requestDialog(a);
            this.model.setState("dialogOpen")
        }
    }, requestDialog: function (a) {
        this.fireEvent("request:dialogWindow.showDialog", this.getDialog(a))
    }, getDialog: function (a) {
        return {
            title: Services.languageManager.getText(Language.Keys.bonusAwardedTitle),
            text: Services.languageManager.getText(Language.Keys.bonusAwardedCongrats, [a]),
            buttons: [{text: Services.languageManager.getText(Language.Keys.btn_continue)}]
        }
    }
};
Core.BonusMessageController = Sys.extend(Core.Controller, Core.BonusMessageController, "Core.BonusMessageController");
Sys.ns("Game");
Game.BonusProgramWidget = {
    constructor: function () {
        Game.BonusProgramWidget.superclass.constructor.apply(this, arguments)
    }, getMixinDependencies: function () {
        return ["orientation"]
    }, getDefaultMVCClasses: function () {
        return {
            model: Game.BonusProgramWidgetModel,
            controller: Game.BonusProgramWidgetController,
            view: Game.BonusProgramWidgetView
        }
    }, getStateChanges: function () {
        var b = this.model, c = b.readData("widgetUrl"), a = b.readData("nextAction");
        return {
            beforeLoaderClose: {
                queue: [function (d) {
                    if (b.bonusProgramWidgetEnabled() && c && a === "spin") {
                        d.stateHandler.pushState(d.states.bonusProgramWidget)
                    }
                }]
            },
            checkForAdditionalFreeRounds: {waitEvents: ["notify:bonusProgramWidget.closed"]},
            bonusProgramWidget: {
                state: {
                    name: "BonusProgramWidget", execute: function () {
                    }, waitEvents: {"notify:bonusProgramWidget.closed": false}
                }
            }
        }
    }
};
Game.BonusProgramWidget = Sys.extend(Core.Module, Game.BonusProgramWidget, "Game.BonusProgramWidget");
Sys.ns("Game");
Game.BonusProgramWidgetModel = {
    constructor: function () {
        Game.BonusProgramWidgetModel.superclass.constructor.apply(this, arguments)
    }, setupData: function (b) {
        var a = b || Resources.readData("gameServerInitResponse");
        this.storeData("bonusProgramWidgetEnabled", Boolean(a.freeRoundWidgetEnabled));
        this.storeData("bonusProgramWidgetGameId", a.freeRoundWidgetGameId);
        this.storeData("bonusProgramWidgetSections", a.freeRoundWidgetSections);
        this.storeData("widgetUrl", "../../");
        this.storeData("nextAction", a.nextaction);
        this.storeData("slowServerRequestTimeLimit", 2000)
    }, bonusProgramWidgetEnabled: function () {
        return Boolean(this.readData("bonusProgramWidgetEnabled"))
    }
};
Game.BonusProgramWidgetModel = Sys.extend(Core.Model, Game.BonusProgramWidgetModel, "Game.BonusProgramWidgetModel");
Sys.ns("Game");
Game.BonusProgramWidgetController = {
    constructor: function () {
        Game.BonusProgramWidgetController.superclass.constructor.apply(this, arguments)
    }, setupEvents: function () {
        this.on({
            "notify:stateHandler.enteringBonusProgramWidgetState": this.initBonusProgramWidget,
            "notify:scaling.gameSizeChanged": this.onGameSizeChanged,
            "notify:bonusProgramWidget.notification": this.notificationHandler,
            "notify:bonusProgramWidget.close": this.closeBonusProgramWidget,
            "notify:responseParser.gameConfigurationParsed": this.checkForAdditionalFreeRounds,
            "notify:responseParser.bonusProgramWidgetValuesParsed": this.onBonusProgramWidgetValuesParsed,
            "notify:bonusProgramWidget.reInit": this.reInit,
            "view:orientationChanged": this.notifyOrientation
        })
    }, initBonusProgramWidget: function () {
        var c = this, f = this.model.readData("widgetUrl"), b = this.model.readData("bonusProgramWidgetGameId"),
            a = Resources.readData("queryData").gameId, d = this.model.readData("slowServerRequestTimeLimit"), e;
        this.view.initViewData();
        if (b.indexOf("##") !== -1) {
            e = b.split("##")[1];
            b = b.split("##")[0];
            this.model.storeData("bonusProgramWidgetTheme", e)
        }
        this.fetchWidgetVariants(f, b, d, function (h) {
            var g;
            if (!h) {
                c.view.closeIframePage();
                return
            }
            g = c.parseVariantsResponse(h, f, b, e, a);
            c.startBonusProgramWidget(g)
        })
    }, fetchWidgetVariants: function (g, e, f, b) {
        var c = this.getWidgetLocationByWidgetID(e), d = Sys.utils.httpGet({url: g + c + "/variants.json"}),
            a = setTimeout(function () {
                b(false)
            }, f);
        d.done(function (h) {
            b(h)
        }).fail(function (h) {
            b(false)
        }).always(function () {
            clearTimeout(a)
        })
    }, getWidgetLocationByWidgetID: function (a) {
        return a === "default_w" || a === "game_branded_w" ? "free_rounds_widget" : a
    }, parseVariantsResponse: function (b, i, d, h, c) {
        var a, g;
        try {
            a = JSON.parse(b.response);
            g = h ? a[h] : a[c];
            return i + this.getWidgetLocationByWidgetID(d) + (g || a["default"])
        } catch (f) {
            return false
        }
    }, startBonusProgramWidget: function (a) {
        if (a && this.checkFileExist(a)) {
            this.view.loadIframePage(a);
            this.disableSettingsButton();
            Resources.storeData("bonusProgramWidgetActive", true)
        } else {
            this.closeBonusProgramWidget()
        }
    }, checkFileExist: function (a) {
        var b = new XMLHttpRequest();
        b.open("HEAD", a, false);
        b.send();
        return b.status === 200
    }, reInit: function (a) {
        this.model.setupData(a);
        if (this.model.bonusProgramWidgetEnabled()) {
            this.initBonusProgramWidget()
        }
    }, sendMessage: function (d, c, a) {
        var b = document.getElementById("bonusProgramWidgetIframe");
        if (b) {
            b.contentWindow.postMessage({
                moduleId: "bonusProgramWidget",
                action: d,
                data: c || null,
                dataRoute: a || null
            }, "*")
        }
    }, notificationHandler: function (c) {
        var d, a, b;
        switch (c.action) {
            case"widgetReady":
                d = Resources.readData("language");
                b = Resources.readData("queryData");
                a = d.lang || d.defaultLang;
                this.notifyOrientation(Environment.getOrientation());
                this.notifyLanguage(a);
                this.sendMessage("defaultValues", {
                    operatorId: b.operatorId,
                    gameId: b.gameId,
                    theme: this.model.readData("bonusProgramWidgetTheme")
                });
                break;
            case"getTextStrings":
                this.getTextStrings(c.data, c.dataRoute);
                break;
            case"roundStarted":
                this.roundStarted();
                break;
            case"resumeNormalGameplay":
                this.resumeNormalGameplay();
                break;
            case"playFreeRoundsNow":
                this.playFreeRoundsNow();
                break;
            case"getSectionValues":
                this.sendMessage("populateSectionValues", this.model.readData("bonusProgramWidgetSections"));
                break;
            default:
                this.sendMessage("actionNotSupported")
        }
    }, getTextStrings: function (a, b) {
        var d, c = {};
        Sys.iterate(a, function (f, e) {
            if (Sys.isArray(e) && e.length > 0) {
                d = Services.languageManager.getText(f, e)
            } else {
                d = Services.languageManager.getText(f)
            }
            if (d) {
                c[f] = d
            }
        });
        this.sendMessage("populateTextStrings", c, b)
    }, roundStarted: function () {
        this.requestWidgetAction()
    }, requestWidgetAction: function () {
        this.fireEvent("request:serverManager.sendAction", "widgetspin", "notify:responseParser.bonusProgramWidgetValuesParsed")
    }, checkForAdditionalFreeRounds: function (a) {
        if (!a.freeRoundWidgetEnabled) {
            this.fireEvent("notify:bonusProgramWidget.closed")
        }
    }, onBonusProgramWidgetValuesParsed: function (a) {
        this.sendMessage("processRoundOutcome", {indexToShow: a.indexToShow})
    }, resumeNormalGameplay: function () {
        this.closeBonusProgramWidget();
        this.enableSettingsButton()
    }, playFreeRoundsNow: function () {
        this.closeBonusProgramWidget();
        this.enableSettingsButton();
        this.fireEvent("request:freeRounds.requestGameConfiguration")
    }, closeBonusProgramWidget: function () {
        this.view.closeIframePage();
        this.fireEvent("notify:bonusProgramWidget.closed")
    }, enableSettingsButton: function () {
        this.fireEvent("request:settingsButton.enable")
    }, disableSettingsButton: function () {
        this.fireEvent("request:settingsButton.disable")
    }, notifyOrientation: function (a) {
        this.sendMessage("updateOrientation", {orientation: a})
    }, notifyLanguage: function (a) {
        this.sendMessage("updateLanguage", {lang: a})
    }, onGameSizeChanged: function () {
        if (Sys.isFunc(this.view.refresh)) {
            this.model.storeData("gameSizeChangedTriggered", true);
            this.view.refresh();
            this.notifyOrientation(Environment.getOrientation())
        }
    }
};
Game.BonusProgramWidgetController = Sys.extend(Core.Controller, Game.BonusProgramWidgetController, "Game.BonusProgramWidgetController");
Sys.ns("Game");
Game.BonusProgramWidgetView = {
    PARENT_CONTAINER_ID: "viewport",
    viewElements: {},
    bonusProgramWidgetIframeId: "bonusProgramWidgetIframe",
    constructor: function () {
        Game.BonusProgramWidgetView.superclass.constructor.apply(this, arguments)
    },
    initViewData: function () {
        var c, a, b;
        a = document.createElement("div");
        b = document.createElement("div");
        a.appendChild(b);
        c = document.getElementById(this.PARENT_CONTAINER_ID);
        a.setAttribute("id", "bonusProgramWidgetContainer");
        b.setAttribute("id", "bonusProgramWidgetOverlay");
        c.appendChild(a);
        this.viewElements = {mainContainer: a, overlay: b};
        this.refresh()
    },
    adaptToOrientation: function (a) {
        if (!this.model.readData("gameSizeChangedTriggered")) {
            this.fireEvent("view:orientationChanged", a);
            this.refresh()
        }
    },
    refresh: function () {
        if (this.viewElements.iframe) {
            this.viewElements.iframe.style.width = "100%";
            this.viewElements.iframe.style.height = this.getScreenHeight() + "px"
        }
    },
    getScreenHeight: function () {
        return Sys.utils.toInt(Environment.getGameHeight() + (Sys.isiPad || Platform.isTabletDevice ? 0 : Environment.getSpaceBelowGame()))
    },
    loadIframePage: function (a) {
        this.removeIframeInstance();
        this.createIframeInstance(a)
    },
    createIframeInstance: function (b) {
        var a = document.createElement("iframe");
        a.setAttribute("id", this.bonusProgramWidgetIframeId);
        a.setAttribute("scrolling", "no");
        a.setAttribute("allowtransparency", "true");
        a.setAttribute("src", b);
        a.setAttribute("style", "width: 100%; height: " + this.getScreenHeight() + "px;");
        this.viewElements.mainContainer.appendChild(a);
        this.viewElements.iframe = a
    },
    removeIframeInstance: function () {
        var a = document.getElementById(this.bonusProgramWidgetIframeId);
        if (a) {
            a.parentNode.removeChild(a);
            this.viewElements.iframe = null
        }
    },
    closeIframePage: function () {
        var a = this.viewElements.mainContainer;
        a.parentNode.removeChild(a)
    }
};
Game.BonusProgramWidgetView = Sys.extend(Core.View, Game.BonusProgramWidgetView, "Game.BonusProgramWidgetView");
Sys.ns("Integration");
Integration.Disclaimer = {
    constructor: function () {
        Integration.Disclaimer.superclass.constructor.apply(this, arguments)
    }, getDefaultMVCClasses: function () {
        return {
            model: Integration.DisclaimerModel,
            controller: Integration.DisclaimerController,
            view: Integration.DisclaimerView
        }
    }, getStateChanges: function () {
        var a = this.model;
        return {
            beforeLoaderClose: {
                queue: [function (b) {
                    if (a.disclaimerEnabled()) {
                        b.stateHandler.pushState(b.states.disclaimer)
                    }
                }]
            }, disclaimer: {
                state: {
                    name: "Disclaimer", execute: function () {
                    }, waitEvents: {}
                }
            }
        }
    }
};
Integration.Disclaimer = Sys.extend(Core.Module, Integration.Disclaimer, "Integration.Disclaimer");
Sys.ns("Integration");
Integration.DisclaimerModel = {
    constructor: function () {
        Integration.DisclaimerModel.superclass.constructor.apply(this, arguments)
    }, setupData: function (c) {
        var b = c || Resources.readData("gameServerInitResponse"), a = Resources.readData("queryData");
        this.storeData("disclaimerEnabled", Boolean(b.iframeEnabled));
        this.storeData("language", Resources.readData("language").lang);
        this.storeData("disclaimerExtUrl", "/ext.html");
        this.storeData("gameId", a.gameId);
        this.storeData("operatorId", a.operatorId)
    }, disclaimerEnabled: function () {
        return Boolean(this.readData("disclaimerEnabled"))
    }
};
Integration.DisclaimerModel = Sys.extend(Core.Model, Integration.DisclaimerModel, "Integration.DisclaimerModel");
Sys.ns("Integration");
Integration.DisclaimerController = {
    constructor: function () {
        Integration.DisclaimerController.superclass.constructor.apply(this, arguments)
    }, setupEvents: function () {
        this.on({"notify:stateHandler.enteringDisclaimerState": this.showDisclaimerDialog})
    }, showDisclaimerDialog: function () {
        var a = this.cookieDialogRequired(), b, c = this.model.readData("language");
        if (a) {
            b = "https://www.netent.com/en/cookie-policy/" + c + "/";
            this.requestDialog({
                text: Services.languageManager.getText(Language.Keys.cookiePolicy) + " [" + Services.languageManager.getText(Language.Keys.cookiePolicyPart2) + "](" + b + ")",
                buttons: [{
                    scope: this,
                    text: Services.languageManager.getText(Language.Keys.btn_no),
                    action: this.declineCookieDialog
                }, {
                    scope: this,
                    text: Services.languageManager.getText(Language.Keys.btn_yes),
                    action: this.acceptCookieDialog
                }]
            })
        }
    }, cookieDialogRequired: function () {
        var c = this.getStoredCookieDialogChoice(), f, b, a, d, e;
        if (c) {
            c = JSON.parse(c);
            f = c.cookieAccepted;
            if (f === true) {
                this.loadDisclaimerIframe();
                return false
            } else {
                if (f === false) {
                    a = new Date();
                    b = new Date(c.date);
                    d = Math.abs(a.getTime() - b.getTime());
                    e = Math.ceil(d / (1000 * 3600 * 24));
                    if (e < 90) {
                        return false
                    }
                }
            }
        }
        return true
    }, declineCookieDialog: function () {
        this.storeCookieDialogChoice(false);
        this.closeDisclaimerDialog()
    }, acceptCookieDialog: function () {
        this.storeCookieDialogChoice(true);
        this.closeDisclaimerDialog();
        this.loadDisclaimerIframe()
    }, storeCookieDialogChoice: function (b) {
        var a = {cookieAccepted: b, date: new Date()};
        localStorage.setItem("cookieDisclaimer", JSON.stringify(a))
    }, getStoredCookieDialogChoice: function () {
        return localStorage.getItem("cookieDisclaimer")
    }, loadDisclaimerIframe: function () {
        this.view.initViewData()
    }, removeIframe: function () {
        this.view.closeDisclaimerIframe()
    }, closeDisclaimerDialog: function () {
        this.fireEvent("notify:disclaimer.dialogClosed")
    }, requestDialog: function (a) {
        this.fireEvent("request:dialogWindow.showDialog", a)
    }
};
Integration.DisclaimerController = Sys.extend(Core.Controller, Integration.DisclaimerController, "Integration.DisclaimerController");
Sys.ns("Integration");
Integration.DisclaimerView = {
    PARENT_CONTAINER_ID: "viewport", viewElements: {}, constructor: function () {
        Integration.DisclaimerView.superclass.constructor.apply(this, arguments)
    }, initViewData: function () {
        var b, a;
        this.addNoReferrerMetaTag();
        a = document.createElement("iframe");
        b = document.getElementById(this.PARENT_CONTAINER_ID);
        a.setAttribute("id", "disclaimerIframe");
        a.setAttribute("scrolling", "no");
        a.setAttribute("allowtransparency", "true");
        a.setAttribute("sandbox", "allow-scripts");
        a.style.width = "1px";
        a.style.height = "1px";
        a.style.display = "none";
        b.appendChild(a);
        this.viewElements = {iframe: a};
        this.loadIframePage()
    }, addNoReferrerMetaTag: function () {
        var a = document.createElement("meta");
        a.name = "referrer";
        a.content = "no-referrer";
        document.getElementsByTagName("head")[0].appendChild(a)
    }, loadIframePage: function () {
        var b = window.location.hostname, d = this.model.readData("disclaimerExtUrl"),
            c = this.model.readData("gameId"), a = encodeURIComponent(b);
        this.viewElements.iframe.src = d + "?id=" + c + "&m=" + a
    }, removeIframe: function () {
        var a = this.viewElements.iframe;
        a.parentNode.removeChild(a)
    }
};
Integration.DisclaimerView = Sys.extend(Core.View, Integration.DisclaimerView, "Integration.DisclaimerView");
Sys.ns("TwinSpin");
TwinSpin.SpinButtonController = {
    setupEvents: function () {
        var a = this;
        TwinSpin.SpinButtonController.superclass.setupEvents.apply(a, arguments);
        a.on({
            "request:disableKeypad": a.disable,
            "notify:stateHandler.enteringBigWinState": a.model.storeData.bind(a.model, "inWinState", true),
            "notify:stateHandler.leavingBigWinState": a.model.storeData.bind(a.model, "inWinState", false),
            "notify:stateHandler.enteringStandardWinPresentationState": a.model.storeData.bind(a.model, "inWinState", true),
            "notify:stateHandler.leavingStandardWinPresentationState": a.model.storeData.bind(a.model, "inWinState", false)
        })
    }, allowedToSpin: function () {
        var b = this, a = b.model.isAutoPlayMode();
        return ((b.model.readData("inIdleState") || b.model.readData("inWinState")) && !a && !b.model.hasProperty("disabled"))
    }, onPressedRequest: function () {
        var a = this;
        if (Platform.isDesktopDevice) {
            if (a.allowedToSpin()) {
                a.view.onPressedRequest()
            }
        } else {
            if (a.model.readData("inIdleState")) {
                a.view.onPressedRequest()
            }
        }
    }, onReleasedRequest: function () {
        var a = this;
        if (Platform.isDesktopDevice) {
            if (a.allowedToSpin()) {
                a.view.onReleasedRequest()
            }
        } else {
            if (a.model.readData("inIdleState")) {
                a.view.onReleasedRequest()
            }
        }
    }, onClick: function () {
        var b = this, a = b.model, c = "spinButtonClick";
        if (a.hasProperty("hidden")) {
            if (b.view.canInteractWhileHidden()) {
                b.fireEvent("notify:spinButton.clickedWhileHidden")
            }
        } else {
            b.fireEvent("request:audioPlayer.play", {name: c, id: "spinBtnSound"});
            b.fireEvent("notify:spinButton.clicked", {skip: a.readData("noStopOnSpin")});
            if ((a.readData("inIdleState") || b.model.readData("inWinState")) && !a.hasProperty("disabled")) {
                if (a.hasDisplayType("autoPlay")) {
                    b.fireEvent(b.AUTOPLAY_START_EVENT)
                } else {
                    b.fireEvent(b.ROUND_START_EVENT)
                }
            }
        }
    }
};
TwinSpin.SpinButtonController = Sys.extend(Interface.Slots.SpinButtonController, TwinSpin.SpinButtonController, "TwinSpin.SpinButtonController");
Sys.ns("TwinSpin");
TwinSpin.SpinButtonDesktopView = {
    constructor: function () {
        var a = this;
        TwinSpin.SpinButtonDesktopView.superclass.constructor.apply(a, arguments);
        a.BUTTON_POSITION = TwinSpin.Positions.SpinButton
    }, enableSpinningAnimations: function () {
    }
};
TwinSpin.SpinButtonDesktopView = Sys.extend(Interface.Slots.SpinButtonDesktopView, TwinSpin.SpinButtonDesktopView, "TwinSpin.SpinButtonDesktopView");
Sys.ns("TwinSpin");
TwinSpin.SpinButtonModel = {
    isAutoPlayMode: function () {
        var a = Services.settingsManager.getSetting("autoPlayNrSpins");
        return (Sys.isDefined(a) && a > 0)
    }
};
TwinSpin.SpinButtonModel = Sys.extend(Interface.Slots.SpinButtonModel, TwinSpin.SpinButtonModel, "TwinSpin.SpinButtonModel");
Sys.ns("TwinSpin");
TwinSpin.MaxButtonController = {
    setupEvents: function () {
        var a = this;
        TwinSpin.MaxBetButtonController.superclass.setupEvents.apply(a, arguments);
        a.on({"request:disableKeypad": a.disable})
    }, startRound: function () {
        var a = this, b = "spinButtonClick";
        a.fireEvent("request:audioPlayer.play", {name: b, id: "spinBtnSound"});
        a.fireEvent(a.ROUND_START_EVENT);
        a.fireEvent("notify:maxBetButton.startedRound")
    }
};
TwinSpin.MaxButtonController = Sys.extend(Interface.Slots.MaxBetButtonController, TwinSpin.MaxButtonController, "TwinSpin.MaxButtonController");
Sys.ns("TwinSpin");
TwinSpin.WinBannerView = {
    BACKGROUND_LEFT: undefined,
    BACKGROUND_TOP: 495,
    BACKGROUND_DEPTH: 100,
    BACKGROUND_IMAGE: "countUpBg",
    BACKGROUND_IMAGE_WIDTH: 500,
    BACKGROUND_IMAGE_HEIGHT: 75,
    NUMBER_IMAGE: "winNumbers",
    NUMBER_WIDTH: 43,
    NUMBER_HEIGHT: 53,
    COUNT_UP_LEFT: undefined,
    COUNT_UP_TOP: 535,
    COUNT_UP_DEPTH: 101,
    SHOW_TOTAL_DURATION: 100
};
TwinSpin.WinBannerView = Sys.extend(Game.Slots.WinBannerView, TwinSpin.WinBannerView, "TwinSpin.WinBannerView");
Sys.ns("TwinSpin");
TwinSpin.WinBannerDesktopView = {
    BACKGROUND_IMAGE_WIDTH: 500,
    BACKGROUND_IMAGE_HEIGHT: 75,
    NUMBER_IMAGE: undefined,
    NUMBER_FONT: "54px NETENT_MyriadPro",
    NUMBER_OFFSET: -12,
    LABEL_FONT: "26px NetentStandardUI",
    NUMBER_TEXT_OPERATIONS: [{fillStyle: "#FFFFFF"}],
    WIN_TEXT_OPERATIONS: [{fillStyle: "#FFFFFF"}],
    createItems: function () {
        var a = this;
        TwinSpin.WinBannerView.superclass.createItems.apply(this, arguments);
        a.winTextItem = a.createWinTextItem();
        a.list.add(a.winTextItem)
    },
    createWinTextItem: function () {
        var a = this, c,
            d = Animation.utils.text.createText(Services.languageManager.getText(Language.Keys.winColon_uc), a.LABEL_FONT, 0, a.WIN_TEXT_OPERATIONS),
            b = a.BACKGROUND_TOP + (a.BACKGROUND_IMAGE_HEIGHT - d.height) / 2;
        c = a.backgroundItem.prop.left + (a.backgroundItem.prop.width / 2) - d.width - 12.5;
        return new Animation.CanvasAnimationItem({
            left: c,
            top: b,
            width: d.width,
            height: d.height,
            depth: a.COUNT_UP_DEPTH,
            image: d,
            operations: {}
        })
    },
    createCountUpItem: function () {
        var a = this, b = Animation.utils.text.createNumberDrawingProperties(a);
        return new Animation.CanvasAnimationItem({
            left: Math.round(Environment.getStageResolution().width / 2 - 8.5),
            top: Math.round(a.BACKGROUND_TOP + (a.BACKGROUND_IMAGE_HEIGHT - b.height) / 2),
            width: 0,
            height: 0,
            depth: a.COUNT_UP_DEPTH,
            executeBefore: function (c) {
                var e, f, g = this.value.toString(), d;
                Animation.utils.text.drawTextFromImage(g, a.NUMBER_OFFSET, this.pivot.x, this.pivot.y, false, b.image, b.charMap, b.width, b.height, c);
                if (Sys.isDefined(this.fireOnValue)) {
                    e = this.fireOnValue.length;
                    for (d = -1; ++d < e;) {
                        f = this.fireOnValue[d];
                        if (!f.fired && this.value >= f.value) {
                            f.scope.fireEvent(f.event, f.argument);
                            f.fired = true
                        }
                    }
                }
            },
            operations: {}
        })
    }
};
TwinSpin.WinBannerDesktopView = Sys.extend(TwinSpin.WinBannerView, TwinSpin.WinBannerDesktopView, "TwinSpin.WinBannerDesktopView");
Sys.ns("TwinSpin");
TwinSpin.WinningSymbolsController = {
    setupEvents: function () {
        var a = this;
        TwinSpin.WinningSymbolsController.superclass.setupEvents.apply(a, arguments);
        a.on({"notify:stateHandler.enteringSpinningState": a.onEnteringSpinningState});
        a.removeListener("notify:winSituationsDisplay.abort")
    }, animateWinSituationSymbols: function (a, b) {
        this.showHiddenSymbols();
        TwinSpin.WinningSymbolsController.superclass.animateWinSituationSymbols.apply(this, arguments)
    }, showHiddenSymbols: function () {
        var a = this;
        a.view.stop();
        a.showSymbol(a.model.readData("symbolsHidden"));
        a.model.storeData("symbolsHidden", {})
    }, onEnteringSpinningState: function () {
        var a = this;
        a.model.resetData();
        a.showHiddenSymbols()
    }
};
TwinSpin.WinningSymbolsController = Sys.extend(Game.Slots.WinningSymbolsController, TwinSpin.WinningSymbolsController, "TwinSpin.WinningSymbolsController");
Sys.ns("TwinSpin");
TwinSpin.WinningSymbolsModel = {
    setupData: function () {
        this.storeData("symbolsHidden", {})
    }, processServerResponse: function (i) {
        var k = this, f = i.reelInfo, e, d, a = [], h, c, l = [], g, b = "",
            j = Resources.readData("config").winSituationsDisplay.SYMBOLS_TO_ANIMATE_ON_TOGGLE;
        if (i.wins && Sys.isArray(i.wins.winSituations)) {
            Sys.each(i.wins.winSituations, function (m) {
                h = [];
                Sys.each(m.positions, function (n) {
                    e = n.reelIndex;
                    d = n.symbolIndex;
                    if (f[e].overlaySymbols[d]) {
                        g = f[e].overlaySymbols[d]
                    } else {
                        g = f[e].symbols[d]
                    }
                    c = {x: e, y: d, symbol: g};
                    l.push(c);
                    if (j.contains(g)) {
                        h.push(c)
                    }
                });
                a.push(h)
            });
            b = i.wins.winType
        }
        k.storeData("winningSymbols", l);
        k.storeData("winSituationSymbols", a);
        k.storeData("winType", b)
    }, resetData: function () {
        var a = this;
        a.storeData("winningSymbols", []);
        a.storeData("winSituationSymbols", []);
        a.storeData("winType", "")
    }
};
TwinSpin.WinningSymbolsModel = Sys.extend(Core.Model, TwinSpin.WinningSymbolsModel, "TwinSpin.WinningSymbolsModel");
Sys.ns("TwinSpin");
TwinSpin.WinningSymbolsView = {
    SYMBOL_BG_ANIMATIONS: {
        smallWin: ["winLow1Sprite", "winLow2Sprite"],
        mediumWin: ["winMid1Sprite", "winMid2Sprite"],
        largeWin: ["winHigh1Sprite", "winHigh2Sprite"],
        bigWin: ["winHigh1Sprite", "winHigh2Sprite"]
    },
    allWinningSymbolAnimationDuration: {
        smallWin: "LOW_WIN_SYM_ANIMATION_TIME",
        mediumWin: "MID_WIN_SYM_ANIMATION_TIME",
        largeWin: "HIGH_WIN_SYM_ANIMATION_TIME",
        bigWin: "HIGH_WIN_SYM_ANIMATION_TIME"
    },
    configureItemForWinSituationToggling: function (f, c, a) {
        var i = this, b = Game.stage.model.getSymbolConfiguration(c.x, c.y),
            e = Resources.readData("config").winSituationsDisplay.WILD_ANIMATION_TIME,
            h = Resources.readData("spriteConfigurations").wildAnimationImg,
            k = Game.stage.view.animationManager.getSpriteSequence("wildAnimation"),
            j = Environment.getVirtualToWindowScale(2), d = {}, g = i.model.readData("symbolsHidden");
        if (Sys.isDefined(g[c.x])) {
            g[c.x].push(c.y)
        } else {
            g[c.x] = [c.y]
        }
        d[c.x] = [c.y];
        i.fireEvent("view:hideSymbol", d);
        f.reset();
        f.prop = Sys.applyProperties(f.prop, {
            depth: Layering.Game.Slots.WinningSymbols.wildAnimation,
            executeBefore: undefined,
            top: b.top + ((b.height - (h.frameHeight / j)) / 2),
            left: b.left + ((b.width - (h.frameWidth / j)) / 2),
            width: h.frameWidth / j,
            height: h.frameHeight / j,
            frameWidth: h.frameWidth,
            frameHeight: h.frameHeight,
            totalSpriteWidth: h.totalSpriteWidth,
            totalSpriteHeight: h.totalSpriteHeight,
            image: "wildAnimationImg",
            opacity: 1,
            ownOpacity: 1,
            spriteArray: k,
            operations: {
                sprite: [{time: 0, value: 0}, {
                    time: e,
                    value: k.length - 1,
                    fireEvent: {event: "view:animationComplete", scope: i}
                }, {time: e + 50, value: k.length - 1}, {time: e + 100, value: k.length - 1, goTo: 2}]
            }
        });
        f.restore()
    },
    configureItemForAllWinningSymbolsDisplay: function (f, d, a) {
        var h = this, b = Game.stage.model.getSymbolConfiguration(d.x, d.y), c = h.model.readData("winType"),
            e = Resources.readData("config").winSituationsDisplay[h.allWinningSymbolAnimationDuration[c]], g, j,
            i = Environment.getVirtualToWindowScale(2);
        g = Resources.readData("spriteConfigurations")[h.animationSprite];
        j = Game.stage.view.animationManager.getSpriteSequence(h.animationSprite + "Animation");
        f.prop = Sys.applyProperties(f.prop, {
            depth: Layering.Game.Slots.WinningSymbols.animationItems,
            top: b.top + ((b.height - (g.frameHeight / i)) / 2),
            left: b.left + ((b.width - (g.frameWidth / i)) / 2),
            width: g.frameWidth / i,
            height: g.frameHeight / i,
            frameWidth: g.frameWidth,
            frameHeight: g.frameHeight,
            totalSpriteWidth: g.totalSpriteWidth,
            totalSpriteHeight: g.totalSpriteHeight,
            image: h.animationSprite,
            opacity: 1,
            ownOpacity: 1,
            spriteArray: j,
            operations: {
                sprite: [{time: 0, value: 0}, {
                    time: e,
                    value: j.length - 1,
                    fireEvent: {event: "view:animationComplete", scope: h}
                }]
            }
        });
        if (h.model.readData("winType") !== "bigWin") {
            f.prop.operations.sprite.push({time: e, value: 0}, {time: e * 2, value: j.length - 1, goTo: 2})
        }
        f.restore()
    },
    animateSymbols: function (a, b, f) {
        var d = this, e = Math.floor(Math.random() * 2), c = d.model.readData("winType");
        d.animationSprite = d.SYMBOL_BG_ANIMATIONS[c][e];
        TwinSpin.WinningSymbolsView.superclass.animateSymbols.apply(d, arguments)
    }
};
TwinSpin.WinningSymbolsView = Sys.extend(Game.Slots.WinningSymbolsView, TwinSpin.WinningSymbolsView, "TwinSpin.WinningSymbolsView");
Sys.ns("Archbot");
Archbot.ArchbotGUI = {
    constructor: function () {
        Archbot.ArchbotGUI.superclass.constructor.apply(this, arguments)
    }, getMixinDependencies: function () {
        return ["serverResponse"]
    }, getDefaultMVCClasses: function () {
        return {controller: Archbot.ArchbotGUIController, model: Archbot.ArchbotGUIModel}
    }
};
Archbot.ArchbotGUI = Sys.extend(Core.Module, Archbot.ArchbotGUI, "Archbot.ArchbotGUI");
Sys.ns("Archbot");
Archbot.ArchbotGUIController = {
    DATA_SET: {
        background: {
            backgroundItem: {pixi: "abc", nonPixi: "item"},
            maingameReelContainer: {pixi: "reelsArea"}
        },
        introMovie: {skipButton: {pixi: "continueButton", nonPixi: "continueButtonItem"}},
        featureSplash: {continueBox: {pixi: "continueButton", nonPixi: "continueButton"}},
        paytable: {paytableButton: {pixi: "button", nonPixi: "button"}},
        autoplaySettings: {autoplayButton: {pixi: "keypadButton", nonPixi: "keypadButton"}},
        spinButton: {spinButton: {pixi: "spinButton", nonPixi: "buttonItem"}},
        maxBetButton: {keypadButton: {pixi: "keypadButton", nonPixi: "keypadButton"}},
        coinsField: {betValueTextFieldBasic: {pixi: "betItem"}, coinsValueTextFieldBasic: {pixi: "coinsItem"}},
        betSettings: {
            betLevelSelectors: {pixi: "betLevelSelector", nonPixi: "selectors.betLevelSelector"},
            coinValueSelectors: {pixi: "coinValueSelector", nonPixi: "selectors.coinValueSelector"}
        },
        freeSpinOutro: {coinWinText: {pixi: "freeSpinOutroCoinsWon"}}
    }, setupEvents: function () {
        var a = this;
        a.on({
            "request:archBotGUI.saveData": this.model.storeData.bind(a.model, "dataFromModule"),
            "request:archBotGUI.saveItem": this.model.updateItemsData.bind(a.model),
            "notify:stateHandler.leavingSetupGameState": a.gameReady
        })
    }, gameReady: function () {
        var a = this;
        Sys.iterate(a.DATA_SET, function (b, c) {
            Sys.iterate(c, function (e, d) {
                a.fireEvent("request:" + b + ".fetchItem", e, (a.model.readData("isPIXIGame") ? d.pixi : d.nonPixi))
            })
        })
    }, getElementState: function (a, c, b) {
        return this.model.fetchElementState(a, c, b)
    }, getElementCords: function (a, b) {
        return this.model.fetchCoordinates(a, b)
    }, fetchFieldData: function (a, b) {
        return this.model.fetchSelectorData(a, b)
    }, fetchDataFromModule: function (a, b) {
        this.fireEvent("request:" + a + ".fetchData", b);
        return this.model.readData("dataFromModule")
    }, isDeviceDesktop: function () {
        return Platform.isDesktopDevice ? true : false
    }, getStaticServerData: function (a, b) {
        return this.model.getStaticServerData(a, b)
    }, getDynamicServerData: function (a) {
        return this.model.getDynamicServerData(a)
    }
};
Archbot.ArchbotGUIController = Sys.extend(Core.Controller, Archbot.ArchbotGUIController, "Archbot.ArchbotGUIController");
Sys.ns("Archbot");
Archbot.ArchbotGUIModel = {
    dataTemplate: {}, setupData: function () {
        this.storeData("isPIXIGame", Game.stage.view.animationManager.renderDisplay === "Auto - WebGL")
    }, processServerResponse: function (b) {
        var a = {};
        if (b.clientaction === "init") {
            var c = {
                autoplayRounds: b.autoplay,
                betLevelValues: b.betlevel.all,
                defaultBetLevel: b.betlevel.standard,
                credit: b.credit,
                coinValues: b.denomination.all,
                defaultCoinValue: b.denomination.standard / 100,
                currentGameState: b.currentGameState,
                numberOfBetlines: b.bl.standard.length,
                isG4Mode: b.g4mode,
                isJackpotWin: b.isJackpotWin,
                jackpotCurrency: b.jackpotcurrencyiso,
                nearWinAllowed: b.nearwinallowed,
                playForFun: b.playforfun,
                playerCurrency: b.playercurrencyiso
            };
            this.storeData("serverData", c)
        } else {
            a = {
                currentGameState: b.currentGameState,
                credit: b.credit,
                nextAction: b.nextAction,
                reelInfo: b.reelInfo,
                isJackpotWin: b.isJackpotWin,
                jackpotCurrency: b.jackpotcurrencyiso,
                nearWinAllowed: b.nearwinallowed,
                wins: b.wins,
                coins: b.wins.coins,
                totalWins: b.totalWin
            };
            this.storeData("serverDynamicData", a)
        }
    }, getStaticServerData: function (c, e) {
        var d = this.readData("serverData")[c], b = this.getTestDataFromConfig(c), a;
        e = e || false;
        a = e ? d : b;
        if (!Sys.isDefined(a)) {
            a = "The key: '" + c + "' not found in the " + (e ? "server response" : "Archbot game config") + " on client."
        }
        return a
    }, getDynamicServerData: function (a) {
        var b = this.readData("serverDynamicData");
        return b[a]
    }, updateItemsData: function (a, b) {
        if (!Sys.isDefined(this.dataTemplate[a])) {
            this.dataTemplate[a] = {}
        }
        this.dataTemplate[a][b.itemName] = b.item
    }, fetchSelectorData: function (b, d) {
        var c = this.dataTemplate[b][d], a;
        if (this.readData("isPIXIGame")) {
            a = {
                currentIndex: c._index,
                valueArray: c._values,
                buttons: {
                    LEFT: {
                        dimensions: c.minusButton.getBounds(),
                        disabledAnimation: this.verifyStatePixi(c.minusButton, "disabled"),
                        enabledAnimation: this.verifyStatePixi(c.minusButton, "enabled"),
                        hoverAnimation: this.verifyStatePixi(c.minusButton, "hover")
                    },
                    RIGHT: {
                        dimensions: c.plusButton.getBounds(),
                        disabledAnimation: this.verifyStatePixi(c.plusButton, "disabled"),
                        enabledAnimation: this.verifyStatePixi(c.plusButton, "enabled"),
                        hoverAnimation: this.verifyStatePixi(c.plusButton, "hover")
                    }
                }
            }
        } else {
            a = {
                currentIndex: c.currentIndex,
                valueArray: c.valueArray,
                buttons: {
                    LEFT: {
                        dimensions: c.buttons.LEFT.dimensions,
                        disabledAnimation: c.buttons.LEFT.disabledAnimation.prop.running,
                        enabledAnimation: c.buttons.LEFT.activeAnimation.prop.running,
                        hoverAnimation: c.buttons.LEFT.hoverAnimation.prop.running
                    },
                    RIGHT: {
                        dimensions: c.buttons.RIGHT.dimensions,
                        disabledAnimation: c.buttons.RIGHT.disabledAnimation.prop.running,
                        enabledAnimation: c.buttons.RIGHT.activeAnimation.prop.running,
                        hoverAnimation: c.buttons.RIGHT.hoverAnimation.prop.running
                    }
                }
            }
        }
        return a
    }, fetchElementState: function (a, d, c) {
        var b = this.dataTemplate[a][d], e;
        if (this.readData("isPIXIGame")) {
            e = this.verifyStatePixi(b, c)
        } else {
            e = this.verifyStateNonPixi(b, c)
        }
        return e
    }, verifyStatePixi: function (b, c) {
        var a = {enabled: true, disabled: false, hover: "over"};
        if (Sys.isDefined(b._currentState) && c === "hover") {
            return b._currentState === a[c]
        } else {
            return b._enabled === a[c]
        }
    }, verifyStateNonPixi: function (b, c) {
        var a = {enabled: "active", disabled: "disabled", hover: "hover"};
        if (Sys.isDefined(b[a[c] + "Animation"])) {
            return b[a[c] + "Animation"].isRunning()
        }
    }, fetchCoordinates: function (a, c) {
        var b = this.dataTemplate[a][c], d = {};
        if (this.readData("isPIXIGame")) {
            d = this.getPixiData(b)
        } else {
            d = this.getNonPixiData(b)
        }
        return d
    }, getPixiData: function (b) {
        var a = b.getBounds();
        return {x: a.x, y: a.y, width: a.width, height: a.height}
    }, getNonPixiData: function (a) {
        if (a.prop) {
            return {x: a.prop.left, y: a.prop.top, width: a.prop.width, height: a.prop.height}
        } else {
            if (a.dimensions) {
                return {x: a.dimensions.x, y: a.dimensions.y, width: a.dimensions.width, height: a.dimensions.height}
            }
        }
    }, getTestDataFromConfig: function (a) {
        return Resources.readData("archbotTestData").data[a]
    }
};
Archbot.ArchbotGUIModel = Sys.extend(Core.Model, Archbot.ArchbotGUIModel, "Archbot.ArchbotGUIModel");
Sys.ns("TwinSpin");
TwinSpin.ArchbotGUIController = {
    DATA_SET: {
        background: {
            backgroundItem: {pixi: "abc", nonPixi: "item"},
            maingameReelContainer: {pixi: "reelsArea"}
        },
        introMovie: {skipButton: {pixi: "continueButton", nonPixi: "continueButtonItem"}},
        featureSplash: {continueBox: {pixi: "continueButton", nonPixi: "continueButton"}},
        paytable: {paytableButton: {pixi: "button", nonPixi: "button"}},
        autoplaySettings: {autoplayButton: {pixi: "keypadButton", nonPixi: "keypadButton"}},
        spinButton: {spinButton: {pixi: "spinButton", nonPixi: "buttonItem"}},
        maxBetButton: {keypadButton: {pixi: "keypadButton", nonPixi: "keypadButton"}},
        coinsField: {betValueTextFieldBasic: {pixi: "betItem"}, coinsValueTextFieldBasic: {pixi: "coinsItem"}},
        betSettings: {
            betLevelSelectors: {pixi: "betLevelSelector", nonPixi: "selectors.betLevelSelector"},
            coinValueSelectors: {pixi: "coinValueSelector", nonPixi: "selectors.coinValueSelector"}
        },
        freeSpinOutro: {coinWinText: {pixi: "freeSpinOutroCoinsWon"}}
    }
};
Sys.override(Archbot.ArchbotGUIController, TwinSpin.ArchbotGUIController);
Sys.ns("TwinSpin");
TwinSpin.WinSituationsView = {
    ANIMATION_IMAGES: {
        borderAnimation: "borderAnimationSprite",
        symbolBackgroundImg: "symbolBackgroundAnimationImg"
    },
    winSituationToggleCounter: 0,
    borderAnimationLeftOffset: 16,
    borderAnimationTopOffset: 25,
    AnimationItemDimensions: {width: 229, height: 229},
    initAnimations: function () {
        var c = this, d = Resources.readData("config").reelGroups["default"], a = d.numberOfReels,
            b = d.reelLayout.standard.numberOfOutcomeSymbols;
        c.symbolAnimationItems = Sys.utils.init2dMatrix(a, b);
        c.symbolBackgroundAnimationItems = Sys.utils.init2dMatrix(a, b);
        c.animationList = new Animation.CanvasAnimationList();
        c.symbolBackgroundAnimationList = new Animation.CanvasAnimationList();
        Game.stage.view.addToRenderLoop(c.animationList);
        Game.stage.view.addToRenderLoop(c.symbolBackgroundAnimationList);
        c.animationList.stop();
        c.symbolBackgroundAnimationList.stop();
        c.isAllWinningSymbolsAnimationCreated = false
    },
    createWinningSymbolsAnimation: function () {
        var d = this, b = d.model.readData("winSituations"), c = [], a = [];
        d.animationList.removeItems();
        d.symbolBackgroundAnimationList.removeItems();
        Sys.each(b, function (e) {
            Sys.each(e.positions, function (i) {
                var g, j, h, f;
                g = i.reelIndex;
                j = i.symbolIndex;
                if (!Sys.isDefined(d.symbolAnimationItems[g][j])) {
                    h = d.createSymbolAnimationItem(i);
                    d.symbolAnimationItems[g][j] = h;
                    c.push(h)
                } else {
                    h = d.symbolAnimationItems[g][j];
                    if (!c.contains(h)) {
                        c.push(h)
                    }
                }
                if (!Sys.isDefined(d.symbolBackgroundAnimationItems[g][j])) {
                    f = d.createSymbolAnimationItem(i);
                    f.prop.image = d.ANIMATION_IMAGES.symbolBackgroundImg;
                    d.symbolBackgroundAnimationItems[g][j] = f;
                    a.push(f)
                } else {
                    f = d.symbolBackgroundAnimationItems[g][j];
                    if (!a.contains(f)) {
                        a.push(f)
                    }
                }
            })
        });
        d.symbolBackgroundAnimationList.addItems(a);
        d.animationList.addItems(c)
    },
    resetBackgroundAnimationList: function () {
        var a = this;
        Sys.each(a.symbolBackgroundAnimationList.items, function (b) {
            b.prop.operations = {};
            b.prop.opacity = b.prop.ownOpacity = 1;
            b.restore()
        })
    },
    showSingleWinSituation: function (d, f) {
        var c = this, b = c.model.readData("winSituations")[d], a = c.model.readData("isSingleBetWayWin"), e = true;
        if (a) {
            if (c.winSituationToggleCounter++ > 1) {
                e = false
            }
        }
        c.showWinningSymbolsAnimation(b, f, e)
    },
    showWinningSymbolsAnimation: function (b, e, d) {
        var c = this, a = [];
        if (!c.isAllWinningSymbolsAnimationCreated) {
            c.isAllWinningSymbolsAnimationCreated = true;
            c.createWinningSymbolsAnimation()
        }
        c.resetBackgroundAnimationList();
        Sys.each(b.positions, function (i) {
            var g, j, h, f;
            g = i.reelIndex;
            j = i.symbolIndex;
            if (Sys.isDefined(c.symbolAnimationItems[g][j])) {
                h = c.symbolAnimationItems[g][j];
                a.push(h);
                c.configureSymbolAnimation(h)
            }
            if (d && Sys.isDefined(c.symbolBackgroundAnimationItems[g][j])) {
                f = c.symbolBackgroundAnimationItems[g][j];
                c.configureSymbolBackgroundAnimation(f)
            }
        });
        c.animationList.play(a);
        c.symbolBackgroundAnimationList.play()
    },
    createSymbolAnimationItem: function (a) {
        var b = this, c = Game.stage.model.getSymbolConfiguration(a.reelIndex, a.symbolIndex);
        return new Animation.CanvasAnimationItem({
            depth: Layering.Game.Slots.WinningSymbols.animationItems,
            delay: 1,
            top: c.top - b.borderAnimationTopOffset,
            left: c.left - b.borderAnimationLeftOffset,
            width: b.AnimationItemDimensions.width,
            height: b.AnimationItemDimensions.height
        })
    },
    configureSymbolAnimation: function (d) {
        var c = this, a = Resources.readData("spriteConfigurations").borderAnimationSprite,
            f = Game.stage.view.animationManager.getSpriteSequence("borderAnimation"),
            e = Resources.readData("config").winSituationsDisplay.winSituationMinimumDisplayTime,
            b = Resources.readData("config").winSituationsDisplay.WIN_SYM_BORDER_ANIMATION_TIME;
        d.prop = Sys.apply(d.prop, {
            image: c.ANIMATION_IMAGES.borderAnimation,
            frameWidth: a.frameWidth,
            frameHeight: a.frameHeight,
            totalSpriteWidth: a.totalSpriteWidth,
            totalSpriteHeight: a.totalSpriteHeight,
            spriteArray: f,
            operations: {
                sprite: [{time: 0, value: 0}, {time: b, value: f.length - 1, goTo: 0}],
                fade: [{time: 0, value: 1}, {time: e, value: 1, fireEvent: {event: "view:animationComplete", scope: c}}]
            }
        });
        d.restore()
    },
    configureSymbolBackgroundAnimation: function (a) {
        var b = Resources.readData("config").winSituationsDisplay.BG_GLOW_ANIM_TIME;
        a.prop = Sys.apply(a.prop, {
            depth: Layering.Game.Slots.WinningSymbols.animationItems - 1,
            operations: {
                fade: [{time: 0, value: 1}, {time: 60, value: 1}, {time: b / 2, value: 0}, {
                    time: b - 60,
                    value: 1
                }, {time: b, value: 1, goTo: 0}]
            }
        });
        a.restore()
    },
    stop: function () {
        var a = this;
        a.animationList.stop();
        a.symbolBackgroundAnimationList.stop()
    },
    clearAnimations: function () {
        var a = this;
        a.isAllWinningSymbolsAnimationCreated = false;
        a.winSituationToggleCounter = 0
    }
};
TwinSpin.WinSituationsView = Sys.extend(Game.Slots.WinSituationsView, TwinSpin.WinSituationsView, "TwinSpin.WinSituationsView");
Sys.ns("TwinSpin");
TwinSpin.WinSituationsModel = {
    processServerResponse: function (d) {
        var c = this, b = "", a = false;
        if (d.wins && Sys.isArray(d.wins.winSituations)) {
            c.storeData("winSituations", d.wins.winSituations.slice(0));
            if (d.wins.winSituations.length === 1) {
                a = true
            }
            c.storeData("isSingleBetWayWin", a);
            b = d.wins.winType
        }
        c.storeData("winType", b)
    }
};
TwinSpin.WinSituationsModel = Sys.extend(Game.Slots.WinSituationsModel, TwinSpin.WinSituationsModel, "TwinSpin.WinSituationsModel");
Sys.ns("TwinSpin");
TwinSpin.WinSituationsController = {
    setupEvents: function () {
        var a = this;
        a.on({
            "notify:winSituationsDisplay.togglingWinSituation": a.animateWinSituation,
            "notify:winSituationsDisplay.abort": a.abort,
            "view:animationComplete": a.fireEvent.bind(a, "notify:winSituations.animationComplete"),
            "notify:stateHandler.enteringSpinningState": a.view.clearAnimations.bind(a.view)
        })
    }
};
TwinSpin.WinSituationsController = Sys.extend(Game.Slots.WinSituationsController, TwinSpin.WinSituationsController, "TwinSpin.WinSituationsController");
Sys.ns("TwinSpin");
TwinSpin.CoinWinView = {
    NUMBER_IMAGE: "winNumbers",
    BACKGROUND_IMAGE: "coinsWonBackground",
    BACKGROUND_DRAWING_FUNCTION: undefined,
    BACKGROUND_WIDTH: 326,
    BACKGROUND_HEIGHT: 130,
    BACKGROUND_TOP: 21,
    BACKGROUND_LEFT: -65,
    NUMBER_WIDTH: 43,
    NUMBER_HEIGHT: 53,
    createBackgroundItem: function () {
        var a = this, b = Game.stage.model.getSymbolConfiguration(0, 0);
        return new Animation.CanvasAnimationItem({
            width: a.BACKGROUND_WIDTH || b.width,
            height: a.BACKGROUND_HEIGHT || b.height,
            depth: Layering.Game.Slots.CoinWin.background,
            executeBefore: a.BACKGROUND_DRAWING_FUNCTION,
            image: a.BACKGROUND_IMAGE,
            top: a.BACKGROUND_HEIGHT / 3
        })
    },
    updateAnimationItems: function (a) {
        var b = this, c;
        c = Game.stage.model.getSymbolConfiguration(a.x, a.y);
        b.backgroundItem.prop.top = c.top + b.BACKGROUND_TOP;
        b.backgroundItem.prop.left = c.left + b.BACKGROUND_LEFT;
        b.textItem.prop.top = (c.top + b.BACKGROUND_TOP + b.BACKGROUND_HEIGHT / 2);
        b.textItem.prop.left = (c.left + b.BACKGROUND_LEFT + b.BACKGROUND_WIDTH / 2);
        b.textItem.prop.customProps.text = a.coins
    }
};
TwinSpin.CoinWinView = Sys.extend(Game.Slots.CoinWinView, TwinSpin.CoinWinView, "TwinSpin.CoinWinView");
Sys.ns("TwinSpin");
TwinSpin.CoinWinDesktopView = {
    NUMBER_IMAGE: "winNumbers",
    NUMBER_WIDTH: 44,
    NUMBER_HEIGHT: 54,
    BACKGROUND_WIDTH: 209,
    BACKGROUND_HEIGHT: 95,
    BACKGROUND_TOP: 35,
    BACKGROUND_LEFT: -13,
    createBackgroundItem: function () {
        var a = this, b = Game.stage.model.getSymbolConfiguration(0, 0);
        return new Animation.CanvasAnimationItem({
            width: a.BACKGROUND_WIDTH || b.width,
            height: a.BACKGROUND_HEIGHT || b.height,
            depth: Layering.Game.Slots.CoinWin.background,
            executeBefore: a.BACKGROUND_DRAWING_FUNCTION,
            image: a.BACKGROUND_IMAGE,
            top: a.BACKGROUND_HEIGHT / 3
        })
    },
    createTextItem: function () {
        var a = this, b = Animation.utils.text.createNumberDrawingProperties(a);
        return new Animation.CanvasAnimationItem({
            top: 0,
            left: 0,
            width: 0,
            height: 0,
            depth: Layering.Game.Slots.CoinWin.text,
            customProps: {text: "not set yet"},
            executeBefore: function (c) {
                var d = this;
                Animation.utils.text.drawTextFromImage(d.customProps.text, a.NUMBER_OFFSET, d.pivot.x, d.pivot.y, true, b.image, b.charMap, b.width, b.height, c)
            },
            operations: {
                fade: [{time: 0, value: 1, fireEvent: {event: "view:animationComplete", scope: a}}, {
                    time: 1,
                    value: 1,
                    goTo: 0
                }]
            }
        })
    },
    configureCoinWinItem: function (c, e) {
        var b = this, a, d, f;
        a = e.toString().length;
        d = a * b.NUMBER_WIDTH;
        f = b.textScaleFactor(d, b.BACKGROUND_WIDTH - 40);
        c.prop.operations.scale = [{time: 0, value: {scaleX: 0, scaleY: 0}}, {time: 10, value: {scaleX: f, scaleY: f}}];
        c.restore()
    },
    textScaleFactor: function (b, a) {
        var d = 1, c;
        c = (a / b);
        if (c > d) {
            c = d
        }
        return c
    },
    updateAnimationItems: function (a) {
        var b = this, c;
        c = Game.stage.model.getSymbolConfiguration(a.x, a.y);
        b.backgroundItem.prop.top = c.top + b.BACKGROUND_TOP;
        b.backgroundItem.prop.left = c.left + b.BACKGROUND_LEFT;
        b.textItem.prop.top = (c.top + b.BACKGROUND_TOP + b.BACKGROUND_HEIGHT / 2);
        b.textItem.prop.left = (c.left + b.BACKGROUND_LEFT + b.BACKGROUND_WIDTH / 2);
        b.configureCoinWinItem(b.textItem, a.coins);
        b.textItem.prop.customProps.text = a.coins
    }
};
TwinSpin.CoinWinDesktopView = Sys.extend(TwinSpin.CoinWinView, TwinSpin.CoinWinDesktopView, "TwinSpin.CoinWinDesktopView");
Sys.ns("TwinSpin");
TwinSpin.CoinWinModel = {
    parseWinSituation: function (l) {
        var c, a = [], f = [], g, b, e, d, h = 0, k;
        if (l.wins.type !== "coins") {
            return undefined
        }
        c = l.positions;
        for (e = 0; e < c.length; e++) {
            a.push(c[e].reelIndex)
        }
        for (e = 0; e < this.SYMBOL_ORDER_FREFERENCE.length; e++) {
            b = this.SYMBOL_ORDER_FREFERENCE[e];
            for (d = 0; d < a.length; d++) {
                if (a[d] === b) {
                    g = d;
                    f[h] = c[g].symbolIndex;
                    h++
                }
            }
            f.sort();
            if (f.indexOf(1) !== -1) {
                k = f.indexOf(1)
            } else {
                if (f.indexOf(0) !== -1) {
                    k = f.indexOf(0)
                } else {
                    k = f.indexOf(2)
                }
            }
            if (g >= 0) {
                return {x: b, y: f[k], coins: l.wins.coins}
            }
        }
    }
};
TwinSpin.CoinWinModel = Sys.extend(Game.Slots.CoinWinModel, TwinSpin.CoinWinModel, "TwinSpin.CoinWinModel");
Sys.ns("TwinSpin");
TwinSpin.Background = {
    getMixinDependencies: function () {
        return {fallback: ["animation"], mobile: ["animation", "orientation"], mobileLow: ["animation", "orientation"]}
    }, getDefaultMVCClasses: function () {
        return {controller: Game.BackgroundController, view: TwinSpin.BackgroundView}
    }
};
TwinSpin.Background = Sys.extend(Core.Module, TwinSpin.Background, "TwinSpin.Background");
Sys.ns("TwinSpin");
TwinSpin.BackgroundView = {
    BACKGROUND_IMAGE: "background",
    BACKGROUND_BETLINES: "betlinesBackground",
    REEL_UPPER_GLOW: "reelUpperGlow",
    initAnimations: function () {
        var b = this, d = new Animation.CanvasAnimationList({}), a = new Animation.CanvasAnimationItem({
            fullScreen: true,
            depth: Layering.Game.Background.image,
            image: b.BACKGROUND_IMAGE
        }), e = new Animation.CanvasAnimationItem({
            top: 249,
            left: 32,
            width: 1216,
            height: 223,
            depth: Layering.Game.Background.BetlineNoImage,
            image: b.BACKGROUND_BETLINES
        }), c = new Animation.CanvasAnimationItem({
            top: 75,
            left: 131,
            width: 1016,
            height: 149,
            depth: Layering.Game.Background.ReelUpperGlow,
            image: b.REEL_UPPER_GLOW
        });
        b.betlineItem = e;
        d.add(a);
        d.add(e);
        d.add(c);
        b.list = d;
        b.item = a;
        Game.stage.view.addToRenderLoop(d)
    },
    onPortrait: function () {
        var a = this;
        a.betlineItem.stop()
    },
    onLandscape: function () {
        var a = this;
        a.betlineItem.play()
    }
};
TwinSpin.BackgroundView = Sys.extend(Game.BackgroundView, TwinSpin.BackgroundView, "TwinSpin.BackgroundView");
Sys.ns("TwinSpin");
TwinSpin.BackgroundDesktopView = {
    REEL_AREA: "reelBackground", initAnimations: function () {
        var c = this, e = new Animation.CanvasAnimationList({}), b = new Animation.CanvasAnimationItem({
            fullScreen: true,
            depth: Layering.Game.Background.image,
            image: c.BACKGROUND_IMAGE
        }), d = new Animation.CanvasAnimationItem({
            top: 0,
            left: 0,
            width: 1280,
            height: 720,
            depth: Layering.Game.Background.ReelUpperGlow,
            image: c.REEL_UPPER_GLOW
        }), a = new Animation.CanvasAnimationItem({
            top: 56,
            left: 150,
            width: 980,
            height: 545,
            depth: Layering.Game.Background.image + 1,
            image: c.REEL_AREA
        });
        c.greyLayer = c.createGreyLayer();
        e.add(c.greyLayer);
        c.greyLayer.stop();
        c.reelItem = a;
        e.add(b);
        e.add(a);
        e.add(c.createNetEntProdLabelItem());
        e.add(d);
        c.list = e;
        c.item = b;
        Game.stage.view.addToRenderLoop(e)
    }, createGreyLayer: function () {
        var b = document.createElement("canvas"), a;
        b.width = 100;
        b.height = 100;
        a = b.getContext("2d");
        a.save();
        a.fillStyle = "rgba(0,0,0,0.2)";
        a.fillRect(0, 0, 100, 100);
        a.restore();
        return new Animation.CanvasAnimationItem({
            fullScreen: true,
            depth: TwinSpin.Layering.Background.greyLayer,
            image: b
        })
    }, enableGreyLayer: function () {
        this.list.play(this.greyLayer)
    }, disableGreyLayer: function () {
        this.greyLayer.stop()
    }, createNetEntProdLabelItem: function () {
        var c = "A NETENT PRODUCTION", b = "13px NetentStandardUI", a = -10,
            d = Animation.utils.text.createText(c, b, 0, [{fillStyle: "#ffffff"}]);
        return new Animation.Item({
            left: 1100,
            top: 8,
            width: d.width,
            height: d.height,
            depth: Layering.Game.Slots.Background.netEntProd,
            image: d
        })
    }, updateDepth: function (a) {
        this.reelItem.prop.depth = Layering.Game.Background.image + a
    }
};
TwinSpin.BackgroundDesktopView = Sys.extend(TwinSpin.BackgroundView, TwinSpin.BackgroundDesktopView, "TwinSpin.BackgroundDesktopView");
Sys.ns("TwinSpin");
TwinSpin.BackgroundController = {
    WINDOWS_TO_GREYOUT: ["paytable", "gameRules"], setupEvents: function () {
        var a = this;
        TwinSpin.BackgroundController.superclass.setupEvents.apply(this, arguments);
        a.on({
            "request:settingsWindow.openChild": a.checkEnableGreyArea,
            "request:settingsWindow.closeChild": a.checkDisableGreyArea,
            "request:settingsWindow.close": a.disableGreyAreaAndButton,
            "notify:settingsWindowCloseButton.click": a.disableGreyAreaAndButton
        })
    }, isWindowToGreyout: function (a) {
        return this.WINDOWS_TO_GREYOUT.indexOf(a) > -1 ? true : false
    }, checkEnableGreyArea: function (a) {
        var b = this;
        if (Platform.isDesktopDevice) {
            if (b.isWindowToGreyout(a)) {
                b.enableGreyArea()
            }
            b.view.updateDepth(-1)
        }
    }, checkDisableGreyArea: function (a) {
        var b = this;
        if (Platform.isDesktopDevice) {
            if (b.isWindowToGreyout(a)) {
                b.disableGreyArea()
            }
            b.view.updateDepth(1)
        }
    }, enableGreyArea: function () {
        var a = this;
        a.fireEvent("request:disableKeypad", a.MODULE_NAME);
        a.view.enableGreyLayer()
    }, disableGreyArea: function () {
        var a = this;
        a.fireEvent("request:enableBasicGamePanel", a.MODULE_NAME);
        a.view.disableGreyLayer()
    }, disableGreyAreaAndButton: function () {
        var a = this;
        if (Platform.isDesktopDevice) {
            a.disableGreyArea();
            a.view.updateDepth(1)
        }
    }
};
TwinSpin.BackgroundController = Sys.extend(Game.BackgroundController, TwinSpin.BackgroundController, "TwinSpin.BackgroundController");
Sys.ns("TwinSpin");
TwinSpin.LogoView = {SIZE_WIDTH: 475, SIZE_HEIGHT: 75, OFFSET_LEFT: 55};
TwinSpin.LogoView = Sys.extend(Game.LogoView, TwinSpin.LogoView, "TwinSpin.LogoView");
Sys.ns("TwinSpin");
TwinSpin.GameRulesController = {
    onDisableBasicGamePanel: function (b) {
        var a = this;
        if (b !== "background") {
            if (Sys.isDefined(a.view.onDisableBasicGamePanel)) {
                a.view.onDisableBasicGamePanel(b)
            }
        }
    }, onUserInputEnd: function (a) {
        if (Platform.isDesktopDevice && !this.view.onGreyAreaClick(a)) {
            this.onHideRequest()
        }
        this.view.onUserInputEnd.apply(this.view, arguments)
    }
};
TwinSpin.GameRulesController = Sys.extend(Interface.GameRulesController, TwinSpin.GameRulesController, "TwinSpin.GameRulesController");
Sys.ns("TwinSpin");
TwinSpin.GameRulesDesktopView = {
    setUpContent: function () {
        var a = this;
        a.containerWrapper = new Sys.Element({id: "containerWrapper", tag: "div", cls: a.WRAPPER_CSS});
        a.container = a.containerWrapper.add(new Sys.Element({id: "gameRules", tag: "div", cls: a.BASE_CSS}));
        a.rulesWrapper = a.container.add(new Sys.Element({
            id: "gameRules_rules",
            tag: "div",
            cls: a.RULES_WRAPPER_CSS
        }));
        a.rulesLoader = new Sys.Element({tag: "div", cls: a.LOADER_CSS + " " + a.LOADER_URI});
        a.createButton();
        a.fireEvent("view:addToContainer", "settingsWindow", {
            title: Services.languageManager.getText(Language.Keys.gameRules_uc),
            content: a.containerWrapper
        });
        a.fireEvent("view:addToNavigator", "desktopSettingsMenu", {order: 4, element: a.menuButton});
        a.addScrolling();
        if (!a.model.readData("disabled")) {
            a.enable()
        }
        a.hide();
        a.model.storeData("activetArea", [{x: 0, y: 68, width: 1280, height: 527}, {
            x: 0,
            y: 695,
            width: 1280,
            height: 200
        }])
    }, onGreyAreaClick: function (c) {
        var b = document.getElementById("canvasAnimationManager"),
            a = Sys.UserInputUtils.getCoordinatesRelativeToElement(c, b);
        return Sys.UserInputUtils.isUserInputInSegment(a, this.model.readData("activetArea"))
    }
};
TwinSpin.GameRulesDesktopView = Sys.extend(Interface.GameRulesDesktopView, TwinSpin.GameRulesDesktopView, "TwinSpin.GameRulesDesktopView");
Sys.override(Interface.PaytableBaseView, {
    SECTIONS: ["SpecialSymbols", "Features", "SymbolValues", "Betlines", "Disclaimer"],
    MEDIUM_WIN: {COLOR: "#6f90b8", SYMBOLS: ["SYM3", "SYM4", "SYM5", "SYM6", "SYM7"]},
    LOW_WIN: {COLOR: "#789788", SYMBOLS: ["SYM8", "SYM9", "SYM10", "SYM11", "SYM12", "SYM13"]},
    WILD_WIN: {COLOR: "red", SYMBOLS: ["SYM1"]},
    SPECIAL_SYM_CSS: "specialSymbolClass",
    DISCLAIMER_STRINGS: ["expWinWaysleftRightPT", "explanationBetWaysPartTwo", Language.Keys.paytable_voidAllPays],
    FEATURE_SYM: ["featureSymbol"],
    SYMBOL_TYPE: ["wild", "normal", "feature"],
    createSpecialSymbols: function () {
        var c = this, d = new Sys.Element({tag: "div", "class": c.SECTION_CSS});
        d.add(new Sys.Element({tag: "div", "class": c.HEADING_CSS + " utils_center_text" + c.SECTION_SEPARATOR_URI}));
        if (c.WILD_WIN.SYMBOLS.length > 0) {
            var a = new Sys.Element({tag: "table", "class": c.SPECIAL_SYM_CSS, style: "width:100%"});
            var b = a.add(new Sys.Element({tag: "tr"}));
            d.add(a);
            c.appendSymbolContainer(b, c.WILD_WIN.SYMBOLS[0], c.WILD_WIN.COLOR, undefined, "betlineWins", undefined, c.SYMBOL_TYPE[0])
        }
        c.container.add(d)
    },
    createFeatures: function () {
        var c = this, d = new Sys.Element({tag: "div", "class": c.SECTION_CSS + " " + c.SECTION_SEPARATOR_URI});
        d.add(new Sys.Element({
            tag: "div",
            textContent: Services.languageManager.getText("twinFeatureHeading"),
            "class": c.HEADING_CSS + " utils_center_text",
            style: "margin-left:-8%;"
        }));
        var b = new Sys.Element({tag: "table", "class": c.SPECIAL_SYM_CSS});
        var a = b.add(new Sys.Element({tag: "tr"}));
        d.add(b);
        c.appendSymbolContainer(a, c.FEATURE_SYM[0], c.WILD_WIN.COLOR, undefined, undefined, undefined, c.SYMBOL_TYPE[2]);
        c.container.add(d)
    },
    createSymbolValues: function () {
        var a = this, b = new Sys.Element({tag: "div", "class": a.SECTION_CSS + " " + a.SECTION_SEPARATOR_URI});
        b.add(new Sys.Element({
            tag: "div",
            textContent: Services.languageManager.getText("OCTsymbolPayout"),
            "class": a.HEADING_CSS + " utils_center_text"
        }));
        if (a.HIGH_WIN.SYMBOLS.length > 0) {
            b.add(a.createSymbolSubSection(a.HIGH_WIN.SYMBOLS, a.HIGH_WIN.COLOR))
        }
        if (a.MEDIUM_WIN.SYMBOLS.length > 0) {
            b.add(a.createSymbolSubSection(a.MEDIUM_WIN.SYMBOLS, a.MEDIUM_WIN.COLOR))
        }
        if (a.LOW_WIN.SYMBOLS.length > 0) {
            b.add(a.createSymbolSubSection(a.LOW_WIN.SYMBOLS, a.LOW_WIN.COLOR))
        }
        a.sectionElements.SymbolValues = b;
        a.container.add(b)
    },
    createSymbolSubSection: function (d, c) {
        var f = this, b = new Sys.Element({tag: "table", "class": "interface-paytable_symbols"}), a = d.length, g, e;
        for (e = -1; ++e < a;) {
            if (e % 2 === 0) {
                g = b.add(new Sys.Element({tag: "tr"}))
            }
            f.appendSymbolContainer(g, d[e], c, undefined, undefined, undefined, f.SYMBOL_TYPE[1])
        }
        return b
    },
    appendSymbolContainer: function (h, o, n, t, r, b, g) {
        function q() {
            h.add(new Sys.Element({tag: "td"}));
            var i = new Sys.Element({tag: "table", style: "margin:0 7%;width:100%;line-height:195%;"});
            var u = new Sys.Element({tag: "tr"});
            u.add(new Sys.Element({
                tag: "td",
                textContent: Services.languageManager.getText("MGwildHeadingLC"),
                "class": s.HEADING_CSS + " utils_center_text",
                style: "text-align: left;"
            }));
            i.add(u);
            u = new Sys.Element({tag: "tr"});
            u.add(new Sys.Element({
                tag: "td",
                textContent: Services.languageManager.getText("allWildSubstituteMGandFS")
            }));
            i.add(u);
            h.add(i)
        }

        function l() {
            h.add(new Sys.Element({tag: "td"}));
            var i = new Sys.Element({tag: "table", style: "padding:0 3%;"});
            var u = new Sys.Element({tag: "tr"});
            u.add(new Sys.Element({tag: "td", textContent: Services.languageManager.getText("cloneExplanation")}));
            i.add(u);
            u = new Sys.Element({tag: "tr"});
            u.add(new Sys.Element({tag: "td", textContent: Services.languageManager.getText("reelCloneNumbers")}));
            i.add(u);
            u = new Sys.Element({tag: "tr"});
            u.add(new Sys.Element({tag: "td", textContent: Services.languageManager.getText("cloneReelLocation")}));
            i.add(u);
            h.add(i)
        }

        function e() {
            a = h.add(new Sys.Element({tag: "td"})).add(new Sys.Element({
                tag: "ul",
                "class": "interface-paytable_symbolValues"
            }));
            for (p = -1; ++p < d;) {
                m = c[p];
                if (Sys.isDefined(m.value)) {
                    a.add(new Sys.Element({tag: "li", textContent: m.from, style: "width: 33%; color: " + n + ";"}));
                    a.add(new Sys.Element({tag: "li", textContent: m.value, style: "width: 66%;"}))
                }
            }
        }

        var f = Resources.readData("animationImages"), j = this.model.readData("symbolHeight"),
            k = h.add(new Sys.Element({tag: "td"})), a, m, p, s = this;
        if (g === s.SYMBOL_TYPE[1]) {
            var c = this.model.getCondensedInfo(o, t, r, b).sort(function (u, i) {
                return i.from - u.from
            }), d = c.length
        }
        if (Sys.isDefined(f[o])) {
            k.el.appendChild(f[o])
        }
        switch (g) {
            case s.SYMBOL_TYPE[0]:
                q();
                break;
            case s.SYMBOL_TYPE[1]:
                e();
                break;
            case s.SYMBOL_TYPE[2]:
                l();
                break
        }
    },
    getRowData: function (f, d, c, h) {
        var g, a = "";
        if (c === true) {
            g = "HWSTHeader"
        } else {
            g = ""
        }
        var e = new Sys.Element({tag: "tr", "class": g});
        for (var b = 0; b < f.length; b++) {
            if (Sys.isDefined(f[b].value)) {
                if (h === true && b === 0) {
                    a = "HWSTText"
                } else {
                    a = "HWSTEntry"
                }
                e.add(new Sys.Element({tag: "td", textContent: f[b][d], "class": a}))
            }
        }
        return e
    },
    createBetlines: function () {
        var b = this, a = Resources.readData("animationImages"),
            c = new Sys.Element({tag: "div", "class": b.SECTION_CSS + " utils_center_text " + b.SECTION_SEPARATOR_URI});
        c.add(new Sys.Element({
            tag: "div",
            textContent: Services.languageManager.getText("waysToWinHeading"),
            "class": b.HEADING_CSS
        }));
        if (Sys.isObj(a) && Sys.isDefined(a.betlines)) {
            c.el.appendChild(a.betlines)
        }
        b.sectionElements.Betlines = c;
        b.container.add(c)
    },
    createDisclaimer: function () {
        var c = this, d = new Sys.Element({
            tag: "div",
            "class": c.SECTION_CSS + " utils_center_text " + c.SECTION_SEPARATOR_URI + " DisclaimerText"
        }), a = c.DISCLAIMER_STRINGS, e = a.length, b;
        for (b = -1; ++b < e;) {
            d.add(new Sys.Element({tag: "div", textContent: Services.languageManager.getText(a[b])}))
        }
        c.sectionElements.Disclaimer = d;
        c.container.add(d)
    },
    sortObject: function (a) {
        a.sort(function (d, c) {
            return d.value - c.value
        });
        return a
    }
});
Sys.ns("TwinSpin");
TwinSpin.PaytableDesktopView = {
    KEYPAD_BUTTON_CONFIG: {
        dimensions: {x: 150, y: 624, width: 52, height: 52},
        buttonImages: {
            up: "paytableButtonUp",
            down: "paytableButtonDown",
            hover: "paytableButtonOver",
            disabled: "paytableButtonDisabled"
        },
        clickArea: {x: 150, y: 624, width: 48, height: 47}
    },
    SECTIONS: ["TwinReelFeature", "MediumWinPayouts", "LowWinPayouts"],
    TWIN_REEL_FEATURE_CSS: "twinreelfeature",
    MEDIUM_WIN_PAYOUTS_CSS: "mediumwinpayouts",
    LOW_WIN_PAYOUTS_CSS: "lowwinpayouts",
    WILD_SECTION_CSS: "wildsection",
    MEDIUM_WIN_PAYOUTS_SYMBOLS_ARRAY: ["SYM3", "SYM4", "SYM5", "SYM6", "SYM7"],
    LOW_WIN_PAYOUTS_SYMBOLS_ARRAY: ["SYM8", "SYM9", "SYM10", "SYM11", "SYM12", "SYM13"],
    SYMBOL_CSS_CONFIG: {
        SYM3: "sym3",
        SYM4: "sym4",
        SYM5: "sym5",
        SYM6: "sym6",
        SYM7: "sym7",
        SYM8: "sym8",
        SYM9: "sym9",
        SYM10: "sym10",
        SYM11: "sym11",
        SYM12: "sym12",
        SYM13: "sym13"
    },
    TWIN_REEL_FEATURE_STRINGS: ["twinFeatureHeading", "cloneExplanation", "reelCloneNumbers", "cloneReelLocation"],
    DISCLAIMER_STRINGS: ["expWinWaysleftRightPT", "explanationBetWaysPartTwo", "voidAllPays", "extraInfo"],
    PAYTABLE_MOVIE_SRC: "paytable_movie",
    createNavigation: function () {
        var a = this;
        a.navigation = new TwinSpin.PaytableCardNavigation({
            id: "paytableNavigation",
            numCards: this.SECTIONS.length,
            selectionCallback: a.onCardSelection.bind(a),
            closeCallback: a.onCloseCallback.bind(a)
        });
        a.subComponents = [a.navigation];
        a.container.add(a.navigation.getArrows());
        a.container.add(a.navigation.getIndicators())
    },
    hide: function () {
        Interface.PaytableDesktopView.superclass.hide.apply(this, arguments);
        var c = this, e = c.SECTIONS, d = c.sectionElements, a = e.length, b;
        for (b = -1; ++b < a;) {
            d[e[b]].el.style.display = "none"
        }
        c.navigation.disable(c.MODULE_NAME)
    },
    createSections: function () {
        Interface.PaytableDesktopView.superclass.createSections.apply(this, arguments);
        this.addDisclaimerDiv();
        this.addBetLinesDiv()
    },
    initAnimations: function () {
        var b = this, a = Sys.applyProperties({clickCallback: b.onButtonClick.bind(b)}, b.KEYPAD_BUTTON_CONFIG);
        if (Sys.isDefined(a.buttonLabel)) {
            a.buttonLabel.depth = Layering.Game.Slots.Keypad.paytable.label
        }
        if (Sys.isDefined(a.buttonLayoutParameters)) {
            a.buttonLayoutParameters.depth = Layering.Game.Slots.Keypad.paytable.button
        } else {
            a.dimensions.depth = Layering.Game.Slots.Keypad.paytable.button
        }
        b.button = new TwinSpin.CanvasButton(a);
        b.button.SOUND_CLICK = "paytableButton";
        b.button.id = "paytable";
        b.animationsReady = true
    },
    addBetLinesDiv: function () {
        var a = new Sys.Element({tag: "div", "class": "betlines"});
        this.container.add(a)
    },
    addDisclaimerDiv: function () {
        var f = this, h, d, a = f.DISCLAIMER_STRINGS, g = a.length, c, e = "", b;
        for (c = -1; ++c < g;) {
            e += Services.languageManager.getText(a[c]) + "<br/>"
        }
        d = new Sys.Element({tag: "div", "class": "disclaimerDiv", innerHTML: e});
        f.container.add(d)
    },
    createTwinReelFeature: function () {
        var f = this, c, a = new Sys.Element({tag: "div", "class": f.TWIN_REEL_FEATURE_CSS}),
            b = new Sys.Element({tag: "table"}), e = f.TWIN_REEL_FEATURE_STRINGS.length;
        b.add(new Sys.Element({
            tag: "th",
            textContent: Services.languageManager.getText(f.TWIN_REEL_FEATURE_STRINGS[0])
        }));
        for (c = 1; c < e; c++) {
            b.add(new Sys.Element({
                tag: "tr",
                textContent: Services.languageManager.getText(f.TWIN_REEL_FEATURE_STRINGS[c])
            }))
        }
        var d = new Sys.Element({tag: "div", "class": "paytable-videoContainer"});
        f.movieList = new Animation.List({});
        f.movieList.add(f.getMovieAnimation(d));
        Game.stage.view.addToRenderLoop(f.movieList);
        f.movieList.stop();
        a.add(d);
        a.add(b);
        f.sectionElements.TwinReelFeature = a;
        f.container.add(a)
    },
    getMovieAnimation: function (b) {
        var a = this;
        return new Animation.VideoItem({
            src: a.PAYTABLE_MOVIE_SRC,
            width: 360,
            height: 410,
            poster: "movie_poster",
            container: b
        })
    },
    createMediumWinPayouts: function () {
        var f = this, e, c, d, g, b, h, a = new Sys.Element({tag: "div", "class": f.MEDIUM_WIN_PAYOUTS_CSS});
        d = f.MEDIUM_WIN_PAYOUTS_SYMBOLS_ARRAY.length;
        c = new Sys.Element({tag: "table", "class": f.WILD_SECTION_CSS});
        h = new Sys.Element({tag: "tr"});
        h.add(new Sys.Element({tag: "td", textContent: Services.languageManager.getText("allWildSubstituteMGandFS")}));
        c.add(h);
        a.add(c);
        for (e = 0; e < d; e++) {
            g = f.MEDIUM_WIN_PAYOUTS_SYMBOLS_ARRAY[e];
            b = f.getSymbolInfoTable(this.model.getCondensedInfo(g), f.SYMBOL_CSS_CONFIG[g]);
            a.add(b)
        }
        f.sectionElements.MediumWinPayouts = a;
        f.container.add(a)
    },
    createLowWinPayouts: function () {
        var e = this, d, c, f, b, a = new Sys.Element({tag: "div", "class": e.LOW_WIN_PAYOUTS_CSS});
        c = e.LOW_WIN_PAYOUTS_SYMBOLS_ARRAY.length;
        for (d = 0; d < c; d++) {
            f = e.LOW_WIN_PAYOUTS_SYMBOLS_ARRAY[d];
            b = e.getSymbolInfoTable(this.model.getCondensedInfo(f), e.SYMBOL_CSS_CONFIG[f]);
            a.add(b)
        }
        e.sectionElements.LowWinPayouts = a;
        e.container.add(a)
    },
    getSymbolInfoTable: function (a, d, e) {
        var b = new Sys.Element({tag: "table", "class": d}), f, c;
        for (c = 2; c >= 0; c--) {
            f = new Sys.Element({tag: "tr"});
            f.add(new Sys.Element({
                tag: "td",
                style: "text-align: right",
                innerHTML: "<span class = 'fontColor'>" + a[c + 1].from + "</span>"
            }));
            f.add(new Sys.Element({
                tag: "td",
                style: "padding-left: 20px; text-align: left",
                innerHTML: a[c + 1].value
            }));
            b.add(f)
        }
        return b
    },
    setUpContent: function () {
        var a = this;
        a.model.setNumberOfPages(a.SECTIONS.length);
        a.model.setCurrentPage(1);
        a.createSections();
        a.createNavigation();
        a.model.storeData("activetArea", [{x: 0, y: 68, width: 1280, height: 527}, {
            x: 0,
            y: 695,
            width: 1280,
            height: 200
        }, {x: 150, y: 624, width: 52, height: 52}]);
        a.fireEvent("view:addToContainer", "settingsWindow", {title: "", content: a.container});
        a.addScrolling();
        if (!a.model.readData("disabled")) {
            a.enable()
        }
        a.hide()
    },
    show: function (b) {
        var c = this, a = 0;
        Interface.PaytableDesktopView.superclass.show.apply(c, arguments);
        if (Sys.isNumber(b) && b > 0 && b <= c.SECTIONS.length) {
            a = b - 1
        }
        c.movieList.items[0].play();
        c.movieList.play();
        c.navigation.selectCard(a);
        c.navigation.enable(c.MODULE_NAME)
    },
    onGreyAreaClick: function (c) {
        var b = document.getElementById("canvasAnimationManager"),
            a = Sys.UserInputUtils.getCoordinatesRelativeToElement(c, b);
        return Sys.UserInputUtils.isUserInputInSegment(a, this.model.readData("activetArea"))
    }
};
TwinSpin.PaytableDesktopView = Sys.extend(Interface.PaytableDesktopView, TwinSpin.PaytableDesktopView, "TwinSpin.PaytableDesktopView");
Sys.ns("TwinSpin");
TwinSpin.PaytableController = {
    onDisableBasicGamePanel: function (b) {
        var a = this;
        if (b !== "background") {
            if (Sys.isDefined(a.view.onDisableBasicGamePanel)) {
                a.view.onDisableBasicGamePanel(b)
            }
        }
    }, onUserInputEnd: function (a) {
        if (Platform.isDesktopDevice && !this.view.onGreyAreaClick(a)) {
            this.onHideRequest()
        }
        this.view.onUserInputEnd.apply(this.view, arguments)
    }
};
TwinSpin.PaytableController = Sys.extend(Interface.PaytableController, TwinSpin.PaytableController, "TwinSpin.PaytableController");
Sys.ns("TwinSpin");
TwinSpin.LinkedReels = {
    getMixinDependencies: function () {
        return ["serverResponse", "animation"]
    }, getStateChanges: function () {
        var a = this.model;
        return {
            animatingLinkedReels: {
                state: {
                    name: "AnimatingLinkedReels", execute: function (b) {
                    }, waitEvents: {"notify:linkedReels.animationComplete": false}
                }
            }, validateSpin: {
                queue: [function (b) {
                    if (a.shouldAnimate()) {
                        b.stateHandler.pushState(b.states.animatingLinkedReels)
                    }
                }]
            }
        }
    }, getDefaultMVCClasses: function () {
        return {
            model: TwinSpin.LinkedReelsModel,
            view: TwinSpin.LinkedReelsView,
            controller: TwinSpin.LinkedReelsController
        }
    }
};
TwinSpin.LinkedReels = Sys.extend(Core.Module, TwinSpin.LinkedReels, "TwinSpin.LinkedReels");
Sys.ns("TwinSpin");
TwinSpin.LinkedReelsModel = {
    processServerResponse: function (d) {
        var b = this, c = [], a = d.linkedreels;
        if (Sys.isDefined(a)) {
            c = b.generateRandomArrayBetween(a[0], a.last());
            b.storeData("winType", d.wins.winType)
        }
        b.storeData("linkedReels", c)
    }, generateRandomArrayBetween: function (h, f) {
        var e = [], b = f - h, d, a, g;
        d = a = Sys.Math.randomIntBetween(h, f);
        e.push(d);
        for (var c = 0; c < b; c++) {
            g = Sys.Math.randomIntBetween(0, 1);
            if (g === 0) {
                if (d > h) {
                    e.push(--d)
                } else {
                    e.push(++a)
                }
            } else {
                if (a < f) {
                    e.push(++a)
                } else {
                    e.push(--d)
                }
            }
        }
        return e
    }, shouldAnimate: function () {
        var b = this, a = b.readData("linkedReels");
        return Sys.isDefined(a) && a.length > 0 && !b.isState("abort")
    }, setupData: function () {
        var c = this, a = Resources.readData("config"), b = a.twinReelTimes, d = a.reelGroups["default"].spinTimes;
        c.storeData("basicSpinStopTimes", d.standard.reelStopDelays);
        c.storeData("quickSpinStopTimes", d.quickSpin.reelStopDelays);
        c.storeData("twinReelAddTimes", b.add);
        c.storeData("twinReelEndTimes", b.end);
        c.storeData("linkedReelsDelay", b.startDelay)
    }, updateSpinType: function () {
        var a = this;
        if (Services.settingsManager.getSetting("quickSpin")) {
            a.storeData("isQuickSpin", Services.settingsManager.getSetting("quickSpin"))
        } else {
            a.storeData("isQuickSpin", false)
        }
    }, getStartLinkTime: function () {
        var a = this;
        if (a.readData("isQuickSpin")) {
            return a.readData("linkedReelsDelay").quickSpin
        } else {
            return a.readData("linkedReelsDelay").standard
        }
    }, getLinkedReelsDurations: function () {
        var f = this, e = f.readData("linkedReels"), b = f.readData("twinReelAddTimes"),
            d = f.readData("twinReelEndTimes")[e.length - 3] || 0, a = [], g = function (h, i) {
                return h + i
            };
        for (var c = 1; c < e.length - 1; c++) {
            a.push((b.slice(0, c)).reduce(g))
        }
        return {durations: a, lastReelDuration: d}
    }, reset: function () {
        var a = this;
        a.storeData("linkedReels", []);
        a.setState("idle");
        a.updateSpinType()
    }
};
TwinSpin.LinkedReelsModel = Sys.extend(Core.Model, TwinSpin.LinkedReelsModel, "TwinSpin.LinkedReelsModel");
Sys.ns("TwinSpin");
TwinSpin.LinkedReelsController = {
    setupEvents: function () {
        var a = this;
        a.settedReels = [];
        a.on({
            "view:startLinking": a.startLinking,
            "view:animationComplete": a.animationComplete,
            "view:setLinkedReels": a.setReels,
            "view:playTwinReel": a.playTwinReel,
            "view:playEndSound": a.playEndSound,
            "view:play": a.playSound,
            "notify:stateHandler.enteringAnimatingLinkedReelsState": a.onEnteringLinkedReelsState,
            "notify:stateHandler.enteringBigWinState": a.stopAnimations,
            "notify:stateHandler.enteringStandardWinPresentationState": a.stopAnimations,
            "notify:stateHandler.enteringSpinningState": a.spinningStarted,
            "notify:spin.reelStopStarted": a.onReelStopStarted,
            "notify:quickStopper.quickStop": a.abort,
            "notify:spin.spinAnimationComplete": a.stopLegacySounds
        })
    }, stopLegacySounds: function () {
        this.fireEvent("request:audioPlayer.stop", "reelTwinEndSndLegacy");
        this.fireEvent("request:audioPlayer.stop", "spinBtnSound");
        this.fireEvent("request:audioPlayer.stop", "spinStart")
    }, onReelStopStarted: function (a) {
        var b = this;
        if (b.model.readData("linkedReels").indexOf(a) !== -1 && !b.model.isState("stopping")) {
            b.model.setState("stopping");
            b.canAbort = false
        }
    }, onServerResponse: function (c) {
        if (Sys.isDefined(c.linkedreels)) {
            var b = this, a = Date.now() - b.spinStartTime;
            b.model.processServerResponse(c);
            if (b.model.isState("abort")) {
                b.view.abort()
            } else {
                b.view.setStartLinkingTimeout(a)
            }
        }
    }, spinningStarted: function () {
        var a = this;
        a.spinStartTime = Date.now();
        a.reset();
        a.view.stopAnimation()
    }, startLinking: function () {
        this.model.setState("animate")
    }, onEnteringLinkedReelsState: function () {
        var a = this;
        a.canAbort = true
    }, setReels: function (c) {
        var b = this;
        var a = c.toString();
        if (!b.settedReels.contains(a)) {
            b.settedReels.push(a);
            b.fireEvent("notify:linkedReels.SetReels", c)
        }
    }, animationComplete: function () {
        this.fireEvent("notify:linkedReels.animationComplete")
    }, stopAnimations: function () {
        this.animationComplete();
        this.view.stopAnimation()
    }, reset: function () {
        var a = this;
        a.settedReels = [];
        a.model.reset();
        a.isQuickStop = false;
        a.lastPlayed = 0;
        a.canAbort = false
    }, abort: function () {
        var a = this;
        a.isQuickStop = true;
        if (a.canAbort) {
            a.view.abort();
            a.animationComplete()
        }
        a.model.setState("abort")
    }, playSound: function (a) {
        this.fireEvent("request:audioPlayer.play", a)
    }, playTwinReel: function (b) {
        var a = this;
        if (a.isQuickStop) {
            a.stopTwinReelSound();
            if (a.model.readData("linkedReels").length > 2) {
                a.playSound({name: "reelTwinQuickStop", id: "reelTwinQuickStop"})
            } else {
                a.playSound({name: "reelTwinSnd", id: "reelTwin2Snd"})
            }
            return
        }
        if (a.lastPlayed !== b) {
            a.stopTwinReelSound();
            a.playSound({name: "reelTwin" + b + "Snd", id: "reelTwinSnd"});
            a.lastPlayed = b
        }
    }, playEndSound: function () {
        var a = this;
        a.stopTwinReelSound();
        if (a.model.readData("linkedReels").length > 2) {
            a.playSound({name: "reelTwinEndSnd", id: "reelTwinEndSnd"});
            a.playSound({name: "reelTwinEnd", id: "reelTwinEndSndLegacy"})
        }
    }, stopTwinReelSound: function () {
        this.fireEvent("request:audioPlayer.stop", "reelTwinSnd")
    }
};
TwinSpin.LinkedReelsController = Sys.extend(Core.Controller, TwinSpin.LinkedReelsController, "TwinSpin.LinkedReelsController");
Sys.ns("TwinSpin");
TwinSpin.LinkedReelsView = {
    SPARKLES_WIDTH: 193,
    SPARKLES_HEIGHT: 549,
    WALKING_LIGHTS_WIDTH: 25,
    WALKING_LIGHTS_HEIGHT: 564,
    BACKGROUND_ANIMATION_WIDTH: 236,
    BACKGROUND_ANIMATION_HEIGHT: 589,
    BACKGROUND_BIG_ANIMATION_WIDTH: 1173,
    BACKGROUND_BIG_ANIMATION_HEIGHT: 742,
    SPLASH_WIDTH: 277,
    SPLASH_HEIGHT: 633,
    BACKGROUND_BIG_LEFT_OFFSET: 78,
    BACKGROUND_BIG_TOP_OFFSET: 96,
    BACKGROUND_LEFT_OFFSET: 22,
    BACKGROUND_TOP_OFFSET: 23,
    SPLASH_LEFT_OFFSET: 40,
    SPLASH_TOP_OFFSET: 41,
    WALKING_OUTRO_TOP_OFFSET: 5,
    WALKING_OUTRO_LL_OFFSET: 3,
    WALKING_OUTRO_RL_OFFSET: 19,
    WALKING_LIGHTS_OFFSET: {left: {x: 7, y: 4}, right: {x: 22, y: 4}},
    REELS: 5,
    SPARKLES: ["sparkles1", "sparkles2", "sparkles3"],
    FPS: 33,
    initAnimations: function () {
        var a = this;
        a.initializeAnimationList();
        a.initializeReels();
        a.initializeWalkingLights();
        a.initializeWalkingLightOutros();
        a.initializeSparkles();
        a.initializeSplashes();
        a.initializeBackgrounds()
    },
    setupEvents: function () {
        var a = this;
        a.on({
            "model:animate": a.animate,
            "model:stopping": a.endAnimation,
            "view:setLinkedReels": a.onReelLinked,
            "view:startFadeOut": a.fadeOut
        })
    },
    initializeAnimationList: function () {
        var a = this;
        a.list = new Animation.CanvasAnimationList({});
        Game.stage.view.addToRenderLoop(a.list);
        a.createFakeAnimation()
    },
    initializeReels: function () {
        var c = this, a = function () {
            return new Animation.CanvasAnimationItem({
                operations: {
                    fade: [{time: 0, value: 0}, {
                        time: 50,
                        value: 0,
                        fireEvent: {event: "view:setLinkedReels", scope: c, argument: undefined}
                    }, {time: 100, value: 0, fireEvent: {event: "", scope: c}}]
                }
            })
        };
        c.reelAnimations = [];
        for (var b = 0; b < 4; b++) {
            c.reelAnimations.push(a())
        }
    },
    addReels: function () {
        var d = this, c = d.model.readData("linkedReels"), g = d.model.getLinkedReelsDurations(), e, f, b;
        e = d.reelAnimations[0];
        f = e.prop.operations.fade;
        f[1].fireEvent.argument = c.slice(0, 2);
        d.list.add(e);
        if (g.durations.length === 0) {
            f[2].fireEvent.event = "view:animationComplete";
            return
        } else {
            f[2].fireEvent.event = ""
        }
        for (var a = 1; a <= g.durations.length; a++) {
            e = d.reelAnimations[a];
            f = e.prop.operations.fade;
            b = (a === g.durations.length);
            f[1].time = g.durations[a - 1];
            f[1].fireEvent.argument = c.slice(0, a + 2);
            f[2].time = g.durations[a - 1] + (b ? g.lastReelDuration : 50);
            f[2].fireEvent.event = b ? "view:animationComplete" : "";
            d.list.add(e)
        }
    },
    createFakeAnimation: function () {
        var a = this;
        a.fakeAnimationList = new Animation.CanvasAnimationList({});
        a.fakeReelAnimationItem = new Animation.CanvasAnimationItem({});
        a.fakeAnimationList.add(a.fakeReelAnimationItem);
        Game.stage.view.addToRenderLoop(a.fakeAnimationList);
        a.fakeAnimationList.stop()
    },
    setStartLinkingTimeout: function (a) {
        var b = this, c = b.model.getStartLinkTime();
        if (a >= c) {
            b.fireEvent("view:startLinking");
            return
        } else {
            c = c - a
        }
        b.fakeReelAnimationItem.prop.operations = {
            fade: [{time: 0, value: 0}, {
                time: c,
                value: 0,
                fireEvent: {event: "view:startLinking", scope: b}
            }]
        };
        b.fakeReelAnimationItem.restore();
        b.fakeAnimationList.play(b.fakeReelAnimationItem)
    },
    initializeWalkingLights: function () {
        var b = this, a = Resources.readData("spriteConfigurations"),
            d = Game.stage.view.animationManager.getSpriteSequence("walkingLights"), c = function (e) {
                return new Animation.CanvasAnimationItem({
                    top: 0,
                    left: 0,
                    width: b.WALKING_LIGHTS_WIDTH,
                    height: b.WALKING_LIGHTS_HEIGHT,
                    depth: TwinSpin.Layering.WalkingLights.image,
                    image: e,
                    frameWidth: a[e].frameWidth,
                    frameHeight: a[e].frameHeight,
                    totalSpriteWidth: a[e].totalSpriteWidth,
                    totalSpriteHeight: a[e].totalSpriteHeight,
                    spriteArray: d,
                    operations: {sprite: [{time: 0, value: 0}, {time: 250, value: d.length - 1, goTo: 0}]}
                })
            };
        b.walkingLights = [[c("walking_Lights_1"), c("walking_Lights_1")], [c("walking_Lights_2"), c("walking_Lights_2")]];
        b.walkingLightsList = new Animation.CanvasAnimationList({});
        Game.stage.view.addToRenderLoop(b.walkingLightsList);
        b.walkingLightsList.addItems(b.walkingLights[0]);
        b.walkingLightsList.addItems(b.walkingLights[1]);
        b.walkingLightsList.stop()
    },
    initializeWalkingLightOutros: function () {
        var c = this, a = Resources.readData("spriteConfigurations"),
            d = Game.stage.view.animationManager.getSpriteSequence("walkingLightsOutro"), b = function (g, f) {
                var e = f ? "view:startFadeOut" : "";
                return new Animation.CanvasAnimationItem({
                    top: 0,
                    left: 0,
                    width: c.WALKING_LIGHTS_WIDTH,
                    height: c.WALKING_LIGHTS_HEIGHT,
                    depth: TwinSpin.Layering.WalkingLights.image,
                    image: g,
                    frameWidth: a[g].frameWidth,
                    frameHeight: a[g].frameHeight,
                    totalSpriteWidth: a[g].totalSpriteWidth,
                    totalSpriteHeight: a[g].totalSpriteHeight,
                    spriteArray: d,
                    operations: {
                        sprite: [{time: 0, value: 0}, {
                            time: 250,
                            value: d.length - 1,
                            fireEvent: {event: e, scope: c}
                        }]
                    }
                })
            };
        c.walkingLightOutros = [[b("walking_Lights_Outro1", true), b("walking_Lights_Outro1")], [b("walking_Lights_Outro2", true), b("walking_Lights_Outro2")]]
    },
    addWalkingLightsAnimations: function (c) {
        var g = this, a, e, b = Game.stage.model.getSymbolConfiguration(c.min(), 0),
            f = Game.stage.model.getSymbolConfiguration(c.max(), 0), d = 0, h = g.WALKING_LIGHTS_OFFSET;
        if (c.length === g.REELS) {
            g.walkingLightsList.stop();
            return
        }
        if (c.length === g.REELS - 1) {
            d = 1
        }
        a = g.walkingLights[d][0];
        e = g.walkingLights[d][1];
        a.prop.left = b.left - h.left.x;
        a.prop.top = b.top - h.left.y;
        e.prop.left = f.left + f.width - h.right.x;
        e.prop.top = f.top - h.right.y;
        if (!a.isRunning()) {
            g.walkingLightsList.stop();
            g.walkingLightsList.play(a);
            g.walkingLightsList.play(e)
        }
    },
    initializeSparkles: function () {
        var c = this;
        c.sparkleAnimations = [];
        for (var b = 0; b < c.REELS; b++) {
            var a = Game.stage.model.getSymbolConfiguration(b, 0);
            c.sparkleAnimations.push(new Animation.CanvasAnimationItem({
                top: a.top + 5,
                left: a.left,
                width: c.SPARKLES_WIDTH,
                height: c.SPARKLES_HEIGHT,
                depth: TwinSpin.Layering.Sparkles.image
            }))
        }
        c.sparkleAnimationsList = new Animation.CanvasAnimationList({});
        Game.stage.view.addToRenderLoop(c.sparkleAnimationsList);
        c.sparkleAnimationsList.addItems(c.sparkleAnimations);
        c.sparkleAnimationsList.stop()
    },
    addSparkles: function (a) {
        var d = this, c = a.length, b;
        switch (c) {
            case d.REELS:
                b = "sparkles3";
                break;
            case 4:
                b = "sparkles2";
                break;
            default:
                b = "sparkles1"
        }
        d.sparkleAnimationsList.stop();
        Sys.each(a, function (f) {
            var g = Game.stage.view.animationManager.getSpriteSequence(b),
                e = Resources.readData("spriteConfigurations");
            d.setOpacity(d.sparkleAnimations[f]);
            Sys.applyProperties(d.sparkleAnimations[f].prop, {
                image: b,
                totalSpriteWidth: e[b].totalSpriteWidth,
                frameWidth: e[b].frameWidth,
                frameHeight: e[b].frameHeight,
                spriteArray: g,
                operations: {
                    sprite: [{time: 0, value: 0}, {
                        time: Math.round((1000 / d.FPS) * g.length),
                        value: g.length - 1,
                        goTo: 0
                    }]
                }
            });
            d.sparkleAnimations[f].restore();
            d.sparkleAnimationsList.play(d.sparkleAnimations[f])
        })
    },
    initializeSplashes: function () {
        var c = this, a, e, d;
        c.splashList = new Animation.CanvasAnimationList({});
        c.splashItems = [];
        Game.stage.view.addToRenderLoop(c.splashList);
        for (var b = 0; b < c.REELS; b++) {
            a = Game.stage.model.getSymbolConfiguration(b, 0);
            d = a.left;
            e = a.top;
            c.splashItems.push(new Animation.CanvasAnimationItem({
                id: "splash" + b,
                top: e - c.SPLASH_TOP_OFFSET,
                left: d - c.SPLASH_LEFT_OFFSET,
                width: c.SPLASH_WIDTH,
                height: c.SPLASH_HEIGHT,
                image: "twin-flash",
                depth: TwinSpin.Layering.Splashes.image,
                operations: {
                    fade: [{time: 0, value: 0}, {time: 60, value: 0.8}, {time: 100, value: 0.8}, {
                        time: 400,
                        value: 0
                    }]
                }
            }))
        }
        c.splashList.addItems(c.splashItems);
        c.splashList.stop()
    },
    onReelLinked: function (a) {
        var b = this;
        b.playSplashAnimation(a);
        b.addBackgrounds(a);
        b.addWalkingLightsAnimations(a);
        b.addSparkles(a);
        b.fireEvent("view:playTwinReel", a.length)
    },
    playSplashAnimation: function (a) {
        var c = this, b = c.model.readData("linkedReels"), d;
        Sys.each(a, function (e) {
            d = c.splashItems[e];
            d.restore();
            c.splashList.play(d)
        })
    },
    initializeBackgrounds: function () {
        var c = this, e, d, a, f = function (g) {
            var h = g.image || "reel_Background_1";
            return new Animation.CanvasAnimationItem({
                width: g.width,
                height: g.height,
                depth: TwinSpin.Layering.Background.image,
                image: h,
                left: g.left,
                top: g.top
            })
        };
        c.backgroundAnimationItems = [];
        for (var b = 0; b < c.REELS; b++) {
            a = Game.stage.model.getSymbolConfiguration(b, 0);
            d = a.top - c.BACKGROUND_TOP_OFFSET;
            e = a.left - c.BACKGROUND_LEFT_OFFSET;
            c.backgroundAnimationItems.push(f({
                width: c.BACKGROUND_ANIMATION_WIDTH,
                height: c.BACKGROUND_ANIMATION_HEIGHT,
                left: e,
                top: d
            }))
        }
        a = Game.stage.model.getSymbolConfiguration(0, 0);
        d = a.top - c.BACKGROUND_BIG_TOP_OFFSET;
        e = a.left - c.BACKGROUND_BIG_LEFT_OFFSET;
        c.backgrounAllItem = f({
            width: c.BACKGROUND_BIG_ANIMATION_WIDTH,
            height: c.BACKGROUND_BIG_ANIMATION_HEIGHT,
            left: e,
            top: d,
            image: "reel_Background_4"
        });
        c.backgroundList = new Animation.CanvasAnimationList({});
        Game.stage.view.addToRenderLoop(c.backgroundList);
        c.backgroundList.addItems(c.backgroundAnimationItems);
        c.backgroundList.add(c.backgrounAllItem);
        c.backgroundList.stop()
    },
    addBackgrounds: function (a) {
        var c = this, b = a.length;
        if (b === c.REELS) {
            c.backgrounAllItem.restore();
            c.backgroundList.stop();
            c.backgroundList.play(c.backgrounAllItem)
        } else {
            Sys.each(a, function (d) {
                var e = c.backgroundAnimationItems[d];
                e.restore();
                c.setOpacity(e);
                e.prop.image = "reel_Background_" + (b - 1);
                c.backgroundList.play(e)
            })
        }
    },
    setOpacity: function (a, b) {
        b = b || 1;
        a.prop.opacity = b;
        a.prop.ownOpacity = b
    },
    animate: function () {
        var a = this;
        a.startTime = Date.now();
        a.clearAnimationList();
        a.addReels();
        a.setOpacity(a.list);
        a.list.play()
    },
    addLastReels: function () {
        var a = this.model.readData("linkedReels");
        this.fireEvent("view:setLinkedReels", a)
    },
    addWalkingLightsOutro: function () {
        var h = this, g = h.model.readData("linkedReels"), e = Game.stage.model.getSymbolConfiguration(g.min(), 0),
            a = e.left - h.WALKING_OUTRO_LL_OFFSET, c = e.top + h.WALKING_OUTRO_TOP_OFFSET,
            d = Game.stage.model.getSymbolConfiguration(g.max(), 0), i = d.left + d.width - h.WALKING_OUTRO_RL_OFFSET,
            f = d.top + h.WALKING_OUTRO_TOP_OFFSET;
        h.walkingLightsList.stop();
        if (g.length < h.REELS) {
            var j = g.length === 4 ? h.walkingLightOutros[1] : h.walkingLightOutros[0], b = j[0];
            Sys.applyProperties(b.prop, {top: c, left: a});
            h.list.add(b);
            h.list.play(b);
            b = j[1];
            Sys.applyProperties(b.prop, {top: f, left: i});
            h.list.add(b);
            h.list.play(b)
        }
    },
    fadeOut: function () {
        var a = this, b = function (c) {
            c.prop.operations.fade = [{time: 0, value: 1}, {time: 700, value: 0}];
            c.restore();
            c.play()
        };
        Sys.each(a.backgroundList.items, function (c) {
            if (c.isRunning()) {
                b(c)
            }
        });
        Sys.each(a.sparkleAnimationsList.items, function (c) {
            if (c.isRunning()) {
                b(c)
            }
        });
        a.fireEvent("view:playEndSound")
    },
    stopAnimation: function () {
        var a = this;
        a.list.stop();
        a.backgroundList.stop();
        a.sparkleAnimationsList.stop();
        Sys.each(a.backgroundList.items, function (b) {
            b.prop.operations = {}
        });
        Sys.each(a.sparkleAnimationsList.items, function (b) {
            b.prop.operations = {}
        })
    },
    abort: function () {
        var a = this;
        a.clearAnimationList();
        a.addLastReels();
        a.fakeAnimationList.stop()
    },
    clearAnimationList: function () {
        this.list.restore();
        this.list.items.length = 0
    },
    endAnimation: function () {
        var b = this, a = b.model.readData("linkedReels");
        b.addWalkingLightsOutro();
        if (a.length === b.REELS) {
            b.fireEvent("view:playEndSound")
        }
    }
};
TwinSpin.LinkedReelsView = Sys.extend(Core.View, TwinSpin.LinkedReelsView, "TwinSpin.LinkedReelsView");
Sys.ns("TwinSpin");
TwinSpin.LinkedReelsDesktopView = {
    SPARKLES_WIDTH: 181,
    SPARKLES_HEIGHT: 513,
    WALKING_LIGHTS_WIDTH: 24,
    WALKING_LIGHTS_HEIGHT: 526,
    BACKGROUND_ANIMATION_WIDTH: 219,
    BACKGROUND_ANIMATION_HEIGHT: 547,
    BACKGROUND_BIG_ANIMATION_WIDTH: 1088,
    BACKGROUND_BIG_ANIMATION_HEIGHT: 668,
    BACKGROUND_BIG_LEFT_OFFSET: 75,
    BACKGROUND_BIG_TOP_OFFSET: 64,
    BACKGROUND_LEFT_OFFSET: 22,
    BACKGROUND_TOP_OFFSET: 15,
    SPLASH_WIDTH: 256,
    SPLASH_HEIGHT: 586,
    SPLASH_LEFT_OFFSET: 40,
    SPLASH_TOP_OFFSET: 35,
    WALKING_OUTRO_TOP_OFFSET: -4,
    WALKING_OUTRO_LL_OFFSET: 7,
    WALKING_OUTRO_RL_OFFSET: 19
};
TwinSpin.LinkedReelsDesktopView = Sys.extend(TwinSpin.LinkedReelsView, TwinSpin.LinkedReelsDesktopView, "TwinSpin.LinkedReelsDesktopView");
Core.Slots.ReelGroup.prototype.createSymbolBuffer = function (c, b, a) {
    this.symbolBuffer = new TwinSpin.SymbolBuffer(c, b, a)
};
Core.Slots.ReelGroup.prototype.setLinkedReels = function (a) {
    this.symbolBuffer.setLinkedReels(a)
};
Sys.ns("TwinSpin");
TwinSpin.SymbolBuffer = {
    setLinkedReels: function (a) {
        var b = this;
        if (Sys.isDefined(a)) {
            Sys.each(a, function (c) {
                b.workspace.linkedReels[c] = true
            });
            Sys.each(b.fillers, function (c) {
                if (Sys.isDefined(c.setLinkedReels)) {
                    c.setLinkedReels(a)
                }
            })
        } else {
            b.workspace.linkedReels = Sys.utils.initArray(b.workspace.pipeCount, false);
            Sys.each(b.fillers, function (c) {
                if (Sys.isDefined(c.reset)) {
                    c.reset()
                }
            })
        }
    }
};
TwinSpin.SymbolBuffer = Sys.extend(Core.Slots.SymbolBuffer, TwinSpin.SymbolBuffer, "TwinSpin.SymbolBuffer");
Sys.ns("TwinSpin");
TwinSpin.SimpleOutcomeFiller = {
    updateStoppingDistances: function (a) {
        var c, d = this, b;
        for (c = 0; c < d.workspace.linkedReels.length; c++) {
            if (d.workspace.linkedReels[c]) {
                if (!Sys.isDefined(b)) {
                    b = a[c]
                }
                a[c] = b
            }
        }
    }
};
TwinSpin.SimpleOutcomeFiller = Sys.extend(Core.Slots.SimpleOutcomeFiller, TwinSpin.SimpleOutcomeFiller, "TwinSpin.SimpleOutcomeFiller");
Sys.ns("TwinSpin");
TwinSpin.SimpleFakeReelFiller = {
    setLinkedReels: function (a) {
        var f = this, b = Resources.readData("config").reelSets, d = b.basic, g = Sys.clone(d.fakeReels),
            e = b.linkedReels, c;
        a.sort();
        Sys.each(f.workspace.linkedReels, function (i, h) {
            if (i) {
                g[h] = e[a[0] + "-" + a[a.length - 1]];
                if (!Sys.isDefined(c)) {
                    c = f.reelPositions[h]
                }
                if (c >= g[h].length) {
                    c = 0
                }
            }
        });
        f.reelStrips = g;
        Sys.each(f.workspace.linkedReels, function (i, h) {
            if (i) {
                f.reelPositions[h] = c
            }
        })
    }, reset: function () {
        var c = this, a = Resources.readData("config").reelSets, b = a.basic;
        c.reelStrips = Sys.clone(b.fakeReels);
        Sys.each(c.reelPositions, function (d, e) {
            if (d >= c.reelStrips[e].length) {
                c.reelPositions[e] = 0
            }
        })
    }
};
TwinSpin.SimpleFakeReelFiller = Sys.extend(Core.Slots.SimpleFakeReelFiller, TwinSpin.SimpleFakeReelFiller, "TwinSpin.SimpleFakeReelFiller");
Sys.ns("TwinSpin");
TwinSpin.BufferedSpinController = {
    setupEvents: function () {
        var a = this;
        TwinSpin.BufferedSpinController.superclass.setupEvents.apply(a, arguments);
        a.on({"notify:stateHandler.leavingStoppedState": a.switchToBasicSet, "notify:linkedReels.SetReels": a.setReels})
    }, setReels: function (a) {
        this.view.setLinkedReels(a)
    }, switchToBasicSet: function () {
        this.view.setLinkedReels()
    }, onSettingsChanged: function (a, c) {
        var b = this;
        TwinSpin.BufferedSpinController.superclass.onSettingsChanged.apply(b, arguments);
        if (a === "autoPlayNrSpins") {
            b.model.storeData("isAutoPlay", c > 0)
        }
    }
};
TwinSpin.BufferedSpinController = Sys.extend(Core.Slots.BufferedSpinController, TwinSpin.BufferedSpinController, "TwinSpin.BufferedSpinController");
Sys.ns("TwinSpin");
TwinSpin.BufferedSpinView = {
    SPIN_SOUNDS: {
        basic: {
            spinStart: {id: "spinStart", name: "spinStart"},
            reelSpin: {id: "reelSpin", name: "reelSpin", loop: true},
            reelBounce: {id: "reelBounce", name: "reelBounce"},
            reelStop: {id: "reelStop", name: "reelStop"}
        },
        autoPlay: {
            normalSpin: {spinStart: {id: "spinStart", name: "autoplayNormal"}},
            quickSpin: {spinStart: {id: "spinStart", name: "autoplayQuick"}}
        }
    }, setLinkedReels: function (a) {
        this.reelGroups[0].setLinkedReels(a)
    }, getSoundConfig: function (b) {
        var e = this, d = e.model.readData("currentReelSet"), f = e.SPIN_SOUNDS, g = f.basic[b],
            a = Services.settingsManager.getSetting("quickSpin") ? "quickSpin" : "normalSpin",
            c = e.model.readData("isAutoPlay");
        if (Sys.isDefined(f[d]) && Sys.isDefined(f[d][b])) {
            g = f[d][b]
        }
        if (c && Sys.isDefined(f.autoPlay[a][b])) {
            g = f.autoPlay[a][b]
        }
        return g
    }
};
TwinSpin.BufferedSpinView = Sys.extend(Core.Slots.BufferedSpinView, TwinSpin.BufferedSpinView, "TwinSpin.BufferedSpinView");
Sys.ns("TwinSpin");
TwinSpin.BigWinCountUpController = {
    stop: function () {
        var a = this;
        if (!a.model.isState("stopped")) {
            a.model.setState("stopped");
            a.view.stop();
            a.fireEvent("notify:" + a.MODULE_NAME + ".hidden", {manualSkip: a.skipped})
        }
    }, showTotal: function (a) {
        if (!this.model.isState("showingTotal")) {
            this.view.showTotal(a);
            this.model.setState("showingTotal");
            this.skipped = a.manualSkip
        }
    }
};
TwinSpin.BigWinCountUpController = Sys.extend(Core.CountUpController, TwinSpin.BigWinCountUpController, "TwinSpin.BigWinCountUpController");
Sys.ns("TwinSpin");
TwinSpin.BigWinCountUpView = {
    NUMBER_IMAGE: "bigWinNumbers",
    NUMBER_WIDTH: 141,
    NUMBER_HEIGHT: 176,
    COUNT_UP_TOP: 350,
    COUNT_UP_EASING_TYPE: "ease-in",
    configureStartAnimation: function (b) {
        var a = this;
        var c = 640;
        a.countUpItem.prop.ownOpacity = 1;
        a.countUpItem.prop.operations.translate = [{time: 0, value: {top: 0, left: c}}, {
            time: 332,
            value: {top: 480, left: c}
        }, {time: 600, value: {top: 360, left: c}}];
        a.countUpItem.prop.operations.scale = [{time: 0, value: {scaleX: 0.4, scaleY: 0.4}}, {
            time: 100,
            value: {scaleX: 0.4, scaleY: 0.4}
        }, {time: 350, value: {scaleX: 0.4, scaleY: 0.4}}, {time: 600, value: {scaleX: 1, scaleY: 1}}, {
            time: 650,
            value: {scaleX: 1.2, scaleY: 1.2}
        }]
    },
    configureEndAnimation: function (b) {
        var a = this;
        a.countUpItem.prop.left = 640;
        a.countUpItem.prop.top = 360;
        delete a.countUpItem.prop.operations.translate;
        a.countUpItem.prop.operations.scale = [{time: 0, value: {scaleX: 1.2, scaleY: 1.2}}, {
            time: b,
            value: {scaleX: 1.2, scaleY: 1.2}
        }];
        a.countUpItem.prop.operations.fade = [{value: 1, time: 0}, {value: 1, time: 2000}, {value: 0, time: b}]
    }
};
TwinSpin.BigWinCountUpView = Sys.extend(Game.Slots.BigWinCountUpView, TwinSpin.BigWinCountUpView, "TwinSpin.BigWinCountUpView");
Sys.ns("TwinSpin");
TwinSpin.BigWinCountUpDesktopView = {
    NUMBER_WIDTH: 153, NUMBER_HEIGHT: 190, configureStartAnimation: function (b) {
        var a = this;
        var c = 640;
        a.countUpItem.prop.ownOpacity = 1;
        a.countUpItem.prop.operations.translate = [{time: 0, value: {top: 0, left: c}}, {
            time: 400,
            value: {top: 480, left: c}
        }, {time: 550, value: {top: 450, left: c}}, {time: 900, value: {top: 330, left: c}}];
        a.countUpItem.prop.operations.scale = [{time: 0, value: {scaleX: 0.5, scaleY: 0.5}}, {
            time: 400,
            value: {scaleX: 0.4, scaleY: 0.4}
        }, {time: 900, value: {scaleX: 0.8, scaleY: 0.8}}, {time: 7500, value: {scaleX: 1, scaleY: 1}}]
    }, configureEndAnimation: function (b) {
        var a = this;
        a.countUpItem.prop.left = 640;
        a.countUpItem.prop.top = 330;
        delete a.countUpItem.prop.operations.translate;
        a.countUpItem.prop.operations.scale = [{time: 0, value: {scaleX: 1, scaleY: 1}}, {
            time: b,
            value: {scaleX: 1, scaleY: 1}
        }];
        a.countUpItem.prop.operations.fade = [{value: 1, time: 0}, {value: 1, time: b}]
    }
};
TwinSpin.BigWinCountUpDesktopView = Sys.extend(TwinSpin.BigWinCountUpView, TwinSpin.BigWinCountUpDesktopView, "TwinSpin.BigWinCountUpDesktopView");
Sys.ns("TwinSpin");
TwinSpin.WinBannerController = {
    COUNT_UP_NAME: "winBanner", COUNT_UP_SOUND_RUNNING: true, setupEvents: function () {
        var a = this;
        TwinSpin.WinBannerController.superclass.setupEvents.apply(this, arguments);
        a.on({
            "notify:responseParser.responseParsed": a.model.processServerResponse.bind(a.model),
            "request:winBanner.animate": a.start,
            "request:winBanner.hide": a.stop,
            "view:playSound": a.playSound,
            "view:stopSound": a.stopSound
        })
    }, playSound: function () {
        this.fireEvent("request:audioPlayer.play", {name: "countUpLoop", loop: true, id: "winBannerCountUp"});
        this.COUNT_UP_SOUND_RUNNING = true
    }, stopSound: function () {
        var a = this;
        if (a.COUNT_UP_SOUND_RUNNING) {
            a.COUNT_UP_SOUND_RUNNING = false;
            a.fireEvent("request:audioPlayer.stop", "winBannerCountUp");
            a.fireEvent("request:audioPlayer.play", {name: "countUpLoopEnd", id: "countUpLoopEnd"})
        }
    }
};
TwinSpin.WinBannerController = Sys.extend(Core.CountUpController, TwinSpin.WinBannerController, "TwinSpin.WinBannerController");
Sys.ns("TwinSpin");
TwinSpin.BigWinView = {
    FONT: {bigWin: "90px Impact", megaWin: "90px Impact", superMegaWin: "90px Impact"},
    TEXT_OPERATIONS: [{shadowColor: "#ec6a14", shadowBlur: 50, drawType: "fill"}, {
        shadowColor: "#ec6a14",
        shadowBlur: 50,
        drawType: "fill"
    }, {fillStyle: "#ffffff", shadowColor: "#ec6a14", shadowBlur: 50, drawType: "fill"}, {
        shadowColor: "#606060",
        shadowBlur: 10,
        shadowOffsetY: 5,
        drawType: "fill"
    }, {lineWidth: 2, strokeStyle: "#edce33", drawType: "stroke", shadowOffsetY: 0}],
    TEXT_OFFSET: 40,
    TEXT_TOP: 45,
    TEXT_WIN_SCALING: 1.5,
    TEXT_SUPER_MEGA_WIN_SCALING: 1.2,
    BACKGROUND_ANIMATION_TOP: 25,
    BACKGROUND_ANIMATION_LEFT: 88,
    BACKGROUND_ANIMATION_WIDTH: 1110,
    BACKGROUND_ANIMATION_HEIGHT: 647,
    configureTextAnimation: function (c) {
        var b = this, a = b.TEXT_WIN_SCALING;
        if (c.prop.text === Services.languageManager.getText(b.WIN_TEXTS.superMegaWin)) {
            a = b.TEXT_SUPER_MEGA_WIN_SCALING
        }
        c.prop.operations.fade = [{time: 0, value: 0}, {time: 300, value: 0}, {time: 300, value: 1}, {
            time: 400,
            value: 1,
            goTo: 2
        }];
        c.prop.operations.scale = [{time: 0, value: {scaleX: 1, scaleY: 1}}, {
            time: 400,
            value: {scaleX: a, scaleY: a}
        }, {time: 800, value: {scaleX: 1, scaleY: 1}}, {time: 801, value: {scaleX: 1, scaleY: 1}, goTo: 2}];
        return c
    },
    configureTextEndingAnimation: function (a) {
        a.prop.operations.fade = [{value: 1, time: 0}, {value: 1, time: 2000}, {
            value: 0,
            time: this.model.readData("showTotalDuration")
        }]
    },
    initAnimations: function () {
        var g = this, f = new Animation.CanvasAnimationList({}), e = new Animation.CanvasAnimationList({}),
            d = new Animation.CanvasAnimationList({}), k = {}, c, b, a, h, j, i;
        g.scaleFactor = g.getScaleFactor();
        Sys.each(g.model.getSupportedSubTypes(), function (l) {
            i = Services.languageManager.getText(g.WIN_TEXTS[l]);
            b = g.FONT[l];
            c = g.configureTextAnimation(g.createTextAnimation(i, b));
            k[l] = c;
            f.add(c);
            c = g.createSwitchAnimation(i);
            k[l + "Switch"] = c;
            f.add(c);
            c = g.createEndAnimation(i);
            k[l + "End"] = c;
            f.add(c)
        });
        a = g.configureBackgroundAnimation();
        e.add(a);
        g.backgroundGlowAnimation = g.getBackgroundGlowAnimationItem();
        e.add(g.backgroundGlowAnimation);
        g.backgroundAnimationList = e;
        h = g.configFinalBgAnimation();
        d.add(h);
        g.finalBgAnimationList = d;
        Game.stage.view.addToRenderLoop(f);
        Game.stage.view.addToRenderLoop(e);
        Game.stage.view.addToRenderLoop(d);
        f.stop();
        e.stop();
        d.stop();
        g.animations = k;
        g.list = f
    },
    show: function () {
        var a = this;
        a.fireEvent("view:stopAudio", "reelTwin5Snd");
        TwinSpin.BigWinView.superclass.show.apply(a, arguments);
        a.backgroundAnimationList.play()
    },
    finish: function () {
        var a = this;
        TwinSpin.BigWinView.superclass.finish.apply(a, arguments);
        a.backgroundAnimationList.stop();
        a.finalBgAnimationList.play()
    },
    close: function () {
        var a = this;
        TwinSpin.BigWinView.superclass.close.apply(a, arguments);
        a.finalBgAnimationList.stop()
    },
    closeTextAnimation: function () {
        TwinSpin.BigWinView.superclass.close.apply(this, arguments)
    },
    closeBgLight: function () {
        this.finalBgAnimationList.stop()
    },
    configureBackgroundAnimation: function () {
        var a = Resources.readData("spriteConfigurations").bigWinAnimationSprite,
            c = Game.stage.view.animationManager.getSpriteSequence("bigWinAnimation");
        var b = new Animation.CanvasAnimationItem({
            top: this.BACKGROUND_ANIMATION_TOP,
            left: this.BACKGROUND_ANIMATION_LEFT,
            width: this.BACKGROUND_ANIMATION_WIDTH,
            height: this.BACKGROUND_ANIMATION_HEIGHT,
            depth: 5,
            image: "bigWinAnimationSprite",
            frameWidth: a.frameWidth,
            frameHeight: a.frameHeight,
            totalSpriteWidth: a.totalSpriteWidth,
            spriteArray: c,
            operations: {sprite: [{time: 0, value: 0}, {time: 260, value: c.length - 1, goTo: 0}]}
        });
        return b
    },
    getBackgroundGlowAnimationItem: function () {
        var a = new Animation.CanvasAnimationItem({
            top: 10,
            left: 65,
            width: 1148,
            height: 669,
            depth: 5,
            image: "bigWinGlow",
            operations: {fade: [{time: 0, value: 1}, {time: 260, value: 0, goTo: 0}]}
        });
        return a
    },
    configFinalBgAnimation: function () {
        return new Animation.CanvasAnimationItem({
            top: -26,
            left: 52,
            width: 1173,
            height: 742,
            depth: 5,
            image: "reel_Background_4",
            operations: {fade: [{time: 0, value: 1}, {time: this.model.readData("showTotalDuration"), value: 1}]}
        })
    },
    createTextAnimation: function (f, b) {
        var d = this, g = Environment.getStageResolution(), e = d.createText(f, b), c = e.width, a = e.height;
        return new Animation.CanvasAnimationItem({
            width: c,
            height: a,
            top: d.TEXT_TOP * d.scaleFactor,
            left: Sys.isDefined(d.TEXT_LEFT) ? d.TEXT_LEFT * d.scaleFactor : (g.width - c) / 2,
            opacity: 1,
            depth: Layering.Game.Slots.BigWin.text,
            image: e,
            operations: {},
            text: f
        })
    },
    createText: (function () {
        var a = {};
        return function (d, b) {
            var c = this;
            return a[d] || (a[d] = Animation.utils.text.createText(d, b, c.TEXT_OFFSET, c.TEXT_OPERATIONS))
        }
    }()),
    showWinText: function (a) {
        var b = this;
        TwinSpin.BigWinView.superclass.showWinText.apply(b, arguments);
        b.playAudio("bigWinText")
    }
};
TwinSpin.BigWinView = Sys.extend(Game.Slots.BigWinView, TwinSpin.BigWinView, "TwinSpin.BigWinView");
Sys.ns("TwinSpin");
TwinSpin.BigWinDesktopView = {
    BACKGROUND_ANIMATION_LEFT: 125,
    BACKGROUND_ANIMATION_WIDTH: 1035,
    BACKGROUND_ANIMATION_HEIGHT: 602,
    SPLASH_WIDTH: 272,
    SPLASH_HEIGHT: 596,
    SPLASH_LEFT_OFFSET: 42,
    SPLASH_TOP_OFFSET: 42,
    initAnimations: function () {
        var a = this;
        TwinSpin.BigWinDesktopView.superclass.initAnimations.apply(a, arguments);
        a.initializeSplashes();
        a.addSplashAnimations();
        a.finalBackgroundBorderAnimationItem = a.getBackgroundGlowAnimationItem();
        a.configureEndBackgroundBorderGlow(a.finalBackgroundBorderAnimationItem);
        a.finalBgAnimationList.stop()
    },
    initializeSplashes: function () {
        var c = this;
        var a = function (d) {
            return {
                width: d.SPLASH_WIDTH,
                height: d.SPLASH_HEIGHT,
                image: "twin-flash",
                depth: 6,
                operations: {
                    fade: [{time: 0, value: 0}, {time: 100, value: 1}, {time: 133, value: 1}, {
                        time: 233,
                        value: 0
                    }, {time: 366, value: 0, goTo: 0}]
                }
            }
        };
        c.splashes = [];
        for (var b = 0; b < 5; b++) {
            c.splashes.push(new Animation.CanvasAnimationItem(a(c)))
        }
    },
    addSplashAnimations: function () {
        var c = this, a, f, e, d, h, g;
        for (var b = 0; b < 5; b++) {
            a = Game.stage.model.getSymbolConfiguration(b, 0);
            f = a.left;
            e = a.top;
            d = c.splashes[b];
            d.restore();
            h = d.prop;
            g = h.operations.fade;
            h.id = "bigWinSplash" + b;
            h.top = e - c.SPLASH_TOP_OFFSET;
            h.left = f - c.SPLASH_LEFT_OFFSET;
            c.finalBgAnimationList.add(d)
        }
    },
    getBackgroundGlowAnimationItem: function () {
        var a = new Animation.CanvasAnimationItem({
            top: 23,
            left: 105,
            width: 1068,
            height: 623,
            depth: 5,
            image: "bigWinGlow",
            operations: {}
        });
        return a
    },
    configureStartBackgroundBorderGlow: function () {
        var a = this;
        a.backgroundGlowAnimation.prop.operations = {fade: [{time: 0, value: 1}, {time: 260, value: 0, goTo: 0}]}
    },
    configFinalBgAnimation: function () {
        return new Animation.CanvasAnimationItem({
            top: 6,
            left: 96,
            width: 1088,
            height: 668,
            depth: 5,
            image: "reel_Background_4",
            operations: {
                fade: [{time: 0, value: 0}, {
                    time: 100,
                    value: 1
                }, {time: this.model.readData("showTotalDuration"), value: 1}]
            }
        })
    },
    configureEndBackgroundBorderGlow: function (a) {
        a.prop.operations = {
            fade: [{time: 0, value: 0}, {time: 100, value: 1}, {time: 133, value: 1}, {
                time: 233,
                value: 0
            }, {time: 366, value: 0, goTo: 0}]
        }
    },
    show: function () {
        var a = this;
        a.fireEvent("view:stopAudio", "reelTwin5Snd");
        TwinSpin.BigWinView.superclass.show.apply(a, arguments);
        a.configureStartBackgroundBorderGlow();
        a.backgroundAnimationList.play()
    },
    configureTextEndingAnimation: function (b) {
        var a = this;
        b.prop.operations.fade = [{value: 1, time: 0}, {value: 1, time: this.model.readData("showTotalDuration")}]
    }
};
TwinSpin.BigWinDesktopView = Sys.extend(TwinSpin.BigWinView, TwinSpin.BigWinDesktopView, "TwinSpin.BigWinDesktopView");
Sys.ns("TwinSpin");
TwinSpin.BigWinController = {
    SPIN_BUTTON_POSITION: {
        x: 590,
        y: 596,
        width: 99,
        height: 99,
        centerX: 640,
        centerY: 642,
        radius: 50
    }, setupEvents: function () {
        var a = this;
        TwinSpin.BigWinController.superclass.setupEvents.apply(a, arguments);
        a.on({
            "notify:spinButton.clicked": a.noAction,
            "notify:spinButton.clickedWhileHidden": a.noAction,
            "request:abortPresentation": a.onSpacebarPressed
        })
    }, noAction: function () {
    }, onConutUpStart: function (a) {
        var b = this;
        b.startListeningToUserInput();
        b.aborted = false;
        this.fireEvent("request:bigWinCountUp.start", a)
    }, onUserInputStart: function () {
    }, onUserInputEnd: function (c) {
        var b = this, a = b.isCollision(c);
        if (Sys.UserInputUtils.isCoordinateTarget(Game.stage.getGameContainer(), c)) {
            if (b.model.isAutoPlay() && Platform.isDesktopDevice || a) {
                b.model.storeData("startingNextSpin", true);
                b.stopListeningToUserInput();
                b.handleUserInput();
                if (Sys.isDefined(b.nextSpinTimeout)) {
                    clearTimeout(b.nextSpinTimeout);
                    delete b.nextSpinTimeout
                }
                b.nextSpinTimeout = setTimeout(b.handleUserInput.bind(b), 500)
            } else {
                b.handleUserInput()
            }
        }
    }, onSpacebarPressed: function () {
        var a = this;
        if (Platform.isDesktopDevice && !a.aborted) {
            a.model.storeData("startingNextSpin", true);
            a.handleUserInput();
            a.aborted = true;
            if (Sys.isDefined(a.nextSpinTimeout)) {
                clearTimeout(a.nextSpinTimeout);
                delete a.nextSpinTimeout
            }
            a.nextSpinTimeout = setTimeout(a.handleUserInput.bind(a), 500)
        } else {
            a.handleUserInput()
        }
    }, isCollision: function (h) {
        var e = this, c = Sys.UserInputUtils.getCoordinatesRelativeToElement(h, Game.stage.getGameContainer()),
            f = Environment.getWindowToVirtualScale(3), a = e.SPIN_BUTTON_POSITION, d = Math.abs((c.x * f) - a.centerX),
            b = Math.abs((c.y * f) - a.centerY), g = Math.sqrt((d * d) + (b * b));
        return (g <= a.radius)
    }, show: function () {
        var a = this;
        a.fireEvent("request:settingsWindow.close");
        a.startListeningToUserInput();
        a.model.setState("showing");
        a.fireEvent("request:ambienceManager.ambiencePauseSwitch", true);
        a.view.show()
    }, finish: function (b) {
        var a = this;
        if (b) {
            a.model.storeData("calledFromCountUp", true)
        } else {
            a.model.storeData("calledFromCountUp", false)
        }
        a.model.setState("finished");
        a.view.finish();
        a.fireEvent("request:ambienceManager.ambiencePauseSwitch", false)
    }, close: function () {
        var a = this;
        if (Platform.isDesktopDevice && (a.model.isState("animationRequested") || a.model.isState("closed"))) {
            return
        }
        a.model.setState("closed");
        if (a.isStartNextSpinAllowed()) {
            a.closeTimeout = setTimeout(a.closeWithTimeout.bind(a), 500);
            a.view.closeBgLight()
        } else {
            a.view.close()
        }
        if (a.model.readData("showAllWins")) {
            if (a.isStartNextSpinAllowed()) {
                a.model.storeData("startingNextSpin", false);
                a.onWaitIsComplete()
            } else {
                a.model.setState("showingAllWins");
                a.initializeWaitSequence("request:winSituationsDisplay.showAllWins", {showDuration: a.model.readData("showAllWinsDuration")})
            }
        } else {
            a.onWaitIsComplete()
        }
    }, isStartNextSpinAllowed: function () {
        var a = this, b = a.model.readData("startingNextSpin");
        return Platform.isDesktopDevice && b
    }, closeWithTimeout: function () {
        var a = this;
        if (Sys.isDefined(a.closeTimeout)) {
            clearTimeout(a.closeTimeout);
            delete a.closeTimeout
        }
        if (Sys.isDefined(a.nextSpinTimeout)) {
            clearTimeout(a.nextSpinTimeout);
            delete a.nextSpinTimeout
        }
        a.aborted = true;
        a.view.closeTextAnimation()
    }
};
TwinSpin.BigWinController = Sys.extend(Game.Slots.BigWinController, TwinSpin.BigWinController, "TwinSpin.BigWinController");
Sys.ns("TwinSpin");
TwinSpin.BigWinModel = {
    SUPPORTED_SUB_TYPES: ["bigWin", "megaWin", "superMegaWin"],
    SUB_TYPE_LIMITS: {bigWin: {from: 0, to: 30}, megaWin: {from: 30, to: 60}, superMegaWin: {from: 60}},
    COUNT_UP_DURATIONS_FACTOR: {bigWin: 0.3, megaWin: 0.2, superMegaWin: 0.15},
    SHOW_TOTAL_DURATION: 3000,
    SHOW_ALL_WINS_DURATION: 2000,
    COUNT_UP_DURATIONS_AUTOPLAY: {bigWin: 6000, megaWin: 7500, superMegaWin: 9000},
    processServerResponse: function (a) {
        TwinSpin.BigWinModel.superclass.processServerResponse.apply(this, arguments);
        this.storeData("startingNextSpin", false)
    },
    getWinCountUpDuration: function () {
        var i = this, e = i.readData("winType"), b, a, k, c, g = Services.moneyManager.getBetCoins(),
            f = i.COUNT_UP_DURATIONS_FACTOR.bigWin, d = i.COUNT_UP_DURATIONS_FACTOR.megaWin,
            h = i.COUNT_UP_DURATIONS_FACTOR.superMegaWin, j = i.readData("coinWin") / g;
        if (i.isAutoPlay()) {
            return i.COUNT_UP_DURATIONS_AUTOPLAY[e]
        }
        a = f * Math.min(j, i.SUB_TYPE_LIMITS.bigWin.to);
        k = Math.max(0, d * Math.min(j - i.SUB_TYPE_LIMITS.megaWin.from, i.SUB_TYPE_LIMITS.megaWin.from));
        c = Math.max(0, h * (j - i.SUB_TYPE_LIMITS.superMegaWin.from));
        c = Math.min(c, 3);
        b = (a + k + c) * 1000;
        return b
    },
    isAutoPlay: function () {
        var a = Services.settingsManager.getSetting("autoPlayNrSpins");
        return (!Sys.isDefined(a) || a > 0)
    },
    shouldToggleWins: function () {
        var a = Services.settingsManager.getSetting("autoPlayNrSpins"), b = Sys.isDefined(a) && a > 0;
        return !b && !this.readData("togglePreventedByFreeSpins") && !this.readData("startingNextSpin")
    }
};
TwinSpin.BigWinModel = Sys.extend(Game.Slots.BigWinModel, TwinSpin.BigWinModel, "TwinSpin.BigWinModel");
Layering.Game.Background.BetlineNoImage = 2;
Layering.Game.Background.ReelUpperGlow = 11;
Layering.Game.Logo.image = 51;
Sys.apply(Layering.Game.Slots.BigWin, {bigWinFinalBg: 5, bigWinGlow: 4, bigWinRunningLights: 5});
Sys.override(Interface.Slots.CoinsFieldModel, {WIN_UP_TO: "270 000"});
Sys.override(Game.Slots.DimmedNoWinSymbolsView, {OPACITY: 0.7});
Sys.override(Core.Audio.AudioPlayerView, {
    stopNonLooping: function () {
        var b = this, a;
        Sys.iterate(b.audioPlaying, function (d, c) {
            a = [];
            Sys.each(c, function (e) {
                if (e.loop) {
                    a.push(e)
                } else {
                    b.stopClip(e)
                }
            });
            b.audioPlaying[d].length = 0;
            b.audioPlaying[d] = a
        })
    }
});
Sys.override(Interface.GameSettingsDesktopView, {
    SETTINGS_CONTROLS: [{
        id: "quickSpin",
        label: Language.Keys.setting_quickSpinGame,
        type: "checkbox"
    }, {id: "showFeatureSplash", label: Language.Keys.setting_introScreeGame, type: "checkbox"}, {
        id: "spacebarToSpin",
        label: Language.Keys.setting_spaceSpin,
        type: "checkbox"
    }]
});
Sys.ns("TwinSpin");
TwinSpin.Positions = {SpinButton: {x: 592, y: 596, width: 99, height: 99, centerX: 640, centerY: 649, radius: 51}};
Sys.ns("TwinSpin");
TwinSpin.Layering = {
    WalkingLights: {image: 4},
    Sparkles: {image: 3},
    Splashes: {image: 16, netEntProd: 52, text: 55, background: 52, button: 51, buttonGlow: 53, starGlow: 54},
    Background: {image: 2, netEntProd: 51, greyLayer: 50},
    WinningSymbols: {animationItems: 5, wildAnimation: 6},
    Keypad: {
        background_basic: 3,
        background_freespin: 35,
        betField: 4,
        balanceField: 4,
        bet: 5,
        balance: 5,
        win: 36,
        total_win: 36,
        betLevelSelector: 5,
        coinValueSelector: 5,
        maxBet: {button: 5, label: 6},
        autoPlay: {button: 5, label: 6},
        paytable: {button: 51, label: 6}
    }
};
Sys.apply(Layering.Game.Slots, TwinSpin.Layering);
Sys.ns("TwinSpin");
TwinSpin.PaytableCardNavigation = {
    setupArrows: function (c) {
        var b = this, a = Sys.isObj(c);
        b.arrowContainer = new Sys.Element({id: b.id + "_arrows", tag: "ul", cls: b.CSS.ARROWS});
        b.previousArrow = new TwinSpin.PaytableDOMButton({
            id: "paytablePrevious",
            tag: "li",
            baseCSS: b.CSS.ARROWS_PREVIOUS,
            textContent: (a && Sys.isDefined(c.previous)) ? c.previous : "",
            clickCallback: b.previous.bind(b)
        });
        b.arrowContainer.add(b.previousArrow.getContainer());
        b.subComponents.push(b.previousArrow);
        if (b.hasCloseButton) {
            b.closeArrow = new TwinSpin.PaytableDOMButton({
                id: "paytableClose",
                tag: "li",
                baseCSS: b.CSS.ARROWS_CLOSE,
                textContent: (a && Sys.isDefined(c.close)) ? c.close : "",
                clickCallback: b.close.bind(b)
            });
            b.arrowContainer.add(b.closeArrow.getContainer());
            b.subComponents.push(b.closeArrow)
        }
        b.nextArrow = new TwinSpin.PaytableDOMButton({
            id: "paytableNext",
            tag: "li",
            baseCSS: b.CSS.ARROWS_NEXT,
            textContent: (a && Sys.isDefined(c.next)) ? c.next : "",
            clickCallback: b.next.bind(b)
        });
        b.arrowContainer.add(b.nextArrow.getContainer());
        b.subComponents.push(b.nextArrow)
    }, setupIndicators: function () {
        var c = this, d = new Sys.Element({id: c.id + "indicators", tag: "ul", cls: c.CSS.INDICATORS}), b = [], e, a;
        for (a = -1; ++a < c.numCards;) {
            e = new TwinSpin.PaytableDOMButton({
                id: "paytableIndicator_" + a,
                tag: "li",
                baseCSS: c.CSS.INDICATORS_CHILD,
                clickCallback: c.selectCard.bind(c, a)
            });
            b.push(d.add(e.getContainer()));
            c.subComponents.push(e)
        }
        c.indicatorContainer = d;
        c.indicatorChildren = b
    }
};
TwinSpin.PaytableCardNavigation = Sys.extend(Interface.utils.CardNavigation, TwinSpin.PaytableCardNavigation, "TwinSpin.PaytableCardNavigation");
Sys.ns("TwinSpin");
TwinSpin.PaytableDOMButton = {SOUND_CLICK: "paytableButton"};
TwinSpin.PaytableDOMButton = Sys.extend(Interface.utils.DOMButton, TwinSpin.PaytableDOMButton, "TwinSpin.PaytableDOMButton");
Sys.ns("TwinSpin");
TwinSpin.MaxBetButtonModel = {
    setupData: function () {
        var d = Resources.readData("gameServerInitResponseObject").betlevel.all, a = Resources.readData("config"),
            b = 0, e = a.winSituationsDisplay.winSituationMinimumDisplayTime, c = 0;
        Interface.Slots.MaxBetButtonModel.superclass.setupData.apply(this, arguments);
        Sys.each(d, function (f) {
            c = Math.max(f, c)
        });
        this.storeData("maxBetLevel", c);
        this.storeData("betlines", b);
        this.storeData("winSituationMinimumDisplayTime", e)
    }
};
TwinSpin.MaxBetButtonModel = Sys.extend(Interface.Slots.MaxBetButtonModel, TwinSpin.MaxBetButtonModel, "TwinSpin.MaxBetButtonModel");
Sys.ns("TwinSpin");
TwinSpin.MaxBetButtonController = {
    setupEvents: function () {
        var a = this;
        TwinSpin.MaxBetButtonController.superclass.setupEvents.apply(a, arguments);
        a.on({"request:disableKeypad": a.view.disable.bind(a.view)})
    }
};
TwinSpin.MaxBetButtonController = Sys.extend(Interface.Slots.MaxBetButtonController, TwinSpin.MaxBetButtonController, "TwinSpin.MaxBetButtonController");
Sys.ns("TwinSpin");
TwinSpin.IdleSymbolAnimation = {
    getMixinDependencies: function () {
        return ["animation", "serverResponse"]
    }, getDefaultMVCClasses: function () {
        return {
            model: TwinSpin.IdleSymbolAnimationModel,
            controller: TwinSpin.IdleSymbolAnimationController,
            view: TwinSpin.IdleSymbolAnimationView
        }
    }
};
TwinSpin.IdleSymbolAnimation = Sys.extend(Core.Module, TwinSpin.IdleSymbolAnimation, "TwinSpin.IdleSymbolAnimation");
Sys.ns("TwinSpin");
TwinSpin.IdleSymbolAnimationController = {
    IDLE_ANIMATION_START_TIME: 0, setupEvents: function () {
        var a = this;
        TwinSpin.IdleSymbolAnimationController.superclass.setupEvents.apply(a, arguments);
        a.on({
            "notify:stateHandler.enteringIdleState": a.showTwinkleAnimations,
            "notify:IntroSplash.closed": a.showTwinkleAnimations,
            "notify:spin.roundStart": a.stopAnimations,
            "notify:settingsManager.settingChanged": a.onSettingChanged
        })
    }, onSettingChanged: function (a) {
        var b = this;
        if (a === "betLevel" || a === "denomination") {
            b.model.storeData("hasWin", false);
            b.showTwinkleAnimations()
        }
    }, showTwinkleAnimations: function () {
        var a = this;
        if (a.model.canIdleAnimationRun()) {
            a.runAnimation()
        }
    }, stopAnimations: function () {
        var a = this;
        a.model.storeData("reelInfo", undefined);
        a.view.stop()
    }, runAnimation: function () {
        var a = this;
        if (Sys.isFunc(a.view["run" + a.model.getAnimationType() + "Animation"])) {
            a.view["run" + a.model.getAnimationType() + "Animation"]()
        }
    }
};
TwinSpin.IdleSymbolAnimationController = Sys.extend(Core.Controller, TwinSpin.IdleSymbolAnimationController, "TwinSpin.IdleSymbolAnimationController");
Sys.ns("TwinSpin");
TwinSpin.IdleSymbolAnimationModel = {
    INDEX: 0,
    ANIMATION_TYPE_ARRAY: ["Lightning", "Twinkle"],
    processServerResponse: function (c) {
        var b = this, a = [];
        if (!Sys.isDefined(c.wins) || !Sys.isDefined(c.wins.winSituations)) {
            b.storeData("hasWin", false);
            ++b.INDEX
        } else {
            b.storeData("hasWin", true)
        }
        b.storeData("reelInfo", c.reelInfo)
    },
    canIdleAnimationRun: function () {
        var a = this;
        return !a.readData("hasWin") && Sys.isDefined(a.readData("reelInfo"))
    },
    getAnimationType: function () {
        var a = this.INDEX % 2;
        return this.ANIMATION_TYPE_ARRAY[a]
    }
};
TwinSpin.IdleSymbolAnimationModel = Sys.extend(Core.Model, TwinSpin.IdleSymbolAnimationModel, "TwinSpin.IdleSymbolAnimationModel");
Sys.ns("TwinSpin");
TwinSpin.IdleSymbolAnimationView = {
    IDLE_ANIMATION_START_TIME: 15000,
    TWINKLE_DOTS_CONFIG: [{
        DELAY: 0,
        REEL_POSITION_Y: 0,
        REEL_POSITION_X: 0,
        xOffset: 5,
        yOffset: 40,
        square: 1
    }, {DELAY: 1000, REEL_POSITION_Y: 0, REEL_POSITION_X: 0, xOffset: 30, yOffset: 0, square: 1}, {
        DELAY: 2000,
        REEL_POSITION_Y: 0,
        REEL_POSITION_X: 0,
        xOffset: 45,
        yOffset: 140,
        square: 1
    }, {DELAY: 3000, REEL_POSITION_Y: 0, REEL_POSITION_X: 0, xOffset: 145, yOffset: 15, square: 1}, {
        DELAY: 0,
        REEL_POSITION_Y: 0,
        REEL_POSITION_X: 1,
        xOffset: 100,
        yOffset: 3,
        square: 2
    }, {DELAY: 1000, REEL_POSITION_Y: 0, REEL_POSITION_X: 1, xOffset: 140, yOffset: 40, square: 2}, {
        DELAY: 2000,
        REEL_POSITION_Y: 0,
        REEL_POSITION_X: 1,
        xOffset: 15,
        yOffset: 100,
        square: 2
    }, {DELAY: 0, REEL_POSITION_Y: 0, REEL_POSITION_X: 2, xOffset: 1, yOffset: 130, square: 3}, {
        DELAY: 1000,
        REEL_POSITION_Y: 0,
        REEL_POSITION_X: 2,
        xOffset: 83,
        yOffset: 1,
        square: 3
    }, {DELAY: 2000, REEL_POSITION_Y: 0, REEL_POSITION_X: 2, xOffset: 155, yOffset: 150, square: 3}, {
        DELAY: 4000,
        REEL_POSITION_Y: 0,
        REEL_POSITION_X: 3,
        xOffset: 15,
        yOffset: 90,
        square: 4
    }, {DELAY: 5000, REEL_POSITION_Y: 0, REEL_POSITION_X: 3, xOffset: 150, yOffset: 15, square: 4}, {
        DELAY: 4000,
        REEL_POSITION_Y: 0,
        REEL_POSITION_X: 4,
        xOffset: 1,
        yOffset: 75,
        square: 5
    }, {DELAY: 5000, REEL_POSITION_Y: 0, REEL_POSITION_X: 4, xOffset: 152, yOffset: 18, square: 5}, {
        DELAY: 4000,
        REEL_POSITION_Y: 1,
        REEL_POSITION_X: 0,
        xOffset: 85,
        yOffset: -10,
        square: 6
    }, {DELAY: 5000, REEL_POSITION_Y: 1, REEL_POSITION_X: 0, xOffset: 140, yOffset: 165, square: 6}, {
        DELAY: 0,
        REEL_POSITION_Y: 1,
        REEL_POSITION_X: 1,
        xOffset: 55,
        yOffset: 145,
        square: 7
    }, {DELAY: 1000, REEL_POSITION_Y: 1, REEL_POSITION_X: 1, xOffset: 65, yOffset: 105, square: 7}, {
        DELAY: 2000,
        REEL_POSITION_Y: 1,
        REEL_POSITION_X: 1,
        xOffset: 75,
        yOffset: 0,
        square: 7
    }, {DELAY: 4000, REEL_POSITION_Y: 1, REEL_POSITION_X: 2, xOffset: 0, yOffset: 145, square: 8}, {
        DELAY: 4000,
        REEL_POSITION_Y: 1,
        REEL_POSITION_X: 3,
        xOffset: 0,
        yOffset: 95,
        square: 9
    }, {DELAY: 5000, REEL_POSITION_Y: 1, REEL_POSITION_X: 3, xOffset: 155, yOffset: 130, square: 9}, {
        DELAY: 0,
        REEL_POSITION_Y: 1,
        REEL_POSITION_X: 4,
        xOffset: 0,
        yOffset: 23,
        square: 10
    }, {DELAY: 1000, REEL_POSITION_Y: 1, REEL_POSITION_X: 4, xOffset: 45, yOffset: -12, square: 10}, {
        DELAY: 2000,
        REEL_POSITION_Y: 1,
        REEL_POSITION_X: 4,
        xOffset: 67,
        yOffset: 135,
        square: 10
    }, {DELAY: 3000, REEL_POSITION_Y: 1, REEL_POSITION_X: 4, xOffset: 157, yOffset: 50, square: 10}, {
        DELAY: 4000,
        REEL_POSITION_Y: 2,
        REEL_POSITION_X: 0,
        xOffset: -3,
        yOffset: 125,
        square: 11
    }, {DELAY: 2000, REEL_POSITION_Y: 2, REEL_POSITION_X: 1, xOffset: 0, yOffset: 0, square: 12}, {
        DELAY: 3000,
        REEL_POSITION_Y: 2,
        REEL_POSITION_X: 1,
        xOffset: 130,
        yOffset: 10,
        square: 12
    }, {DELAY: 2000, REEL_POSITION_Y: 2, REEL_POSITION_X: 2, xOffset: 0, yOffset: 83, square: 13}, {
        DELAY: 3000,
        REEL_POSITION_Y: 2,
        REEL_POSITION_X: 2,
        xOffset: 115,
        yOffset: 120,
        square: 13
    }, {DELAY: 2000, REEL_POSITION_Y: 2, REEL_POSITION_X: 3, xOffset: 0, yOffset: 40, square: 14}, {
        DELAY: 3000,
        REEL_POSITION_Y: 2,
        REEL_POSITION_X: 3,
        xOffset: 50,
        yOffset: 120,
        square: 14
    }, {DELAY: 2000, REEL_POSITION_Y: 2, REEL_POSITION_X: 4, xOffset: 0, yOffset: 60, square: 15}, {
        DELAY: 3000,
        REEL_POSITION_Y: 2,
        REEL_POSITION_X: 4,
        xOffset: 130,
        yOffset: 120,
        square: 15
    }],
    runLightningAnimation: function () {
        if (this.animationListElectric) {
            this.animationListElectric.restore()
        }
    },
    runTwinkleAnimation: function () {
        if (this.animationListTwinkle) {
            this.animationListTwinkle.restore()
        }
    },
    initAnimations: function () {
        var k = this, c, m, f = Resources.readData("config").reelGroups["default"], b = f.numberOfReels,
            a = f.reelLayout.standard.numberOfOutcomeSymbols, h, g, l = [];
        k.animationListTwinkle = new Animation.CanvasAnimationList({delay: k.IDLE_ANIMATION_START_TIME});
        k.animationListElectric = new Animation.CanvasAnimationList({delay: k.IDLE_ANIMATION_START_TIME});
        for (var e = 0; e < a; e++) {
            l[e] = [];
            for (var d = 0; d < b; d++) {
                c = f.reelAreaLeft + d * (f.symbolWidth + f.reelSpacing) + d;
                m = f.reelAreaTop + e * (f.symbolHeight + f.reelSpacing);
                l[e][d] = {left: c, top: m}
            }
        }
        k.COORDINATE_ARRAY = l;
        k.TWINKLE_DOTS_CONFIG.forEach(function (p, i, q) {
            var o = k.COORDINATE_ARRAY[p.REEL_POSITION_Y][p.REEL_POSITION_X], n = o.left + p.xOffset,
                j = o.top + p.yOffset;
            h = k.createTwinkleAnimationItem(p, n, j);
            k.animationListTwinkle.add(h)
        });
        k.animationListElectric.addItems(k.getElectricAnimationItems());
        Game.stage.view.addToRenderLoop(k.animationListElectric);
        k.animationListElectric.stop();
        Game.stage.view.addToRenderLoop(k.animationListTwinkle);
        k.animationListTwinkle.stop()
    },
    getElectricAnimationItems: function () {
        var a = Resources.readData("spriteConfigurations").electricAnimationSprite,
            b = Game.stage.view.animationManager.getSpriteSequence("electricAnimation");
        this.electricAnimationItemLeft = new Animation.CanvasAnimationItem({
            left: 157,
            top: 65,
            width: a.frameWidth,
            height: a.frameHeight,
            depth: Layering.Game.Slots.WinningSymbols.animationItems,
            image: "electricAnimationSprite",
            frameWidth: a.frameWidth,
            frameHeight: a.frameHeight,
            totalSpriteWidth: a.totalSpriteWidth,
            spriteArray: b,
            operations: {
                sprite: [{time: 0, value: 0}, {time: 3000, value: b.length - 1}, {
                    time: 3001,
                    value: 0
                }, {time: 7500, value: 0, goTo: 0}],
                fade: [{time: 0, value: 1}, {time: 3000, value: 1}, {time: 3001, value: 0}, {
                    time: 7500,
                    value: 0,
                    goTo: 0
                }]
            }
        });
        this.electricAnimationItemRight = new Animation.CanvasAnimationItem({
            left: 633,
            top: 65,
            width: a.frameWidth,
            height: a.frameHeight,
            depth: Layering.Game.Slots.WinningSymbols.animationItems,
            image: "electricAnimationSprite",
            frameWidth: a.frameWidth,
            frameHeight: a.frameHeight,
            totalSpriteWidth: a.totalSpriteWidth,
            spriteArray: b,
            operations: {
                sprite: [{time: 0, value: 0}, {time: 3000, value: b.length - 1}, {
                    time: 3001,
                    value: 0
                }, {time: 7500, value: 0, goTo: 0}],
                scale: [{time: 0, value: {scaleX: -1, scaleY: 1}}, {
                    time: 3000,
                    value: {scaleX: -1, scaleY: 1},
                    goTo: 0
                }],
                fade: [{time: 0, value: 1}, {time: 3000, value: 1}, {time: 3001, value: 0}, {
                    time: 7500,
                    value: 0,
                    goTo: 0
                }]
            }
        });
        return [this.electricAnimationItemLeft, this.electricAnimationItemRight]
    },
    createTwinkleAnimationItem: function (c, g, f) {
        var a = Resources.readData("spriteConfigurations").twinkleAnimationSprite,
            e = Game.stage.view.animationManager.getSpriteSequence("twinkleAnimation"), b = c.DELAY,
            d = new Animation.CanvasAnimationItem({
                left: g,
                top: f,
                delay: b,
                width: a.frameWidth,
                height: a.frameHeight,
                depth: Layering.Game.Slots.WinningSymbols.animationItems,
                image: "twinkleAnimationSprite",
                frameWidth: a.frameWidth,
                frameHeight: a.frameHeight,
                totalSpriteWidth: a.totalSpriteWidth,
                spriteArray: e,
                operations: {
                    sprite: [{time: 0, value: 0}, {time: 3000, value: e.length - 1}, {
                        time: 3001,
                        value: 0
                    }, {time: 4500, value: 0, goTo: 0}]
                }
            });
        return d
    },
    stop: function () {
        this.animationListElectric.stop();
        this.animationListTwinkle.stop()
    }
};
TwinSpin.IdleSymbolAnimationView = Sys.extend(Core.View, TwinSpin.IdleSymbolAnimationView, "TwinSpin.IdleSymbolAnimationView");
Sys.ns("TwinSpin");
TwinSpin.SettingsWindowDesktopView = {
    CLOSE_BUTTON_TAG_CSS: "close-button_css", setupDOMStructure: function () {
        var a = this;
        TwinSpin.SettingsWindowDesktopView.superclass.setupDOMStructure.apply(a, arguments);
        a.closeButton = new TwinSpin.PaytableDOMButton({
            id: "settingsWindowCloseButton",
            baseCSS: a.CLOSE_BUTTON_CSS,
            clickCallback: a.fireEvent.bind(a, "view:close"),
            enabled: false
        });
        a.container.add(a.closeButton.getContainer())
    }
};
TwinSpin.SettingsWindowDesktopView = Sys.extend(Interface.SettingsWindowDesktopView, TwinSpin.SettingsWindowDesktopView, "TwinSpin.SettingsWindowDesktopView");
Sys.ns("TwinSpin");
TwinSpin.LogoDesktopView = {SIZE_WIDTH: 407, SIZE_HEIGHT: 76, OFFSET_LEFT: -0.5, OFFSET_TOP: -1};
TwinSpin.LogoDesktopView = Sys.extend(Game.LogoView, TwinSpin.LogoDesktopView, "TwinSpin.LogoDesktopView");
Sys.ns("TwinSpin");
TwinSpin.BackgroundDesktopView = {
    REEL_AREA: "reelBackground", initAnimations: function () {
        var c = this, e = new Animation.CanvasAnimationList({}), b = new Animation.CanvasAnimationItem({
            fullScreen: true,
            depth: Layering.Game.Background.image,
            image: c.BACKGROUND_IMAGE
        }), d = new Animation.CanvasAnimationItem({
            top: 0,
            left: 0,
            width: 1280,
            height: 720,
            depth: Layering.Game.Background.ReelUpperGlow,
            image: c.REEL_UPPER_GLOW
        }), a = new Animation.CanvasAnimationItem({
            top: 56,
            left: 150,
            width: 980,
            height: 545,
            depth: Layering.Game.Background.image + 1,
            image: c.REEL_AREA
        });
        c.greyLayer = c.createGreyLayer();
        e.add(c.greyLayer);
        c.greyLayer.stop();
        c.reelItem = a;
        e.add(b);
        e.add(a);
        e.add(c.createNetEntProdLabelItem());
        e.add(d);
        c.list = e;
        c.item = b;
        Game.stage.view.addToRenderLoop(e)
    }, createGreyLayer: function () {
        var b = document.createElement("canvas"), a;
        b.width = 100;
        b.height = 100;
        a = b.getContext("2d");
        a.save();
        a.fillStyle = "rgba(0,0,0,0.2)";
        a.fillRect(0, 0, 100, 100);
        a.restore();
        return new Animation.CanvasAnimationItem({
            fullScreen: true,
            depth: TwinSpin.Layering.Background.greyLayer,
            image: b
        })
    }, enableGreyLayer: function () {
        this.list.play(this.greyLayer)
    }, disableGreyLayer: function () {
        this.greyLayer.stop()
    }, createNetEntProdLabelItem: function () {
        var c = "A NETENT PRODUCTION", b = "13px NetentStandardUI", a = -10,
            d = Animation.utils.text.createText(c, b, 0, [{fillStyle: "#ffffff"}]);
        return new Animation.Item({
            left: 1100,
            top: 8,
            width: d.width,
            height: d.height,
            depth: Layering.Game.Slots.Background.netEntProd,
            image: d
        })
    }, updateDepth: function (a) {
        this.reelItem.prop.depth = Layering.Game.Background.image + a
    }
};
TwinSpin.BackgroundDesktopView = Sys.extend(TwinSpin.BackgroundView, TwinSpin.BackgroundDesktopView, "TwinSpin.BackgroundDesktopView");
Sys.ns("TwinSpin");
TwinSpin.CoinsFieldDesktopView = {
    BASE_CSS: "interface-coinsField_desktop",
    BASIC_BET_LABEL: {
        font: "17px NetentStandardUI",
        fillstyle: "#ffffff",
        position: {x: 197, y: 604, width: 134, height: 23},
        alignment: {horizontal: "center", vertical: false}
    },
    BASIC_BET_VALUE: {
        font: "24px NetentStandardUI",
        fillstyle: "#f9fb00",
        position: {x: 196, y: 632, width: 134, height: 30},
        alignment: {horizontal: "center", vertical: false}
    },
    BASIC_BALANCE_LABEL: {
        font: "17px NetentStandardUI",
        fillstyle: "#ffffff",
        position: {x: 917, y: 604, width: 267, height: 133},
        alignment: {horizontal: "center", vertical: false}
    },
    BASIC_BALANCE_VALUE: {
        font: "24px NetentStandardUI",
        fillstyle: "#f9fb00",
        position: {x: 917, y: 632, width: 267, height: 133},
        alignment: {horizontal: "center", vertical: false}
    },
    BASIC_BACKGROUND: {position: {x: 7, y: 606, width: 1265, height: 84}},
    BASIC_BET_FIELD_BACKGROUND: {width: 85, height: 45, x: 222, y: 627, image: "betFieldBackground", depth: 4},
    BASIC_COIN_FIELD_BACKGROUND: {width: 150, height: 45, x: 976, y: 627, image: "coinFieldBackground", depth: 4},
    setupFrame: function (a) {
        var b = this;
        return new Animation.Item({
            top: a.y,
            left: a.x,
            width: a.width,
            height: a.height,
            depth: a.depth,
            image: a.image
        })
    },
    initTextBackground: function () {
        var a = this;
        a.textBackgroundList = new Animation.List({});
        a.betValueItem = a.setupFrame(a.BASIC_BET_FIELD_BACKGROUND);
        a.coinValueItem = a.setupFrame(a.BASIC_COIN_FIELD_BACKGROUND);
        a.textBackgroundList.addItems([a.betValueItem, a.coinValueItem]);
        Game.stage.view.addToRenderLoop(a.textBackgroundList)
    },
    initAnimations: function () {
        var a = this;
        a.initTexts();
        a.initTextBackground();
        a.onGameModeChanged("BASIC")
    },
    updateSubTypeTexts: function (j, k, g, f) {
        var o = this, l = Object.keys(j), r = l.length, p, n, q, c, h;
        for (h = -1; ++h < r;) {
            p = l[h];
            n = j[p];
            q = n.item;
            c = q.prop;
            var b = k + "_" + f + "_" + p, e = c.customProps.defaultMainType + "_" + f + "_" + p,
                d = (Sys.isDefined(o[b]) ? o[b].font : o[e].font), m = o.getAlignment(b, e), a;
            if (Sys.isDefined(o[b]) && Sys.isDefined(o[b].operations)) {
                a = o[b].operations
            } else {
                if (Sys.isDefined(o[b]) && Sys.isDefined(o[b].fillstyle)) {
                    a = [{fillStyle: o[b].fillstyle, drawType: "fill"}]
                } else {
                    a = [{fillStyle: o[e].fillstyle, drawType: "fill"}]
                }
            }
            if (g) {
                o.updateTextItem(q, n.valueFunction.call(o), d, a, m);
                if (!q.prop.running) {
                    q.play()
                }
            } else {
                q.stop()
            }
        }
    },
    updateTextItem: function (l, c, d, a, f, j) {
        var b = l.prop, i = Sys.isDefined(f) ? f : {horizontal: "left", vertical: false},
            h = i.horizontal === "right" ? b.width : 0, e = b.customProps.inMemCanvas,
            g = Animation.utils.text.measureText(c.toString(), d, 0, e.ctx).height / 2, k = Sys.isDefined(j) ? j : 20;
        e.ctx.clearRect(0, 0, e.canvas.width, e.canvas.height);
        if (i.horizontal === "center") {
            h = b.width / 2
        }
        Animation.utils.text.wrapCanvasText(c.toString(), d, h, g, b.width, k, a, e.ctx, i.vertical)
    },
    countUpCallback: function () {
        Interface.Slots.CoinsFieldDesktopView.superclass.countUpCallback.apply(this, arguments)
    },
    showWinUpTo: function () {
        Interface.Slots.CoinsFieldDesktopView.superclass.showWinUpTo.apply(this, arguments)
    },
    setupView: function () {
        var b = this, e = 0, c = "<span class='number'></span>",
            a = "<span style='font:32px NETENT_MyriadProReg;color:#d7af35;'>" + b.model.getWinUpToText() + "</span>",
            d = "";
        b.container = new Sys.Element({id: "coinsField", tag: "div", cls: b.BASE_CSS, renderTo: "gameWrapper"});
        b.marqueeArea = new Sys.Element({tag: "div", cls: "marqueeFrame", renderTo: "coinsField"});
        b.youWon = b.marqueeArea.add(new Sys.Element({
            id: "coinsField_youWon",
            tag: "div",
            cls: b.SUB_COMPONENT_CSS,
            innerHTML: Services.languageManager.getText("MGyouWonCoins").replace("{0}", c),
            style: "visibility:hidden; z-index:" + (e++) + ";font:26px NetentStandardUI;color:#ffffff;top:6px;"
        }));
        b.youWonCoinsElement = b.youWon.el.getElementsByTagName("span")[0] || document.createElement("span");
        b.winUpTo = b.marqueeArea.add(new Sys.Element({
            id: "coinsField_winUpTo",
            tag: "div",
            cls: b.SUB_COMPONENT_CSS + " win-upto",
            innerHTML: Services.languageManager.getText(Language.Keys.winUpTo).replace("{0}", a),
            style: "visibility:hidden; z-index:" + (e++) + ";font:24px NETENT_MyriadProReg;color:#cdcdcd;top:6px;"
        }))
    },
    show: function () {
        Interface.Slots.CoinsFieldDesktopView.superclass.show.apply(this, arguments)
    },
    hideElement: function () {
        Interface.Slots.CoinsFieldDesktopView.superclass.hideElement.apply(this, arguments)
    },
    showElement: function () {
        Interface.Slots.CoinsFieldDesktopView.superclass.showElement.apply(this, arguments)
    },
    showWin: function () {
        var a = this, b = a.model.getWinText();
        this.updateTexts();
        if (b > 0) {
            a.youWonCoinsElement.textContent = b;
            a.show(a.youWon)
        }
    },
    showInfoBanner: function (a) {
        var b = this;
        b.container.el.style.display = "block";
        b.container.el.style.opacity = "1";
        b.marqueeArea.el.style.display = "block";
        b[a.action]();
        b.fireEvent("view:setToggleTimeOut", a)
    },
    hideInfoBanner: function () {
        var a = this;
        a.marqueeArea.el.style.display = "none";
        a.container.el.style.opacity = 0;
        a.container.el.style.display = "none";
        a.fireEvent("view:clearToggleTimeOut")
    },
    onGameModeChanged: function (a) {
        this.updateTexts()
    }
};
TwinSpin.CoinsFieldDesktopView = Sys.extend(Interface.Slots.CoinsFieldDesktopView, TwinSpin.CoinsFieldDesktopView, "TwinSpin.CoinsFieldDesktopView");
Sys.ns("TwinSpin");
TwinSpin.CoinsFieldBaseView = {
    showInfoBanner: function () {
    }, hideInfoBanner: function () {
    }
};
Sys.override(Interface.Slots.CoinsFieldBaseView, TwinSpin.CoinsFieldBaseView);
Sys.ns("TwinSpin");
TwinSpin.CoinsFieldController = {
    CAN_SHOW_TICKER: false, setupEvents: function () {
        var a = this;
        TwinSpin.CoinsFieldController.superclass.setupEvents.apply(a, arguments);
        a.on({
            "notify:IntroSplash.closed": a.onIntroSplashClosed,
            "notify:stateHandler.leavingIdleState": a.onLeavingIdleState,
            "view:setToggleTimeOut": a.setToggleTimeOut,
            "view:clearToggleTimeOut": a.clearToggleTimeOut,
            pageVisibilityChanged_event: a.onPageVisibilityChanged,
            "notify:bigWinCountUp.hidden": a.bigWinCountUpStopped,
            "request:bigWinCountUp.start": a.bigWinCountUpStart,
            "notify:stateHandler.enteringSpinningState": a.resetTickerTape
        })
    }, onPageVisibilityChanged: function (b) {
        var a = this;
        if (a.CAN_SHOW_TICKER) {
            if (b) {
                a.hideInfoBanner()
            } else {
                a.showInfoBanner()
            }
        }
    }, setToggleTimeOut: function () {
        var a = this;
        clearTimeout(a.toggleTimeout);
        a.toggleTimeout = setTimeout(a.showNextInToggleSequence.bind(a), a.currentToggleConfig.displayDuration)
    }, clearToggleTimeOut: function () {
        clearTimeout(this.infoBannertimeout);
        clearTimeout(this.toggleTimeout);
        clearTimeout(this.idleTimeout)
    }, resetTickerTape: function () {
        var a = this;
        a.model.storeData("isSpinning", true);
        a.clearToggleTimeOut()
    }, onLeavingIdleState: function () {
        var a = this;
        TwinSpin.CoinsFieldController.superclass.onEnteringIdleState.apply(a, arguments);
        a.hideInfoBanner()
    }, onIntroSplashClosed: function () {
        var a = this;
        a.TOGGLE_SEQUENCE = [{action: "showWinUpTo", displayDuration: 4000}];
        a.currentToggleConfig = a.TOGGLE_SEQUENCE[0];
        a.CAN_SHOW_TICKER = true;
        a.showInfoBanner()
    }, onEnteringIdleState: function () {
        TwinSpin.CoinsFieldController.superclass.onEnteringIdleState.apply(this, arguments);
        if (!this.model.readData("isBigWin")) {
            this.idleTimeout = setTimeout(this.showInfoBanner.bind(this), 3000)
        }
    }, bigWinCountUpStart: function () {
        this.CAN_SHOW_TICKER = false;
        this.model.storeData("isSpinning", false);
        this.hideInfoBanner()
    }, bigWinCountUpStopped: function () {
        this.CAN_SHOW_TICKER = true;
        if (!this.model.readData("isSpinning")) {
            this.idleTimeout = setTimeout(this.showInfoBanner.bind(this), 3000)
        }
    }, hideInfoBanner: function () {
        this.view.hideInfoBanner()
    }, showInfoBanner: function () {
        var a = this;
        clearTimeout(a.infoBannertimeout);
        clearTimeout(a.idleTimeout);
        a.infoBannertimeout = setTimeout(function () {
            if (a.CAN_SHOW_TICKER) {
                a.view.showInfoBanner(a.currentToggleConfig)
            }
        }, 3000)
    }, showNextInToggleSequence: function () {
        var c = this, b = c.TOGGLE_SEQUENCE, d = c.model.readData("nextToggleIndex") || 0, a = b[d];
        c.model.storeData("nextToggleIndex", (d + 1) % b.length);
        c.currentToggleConfig = a;
        c.view[a.action]();
        clearTimeout(c.toggleTimeout);
        c.toggleTimeout = setTimeout(c.showNextInToggleSequence.bind(c), a.displayDuration)
    }
};
TwinSpin.CoinsFieldController = Sys.extend(Interface.Slots.CoinsFieldController, TwinSpin.CoinsFieldController, "TwinSpin.CoinsFieldController");
Sys.ns("TwinSpin");
TwinSpin.CoinsFieldModel = {
    processServerResponse: function (c) {
        var b = this, a = false;
        TwinSpin.CoinsFieldModel.superclass.processServerResponse.apply(this, arguments);
        if (c.wins) {
            a = (c.wins.winType === "bigWin") ? true : false
        }
        b.storeData("isBigWin", a)
    }
};
TwinSpin.CoinsFieldModel = Sys.extend(Interface.Slots.CoinsFieldModel, TwinSpin.CoinsFieldModel, "TwinSpin.CoinsFieldModel");
Sys.ns("TwinSpin");
TwinSpin.AutoplaySettingsView = {
    KEYPAD_BUTTON_CONFIG: {
        dimensions: {x: 475, y: 608, width: 129, height: 73},
        buttonImages: {
            up: "autoPlayButtonUp",
            down: "autoPlayButtonDown",
            hover: "autoPlayButtonOver",
            disabled: "autoPlayButtonDisabled"
        },
        buttonLabel: {
            width: 125,
            height: 71,
            text: "autoplayButtonTwoLine",
            font: "16px NetentStandardUI",
            lineHeight: 20,
            alignment: "center",
            color: "#ffffff",
            operations: [{
                shadowColor: "#000000",
                shadowBlur: 16,
                shadowOffsetX: 1,
                shadowOffsetY: 1
            }, {fillStyle: "#ffffff", drawType: "fill"}],
            breakOn: "<br>",
            offsetX: -5,
            offsetY: 0
        },
        clickArea: {x: 475, y: 608, width: 112, height: 71}
    }, setUpKeypadButton: function () {
        var b = this, a = Sys.applyProperties({clickCallback: b.onButtonClick.bind(b)}, b.KEYPAD_BUTTON_CONFIG);
        a.buttonLabel.depth = Layering.Game.Slots.Keypad.autoPlay.label;
        if (Sys.isDefined(a.buttonLayoutParameters)) {
            a.buttonLayoutParameters.depth = Layering.Game.Slots.Keypad.autoPlay.button
        } else {
            a.dimensions.depth = Layering.Game.Slots.Keypad.autoPlay.button
        }
        b.keypadButton = new TwinSpin.CanvasButton(a);
        b.keypadPendingDisable.forEach(b.keypadButton.disable.bind(b.keypadButton));
        delete b.keypadPendingDisable
    }
};
TwinSpin.AutoplaySettingsView = Sys.extend(Interface.AutoplaySettingsView, TwinSpin.AutoplaySettingsView, "TwinSpin.AutoplaySettingsView");
Sys.ns("TwinSpin");
TwinSpin.AutoplaySettingsController = {
    setupEvents: function () {
        var a = this;
        TwinSpin.AutoplaySettingsController.superclass.setupEvents.apply(a, arguments);
        a.on({"request:disableKeypad": a.view.disableKeypadButton.bind(a.view)})
    }
};
TwinSpin.AutoplaySettingsController = Sys.extend(Interface.AutoplaySettingsController, TwinSpin.AutoplaySettingsController, "TwinSpin.AutoplaySettingsController");
Sys.ns("TwinSpin");
TwinSpin.BetSettingsDesktopView = {
    BASIC_BETLEVEL_LABEL: {font: "17px NetentStandardUI", fillstyle: "#ffffff"},
    BASIC_BETLEVEL_VALUE: {font: "24px NetentStandardUI", fillstyle: "#ffffff"},
    BASIC_COINVALUE_LABEL: {font: "17px NetentStandardUI", fillstyle: "#ffffff"},
    BASIC_COINVALUE_VALUE: {font: "24px NetentStandardUI", fillstyle: "#ffffff"},
    BETLEVEL_VALUE_SELECTOR_BASE_POSITION: {x: 320, y: 627},
    BETLEVEL_VALUE_SELECTOR_FRAME_POSITION: {x: 358, y: 625},
    COINVALUE_VALUE_SELECTOR_BASE_POSITION: {x: 820, y: 627},
    COINVALUE_VALUE_SELECTOR_FRAME_POSITION: {x: 858, y: 625},
    SELECTOR_FRAME_DIMENSIONS: {width: 70, height: 50},
    VALUE_SELECTOR_POSITION_OFFSET_LABEL: {x: 0, y: -23},
    VALUE_SELECTOR_POSITION_OFFSET_VALUE: {x: 0, y: 5},
    VALUE_SELECTOR_HANDLE_DIMENSIONS: {LEFT: {width: 40, height: 46}, RIGHT: {width: 40, height: 46}},
    VALUE_SELECTOR_HANDLE_POSITION_OFFSET: {LEFT: {x: 0, y: 0}, RIGHT: {x: 106, y: 0}},
    VALUE_SELECTOR_BAR_POSITIONS_OFFSET: {background: {x: 4, y: 50}, fill: {x: 6, y: 52}},
    VALUE_SELECTOR_BAR_DIMENSIONS: {background: {width: 138, height: 15}, fill: {width: 134, height: 10}},
    VALUE_SELECTOR_BAR_BACKGROUND_DISABLED: "selectorBarBackground",
    initAnimations: function () {
        var a = this;
        a.betLevelLabel = Services.languageManager.getText(Language.Keys.level);
        a.coinValueLabel = Services.languageManager.getText(Language.Keys.machinetext_coinvalue);
        a.keyPadLayering = Layering.Game.Slots.Keypad;
        a.itemList = new Animation.List({});
        a.frameItemList = new Animation.List({});
        a.initSelectors();
        a.initFreespinItems();
        a.initFrameItems();
        a.update()
    },
    setupFrame: function (a, c) {
        var b = this;
        return new Animation.Item({
            top: a.y,
            left: a.x,
            width: c.width,
            height: c.height,
            depth: b.keyPadLayering.betLevelSelector + 5,
            image: "selectorFrame"
        })
    },
    initFrameItems: function () {
        var a = this;
        a.betLevelFrame = a.setupFrame(a.BETLEVEL_VALUE_SELECTOR_FRAME_POSITION, a.SELECTOR_FRAME_DIMENSIONS);
        a.coinValueFrame = a.setupFrame(a.COINVALUE_VALUE_SELECTOR_FRAME_POSITION, a.SELECTOR_FRAME_DIMENSIONS);
        a.frameItemList.addItems([a.betLevelFrame, a.coinValueFrame]);
        Game.stage.view.addToRenderLoop(a.frameItemList)
    },
    initSelectors: function () {
        var c = this, b = c.keyPadLayering, a;
        a = c.model.readData("coinValues").map(function (d) {
            return Sys.utils.numberToFixedDigits(d, 3)
        });
        c.selectors = {
            betLevelSelector: new TwinSpin.CanvasValueSelector({
                id: "betLevelSelector",
                x: c.BETLEVEL_VALUE_SELECTOR_BASE_POSITION.x,
                y: c.BETLEVEL_VALUE_SELECTOR_BASE_POSITION.y,
                depth: b.betLevelSelector,
                values: c.model.readData("betLevels"),
                callback: c.onValueChange.bind(c, "betLevelChanged"),
                disabled: !c.model.readData("updatableBetLevels"),
                label: Services.languageManager.getText(Language.Keys.level),
                fontLabel: c.BASIC_BETLEVEL_LABEL.font,
                fontValue: c.BASIC_BETLEVEL_VALUE.font,
                operationsLabel: c.BASIC_BETLEVEL_LABEL.operations,
                fillstyleValue: c.BASIC_BETLEVEL_VALUE.fillstyle,
                positionOffsetLabel: c.VALUE_SELECTOR_POSITION_OFFSET_LABEL,
                positionOffsetValue: c.VALUE_SELECTOR_POSITION_OFFSET_VALUE,
                rightButtonImage: c.VALUE_SELECTOR_RIGHT_BUTTON_IMAGE,
                leftButtonImage: c.VALUE_SELECTOR_LEFT_BUTTON_IMAGE,
                handlePositionOffset: c.VALUE_SELECTOR_HANDLE_POSITION_OFFSET,
                handleDimensions: c.VALUE_SELECTOR_HANDLE_DIMENSIONS,
                handleCollisionBox: c.VALUE_SELECTOR_HANDLE_COLLISION_BOX,
                barBackground: c.VALUE_SELECTOR_BAR_BACKGROUND,
                barBackgroundDisabled: c.VALUE_SELECTOR_BAR_BACKGROUND_DISABLED,
                barFill: c.VALUE_SELECTOR_BAR_FILL,
                barFillDisabled: c.VALUE_SELECTOR_BAR_FILL_DISABLED,
                barDimensions: c.VALUE_SELECTOR_BAR_DIMENSIONS,
                barPositionOffset: c.VALUE_SELECTOR_BAR_POSITIONS_OFFSET
            }),
            coinValueSelector: new TwinSpin.CanvasValueSelector({
                id: "coinValueSelector",
                x: c.COINVALUE_VALUE_SELECTOR_BASE_POSITION.x,
                y: c.COINVALUE_VALUE_SELECTOR_BASE_POSITION.y,
                depth: b.betLevelSelector,
                values: c.model.readData("coinValues"),
                valueNames: a,
                callback: c.onValueChange.bind(c, "coinValueChanged"),
                disabled: !c.model.readData("updatableCoinValues"),
                label: Services.languageManager.getText(Language.Keys.machinetext_coinvalue),
                fontLabel: c.BASIC_COINVALUE_LABEL.font,
                fontValue: c.BASIC_COINVALUE_VALUE.font,
                operationsLabel: c.BASIC_COINVALUE_LABEL.operations,
                fillstyleValue: c.BASIC_COINVALUE_VALUE.fillstyle,
                positionOffsetLabel: c.VALUE_SELECTOR_POSITION_OFFSET_LABEL,
                positionOffsetValue: c.VALUE_SELECTOR_POSITION_OFFSET_VALUE,
                rightButtonImage: c.VALUE_SELECTOR_RIGHT_BUTTON_IMAGE,
                leftButtonImage: c.VALUE_SELECTOR_LEFT_BUTTON_IMAGE,
                handlePositionOffset: c.VALUE_SELECTOR_HANDLE_POSITION_OFFSET,
                handleDimensions: c.VALUE_SELECTOR_HANDLE_DIMENSIONS,
                handleCollisionBox: c.VALUE_SELECTOR_HANDLE_COLLISION_BOX,
                barBackground: c.VALUE_SELECTOR_BAR_BACKGROUND,
                barBackgroundDisabled: c.VALUE_SELECTOR_BAR_BACKGROUND_DISABLED,
                barFill: c.VALUE_SELECTOR_BAR_FILL,
                barFillDisabled: c.VALUE_SELECTOR_BAR_FILL_DISABLED,
                barDimensions: c.VALUE_SELECTOR_BAR_DIMENSIONS,
                barPositionOffset: c.VALUE_SELECTOR_BAR_POSITIONS_OFFSET
            })
        }
    }
};
TwinSpin.BetSettingsDesktopView = Sys.extend(Interface.BetSettingsDesktopView, TwinSpin.BetSettingsDesktopView, "TwinSpin.BetSettingsDesktopView");
Sys.ns("TwinSpin");
TwinSpin.BetSettingsController = {
    setupEvents: function () {
        var a = this;
        TwinSpin.BetSettingsController.superclass.setupEvents.apply(a, arguments);
        a.on({"request:disableKeypad": a.disable})
    }
};
TwinSpin.BetSettingsController = Sys.extend(Interface.BetSettingsController, TwinSpin.BetSettingsController, "TwinSpin.BetSettingsController");
Sys.ns("TwinSpin");
TwinSpin.MaxBetButtonBaseView = {
    KEYPAD_BUTTON_CONFIG: {
        dimensions: {x: 679, y: 608, width: 129, height: 73},
        buttonImages: {
            up: "maxBetButtonUp",
            down: "maxBetButtonDown",
            hover: "maxBetButtonOver",
            disabled: "maxBetButtonDisabled"
        },
        buttonLabel: {
            width: 125,
            height: 71,
            text: "maxbetbuttonTwoLine",
            font: "16px NetentStandardUI",
            lineHeight: 20,
            alignment: "center",
            color: "#ffffff",
            operations: [{
                shadowColor: "#000000",
                shadowBlur: 16,
                shadowOffsetX: 1,
                shadowOffsetY: 1
            }, {fillStyle: "#ffffff", drawType: "fill"}],
            breakOn: "<br>",
            offsetX: 0,
            offsetY: 0
        },
        clickArea: {x: 690, y: 609, width: 110, height: 71}
    }, setUpKeypadButton: function () {
        var b = this, a = Sys.applyProperties({clickCallback: b.onButtonClick.bind(b)}, b.KEYPAD_BUTTON_CONFIG);
        a.buttonLabel.depth = Layering.Game.Slots.Keypad.maxBet.label;
        if (Sys.isDefined(a.buttonLayoutParameters)) {
            a.buttonLayoutParameters.depth = Layering.Game.Slots.Keypad.maxBet.button
        } else {
            a.dimensions.depth = Layering.Game.Slots.Keypad.maxBet.button
        }
        b.keypadButton = new TwinSpin.CanvasButton(a)
    }
};
TwinSpin.MaxBetButtonBaseView = Sys.extend(Interface.Slots.MaxBetButtonBaseView, TwinSpin.MaxBetButtonBaseView, "TwinSpin.MaxBetButtonBaseView");
Sys.ns("TwinSpin");
TwinSpin.CanvasValueSelector = {
    setupLayering: function (a) {
        var b = a.depth;
        this.layeringConfig = {
            background: b,
            barBackground: b + 1,
            value: b + 6,
            barFrame: b + 3,
            barFill: b + 4,
            buttons: b + 4,
            label: b + 4
        }
    }, init: function (a) {
        var b = this;
        Interface.utils.CanvasValueSelector.superclass.init.call(b, a);
        b.currentIndex = 0;
        b.callback = a.callback;
        b.label = a.label;
        b.valueArray = a.values;
        b.valueNameArray = Sys.isDefined(a.valueNames) ? a.valueNames : b.valueArray;
        b.basePosition = {x: a.x, y: a.y};
        b.POSITION_OFFSET_LABEL = a.positionOffsetLabel || b.POSITION_OFFSET_LABEL;
        b.POSITION_OFFSET_VALUE = a.positionOffsetValue || b.POSITION_OFFSET_VALUE;
        if (a.rightButtonImage) {
            b.IMAGE_RIGHT_UP = a.rightButtonImage.up || b.IMAGE_RIGHT_UP;
            b.IMAGE_RIGHT_DOWN = a.rightButtonImage.down || b.IMAGE_RIGHT_DOWN;
            b.IMAGE_RIGHT_HOVER = a.rightButtonImage.hover || b.IMAGE_RIGHT_HOVER;
            b.IMAGE_RIGHT_DISABLED = a.rightButtonImage.disabled || b.IMAGE_RIGHT_DISABLED
        }
        if (a.leftButtonImage) {
            b.IMAGE_LEFT_UP = a.leftButtonImage.up || b.IMAGE_LEFT_UP;
            b.IMAGE_LEFT_DOWN = a.leftButtonImage.down || b.IMAGE_LEFT_DOWN;
            b.IMAGE_LEFT_HOVER = a.leftButtonImage.hover || b.IMAGE_LEFT_HOVER;
            b.IMAGE_LEFT_DISABLED = a.leftButtonImage.disabled || b.IMAGE_LEFT_DISABLED
        }
        b.HANDLE_POSITION_OFFSET = a.handlePositionOffset || b.HANDLE_POSITION_OFFSET;
        b.HANDLE_DIMENSIONS = a.handleDimensions || b.HANDLE_DIMENSIONS;
        b.HANDLE_COLLISION_BOX = a.handleCollisionBox || b.HANDLE_COLLISION_BOX;
        b.BAR_BACKGROUND = a.barBackground || b.BAR_BACKGROUND;
        b.BAR_BACKGROUND_DISABLED = a.barBackgroundDisabled || b.BAR_BACKGROUND_DISABLED;
        b.BAR_FILL = a.barFill || b.BAR_FILL;
        b.BAR_FILL_DISABLED = a.barFillDisabled || b.BAR_FILL_DISABLED;
        b.BAR_DIMENSIONS = a.barDimensions || b.BAR_DIMENSIONS;
        b.BAR_POSITION_OFFSET = a.barPositionOffset || b.BAR_POSITION_OFFSET;
        b.setupLayering(a);
        b.setupFontStyle(a);
        if (Sys.isDefined(a.operationsLabel)) {
            b.LABEL_OPERATIONS = a.operationsLabel
        } else {
            b.LABEL_OPERATIONS = [{fillStyle: b.FILLSTYLE_LABEL, drawType: "fill"}]
        }
        b.initAnimations();
        if (a.disabled === true) {
            b.disable("CanvasValueSelector")
        } else {
            b.enable("CanvasValueSelector")
        }
    }, initLabelItem: function () {
        var a = this, f = Animation.utils.text.createText(a.label, a.FONT_LABEL, 0, a.LABEL_OPERATIONS),
            e = a.HANDLE_DIMENSIONS.RIGHT.width + a.HANDLE_POSITION_OFFSET.RIGHT.x, d = a.POSITION_OFFSET_LABEL,
            c = ((a.basePosition.x + (e / 2)) - (f.width / 2)) + d.x, b = a.basePosition.y + d.y;
        a.labelItem = new Animation.Item({
            top: b,
            left: c,
            width: f.width,
            height: f.height,
            depth: a.layeringConfig.label,
            image: f
        });
        a.animationLists.LABEL.add(a.labelItem)
    }
};
TwinSpin.CanvasValueSelector = Sys.extend(Interface.utils.CanvasValueSelector, TwinSpin.CanvasValueSelector, "TwinSpin.CanvasValueSelector");
Sys.ns("TwinSpin");
TwinSpin.CanvasButton = {
    init: function (a) {
        this.clickArea = a.clickArea || a.dimensions;
        TwinSpin.CanvasButton.superclass.init.apply(this, arguments)
    }, isInputTarget: function (c) {
        var a = this,
            b = Sys.UserInputUtils.getCoordinatesRelativeToElement(c, Game.stage.getGameContainer(), Game.stage.getGameContainer());
        return Sys.UserInputUtils.isUserInputInSegment(b, a.clickArea) && Sys.UserInputUtils.isCoordinateTarget(a.canvasElement, c)
    }, createTextLabel: function (j) {
        var i = this, g = j.text, d = j.offsetY || 0, f = j.offsetX || 0, k = 0, l = j.width, e = j.height,
            c = Animation.utils.getInMemoryCanvas(l, e),
            b = Services.languageManager.hasText(g) ? Services.languageManager.getText(g) : g,
            a = (Sys.isDefined(j.operations) ? j.operations : [{fillStyle: j.color, drawType: "fill"}]);
        if (j.alignment === "center") {
            c.ctx.textAlign = j.alignment;
            k = l / 2
        }
        Animation.utils.text.wrapCanvasText(b, j.font, k, 0, l, j.lineHeight, a, c.ctx, true, j.breakOn);
        return new Animation.Item({
            width: l,
            height: e,
            left: i.dimensions.x + Math.round(Math.abs((l - i.dimensions.width) / 2)) + f,
            top: i.dimensions.y + Math.round(Math.abs((e - i.dimensions.height) / 2)) + d,
            depth: j.depth,
            image: c.canvas
        })
    }
};
TwinSpin.CanvasButton = Sys.extend(Interface.utils.CanvasButton, TwinSpin.CanvasButton, "TwinSpin.CanvasButton");
Sys.ns("TwinSpin");
TwinSpin.WinSituationsDesktopView = {
    borderAnimationLeftOffset: 16,
    borderAnimationTopOffset: 22,
    AnimationItemDimensions: {width: 214, height: 214},
    showWinningSymbolsAnimation: function (b, e, d) {
        var c = this, a = [];
        if (!c.isAllWinningSymbolsAnimationCreated) {
            c.isAllWinningSymbolsAnimationCreated = true;
            c.createWinningSymbolsAnimation()
        }
        c.resetBackgroundAnimationList();
        Sys.each(b.positions, function (i) {
            var g, j, h, f;
            g = i.reelIndex;
            j = i.symbolIndex;
            if (Sys.isDefined(c.symbolAnimationItems[g][j])) {
                h = c.symbolAnimationItems[g][j];
                a.push(h);
                c.configureSymbolAnimation(h)
            }
            if (Sys.isDefined(c.symbolBackgroundAnimationItems[g][j])) {
                f = c.symbolBackgroundAnimationItems[g][j];
                c.configureSymbolBackgroundAnimation(f)
            }
        });
        c.animationList.play(a);
        c.symbolBackgroundAnimationList.play()
    },
    configureSymbolAnimation: function (e) {
        var d = this, c, a = Resources.readData("spriteConfigurations").borderAnimationSprite,
            g = Game.stage.view.animationManager.getSpriteSequence("borderAnimation"),
            f = Resources.readData("config").winSituationsDisplay.winSituationMinimumDisplayTime,
            b = d.model.readData("winType");
        c = Resources.readData("config").winSituationsDisplay[b.toUpperCase() + "_SYM_BORDER_ANIMATION_TIME"];
        e.prop = Sys.apply(e.prop, {
            image: d.ANIMATION_IMAGES.borderAnimation,
            frameWidth: a.frameWidth,
            frameHeight: a.frameHeight,
            totalSpriteWidth: a.totalSpriteWidth,
            totalSpriteHeight: a.totalSpriteHeight,
            spriteArray: g,
            operations: {
                sprite: [{time: 0, value: 0}, {time: c, value: g.length - 1, goTo: 0}],
                fade: [{time: 0, value: 1}, {time: f, value: 1, fireEvent: {event: "view:animationComplete", scope: d}}]
            }
        });
        e.restore()
    },
    configureSymbolBackgroundAnimation: function (c) {
        var b = this, d = Resources.readData("config").winSituationsDisplay.BG_GLOW_ANIM_TIME,
            a = b.model.readData("winType");
        if (a === "smallWin") {
            c.prop = Sys.apply(c.prop, {
                depth: Layering.Game.Slots.WinningSymbols.animationItems - 1,
                operations: {fade: [{time: 0, value: 1}, {time: 60, value: 1, goTo: 0}]}
            })
        } else {
            if (a === "mediumWin") {
                c.prop = Sys.apply(c.prop, {
                    depth: Layering.Game.Slots.WinningSymbols.animationItems - 1,
                    operations: {
                        fade: [{time: 0, value: 1}, {time: 300, value: 1}, {time: 350, value: 0}, {
                            time: 700,
                            value: 0
                        }, {time: 750, value: 1, goTo: 0}]
                    }
                })
            } else {
                c.prop = Sys.apply(c.prop, {
                    depth: Layering.Game.Slots.WinningSymbols.animationItems - 1,
                    operations: {
                        fade: [{time: 0, value: 1}, {time: 100, value: 1}, {time: 100, value: 0}, {
                            time: 230,
                            value: 0
                        }, {time: 330, value: 1, goTo: 0}]
                    }
                })
            }
        }
        c.restore()
    }
};
TwinSpin.WinSituationsDesktopView = Sys.extend(TwinSpin.WinSituationsView, TwinSpin.WinSituationsDesktopView, "TwinSpin.WinSituationsDesktopView");
Sys.ns("TwinSpin");
TwinSpin.SpinSettingsView = {
    initAdvancedAutoplaySettings: function () {
        TwinSpin.SpinSettingsView.superclass.initAdvancedAutoplaySettings.apply(this, arguments);
        this.advancedSettings.stopAutoplayIfFreeSpinWon.getContainer().el.style.display = "none"
    }
};
TwinSpin.SpinSettingsView = Sys.extend(Interface.SpinSettingsView, TwinSpin.SpinSettingsView, "TwinSpin.SpinSettingsView");
Sys.ns("TwinSpin");
TwinSpin.Splash = {
    getMixinDependencies: function () {
        return ["serverResponse", "animation", {userInput: {inputEvents: ["end", "hover"]}}]
    }, getStateChanges: function () {
        var a = this.model;
        return {
            Splash: {
                state: {
                    name: "Splash", execute: function () {
                    }, waitEvents: {"notify:IntroSplash.closed": false}
                }
            }, beforeLoaderClose: {
                queue: [function (b) {
                    if (a.readData("animationRequested")) {
                        b.stateHandler.pushState(b.states.Splash)
                    }
                }]
            }
        }
    }, getDefaultMVCClasses: function () {
        return {model: TwinSpin.SplashModel, controller: TwinSpin.SplashController, view: TwinSpin.SplashView}
    }
};
TwinSpin.Splash = Sys.extend(Core.Module, TwinSpin.Splash, "TwinSpin.Splash");
Sys.ns("TwinSpin");
TwinSpin.SplashController = {
    setupEvents: function () {
        var a = this;
        a.on({
            "notify:stateHandler.enteringBeforeLoaderCloseState": a.start,
            "request:IntroSplash.close": a.close,
            "notify:stateHandler.leavingIdleState": a.onLeavingIdleState,
            "view:checkBoxClick": a.updateShowNextTime,
            "view:closed": a.onClosed
        })
    }, start: function () {
        var a = this;
        if (a.model.readData("animationRequested") && a.model.readData("showNextTime") === true) {
            a.view.startAllAnimations();
            a.show();
            a.startListeningToUserInput()
        } else {
            a.close()
        }
    }, show: function () {
        var a = this;
        a.view.show();
        a.fireEvent("request:disableBasicGamePanel", "featureSplash");
        a.fireEvent("request:spinButton.hide", "featureSplash");
        a.fireEvent("notify:featureSplash.showing");
        a.closed = false;
        a.splashTimeout = setTimeout(function () {
            a.close()
        }, 20000)
    }, close: function () {
        var a = this;
        if (!a.closed) {
            a.closed = true;
            a.view.close()
        }
        window.clearTimeout(a.splashTimeout)
    }, onClosed: function () {
        var a = this;
        a.closed = true;
        a.stopListeningToUserInput();
        a.fireEvent("request:enableBasicGamePanel", "featureSplash");
        a.fireEvent("request:spinButton.show", "featureSplash");
        a.fireEvent("notify:IntroSplash.closed");
        a.fireEvent("notify:featureSplash.closed")
    }, updateShowNextTime: function () {
        var a = this, b = !a.model.readData("showNextTime");
        a.model.storeData("showNextTime", b);
        a.view.updateCheckBox(b);
        a.fireEvent("request:settingsManager.storeData", "showFeatureSplash", b, true)
    }, onLeavingIdleState: function () {
        this.close()
    }
};
TwinSpin.SplashController = Sys.extend(Core.Controller, TwinSpin.SplashController, "TwinSpin.SplashController");
Sys.ns("TwinSpin");
TwinSpin.SplashModel = {
    processServerResponse: function (b) {
        var a = this;
        if (b.gamestate.current === "basic" && b.clientaction === "init" && b.restore === false) {
            a.storeData("animationRequested", true)
        } else {
            a.storeData("animationRequested", false)
        }
        a.storeData("restore", b.restore)
    }, setupData: function () {
        var a = this,
            b = !(Services.localStorageManager.hasData("showFeatureSplash") && Services.localStorageManager.readData("showFeatureSplash") === "false");
        a.storeData("showNextTime", b);
        a.storeData("autoClose", false)
    }
};
TwinSpin.SplashModel = Sys.extend(Core.Model, TwinSpin.SplashModel, "TwinSpin.SplashModel");
Sys.ns("TwinSpin");
TwinSpin.SplashView = {
    FS_TEXT: {text: "splashScreenDescription"},
    SPLASH_MOVIE_SRC: "splash_movie",
    TWINKLE_DOTS_CONFIG: [{DELAY: 0, left: 347, top: 48, square: 1}, {
        DELAY: 1000,
        left: 386,
        top: 68,
        square: 1
    }, {DELAY: 1500, left: 500, top: 96, square: 1}, {DELAY: 550, left: 443, top: 87, square: 1}, {
        DELAY: 500,
        left: 539,
        top: 87,
        square: 1
    }, {DELAY: 1500, left: 558, top: 48, square: 1}, {DELAY: 1700, left: 596, top: 97, square: 1}, {
        DELAY: 2000,
        left: 654,
        top: 58,
        square: 1
    }, {DELAY: 1000, left: 703, top: 97, square: 1}, {DELAY: 300, left: 713, top: 50, square: 1}, {
        DELAY: 2000,
        left: 818,
        top: 87,
        square: 1
    }, {DELAY: 1000, left: 779, top: 48, square: 1}, {DELAY: 2000, left: 741, top: 77, square: 1}, {
        DELAY: 100,
        left: 741,
        top: 97,
        square: 1
    }, {DELAY: 0, left: 876, top: 77, square: 1}, {DELAY: 1000, left: 914, top: 97, square: 1}],
    SOUND_CLICK: "buttonClick",
    LOGO_GLOW: {left: 250, top: 15, width: 773, height: 131},
    MEM_CANVAS: {width: 1280, height: 720},
    constructor: function () {
        TwinSpin.SplashView.superclass.constructor.apply(this, arguments);
        this.setupContainer()
    },
    initAnimations: function () {
        var c = this, d, b = Environment.getResolution(), a;
        c.scaleFactor = c.getScaleFactor();
        c.inMemCanvas = document.createElement("canvas");
        c.inMemCanvas.width = c.MEM_CANVAS.width;
        c.inMemCanvas.height = c.MEM_CANVAS.height;
        c.inMemContext = c.inMemCanvas.getContext("2d");
        c.createTextStrings();
        c.animationList = new Animation.CanvasAnimationList({});
        c.animationList.add(c.createBackgroundItem());
        c.continueBtn = c.createStartButton();
        c.chkBtn = c.createCheckBoxItem();
        c.winUpTo = c.createWinUpToText();
        c.waysToWin = c.createWaysToWinText();
        c.featureText = c.createFeatureText(c.FS_TEXT);
        c.netEntProduction = c.createNetEntProdLabelItem();
        c.logoGlow = c.createGameLogoFlashAnimationItem(c.LOGO_GLOW);
        c.animationList.addItems([c.logoGlow, c.netEntProduction]);
        c.container.add(c.winUpTo);
        c.container.add(c.waysToWin);
        c.container.add(c.featureText);
        c.container.add(c.continueBtn);
        c.container.add(c.chkBtn);
        c.animationList.add(c.getMovieAnimation(c.container));
        c.TWINKLE_DOTS_CONFIG.forEach(function (f, e, g) {
            d = c.createTwinkleAnimationItem(f, f.left, f.top);
            c.animationList.add(d)
        });
        Game.stage.view.addToRenderLoop(c.animationList);
        c.animationList.stop()
    },
    setupContainer: function () {
        var a = this;
        a.container = new Sys.Element({id: "SplashScreen", tag: "div", renderTo: "gameWrapper"})
    },
    createNetEntProdLabelItem: function () {
        var c = "A NETENT PRODUCTION", b = "13px NetentStandardUI", a = -10,
            d = Animation.utils.text.createText(c, b, 0, [{fillStyle: "#ffffff"}]);
        return new Animation.Item({
            left: 1100,
            top: 8,
            width: d.width,
            height: d.height,
            depth: TwinSpin.Layering.Splashes.text,
            image: d
        })
    },
    createGameLogoFlashAnimationItem: function (a) {
        var b = new Animation.CanvasAnimationItem({
            left: a.left,
            top: a.top,
            width: a.width,
            height: a.height,
            depth: TwinSpin.Layering.Splashes.text,
            image: "logo_glow",
            operations: {fade: [{time: 4000, value: 0}, {time: 4001, value: 1}, {time: 5000, value: 0}]}
        });
        return b
    },
    createTwinkleAnimationItem: function (c, g, f) {
        var a = Resources.readData("spriteConfigurations").twinkleAnimationSprite,
            e = Game.stage.view.animationManager.getSpriteSequence("twinkleAnimation"), b = c.DELAY,
            d = new Animation.CanvasAnimationItem({
                left: g,
                top: f,
                delay: b,
                width: a.frameWidth,
                height: a.frameHeight,
                depth: TwinSpin.Layering.Splashes.text,
                image: "twinkleAnimationSprite",
                frameWidth: a.frameWidth,
                frameHeight: a.frameHeight,
                totalSpriteWidth: a.totalSpriteWidth,
                spriteArray: e,
                operations: {
                    sprite: [{time: 0, value: 0}, {time: 1000, value: e.length - 1}, {
                        time: 1001,
                        value: 0
                    }, {time: 1500, value: 0, goTo: 0}]
                }
            });
        return d
    },
    getMovieAnimation: function (b) {
        var a = this;
        return new Animation.VideoItem({
            src: a.SPLASH_MOVIE_SRC,
            width: 416,
            height: 500,
            top: "199px",
            left: "64px",
            position: "absolute",
            poster: "splash_movie_poster",
            zIndex: 220,
            container: b
        })
    },
    createFeatureText: function (b) {
        var a = Services.languageManager.getText(b.text);
        return new Sys.Element({tag: "div", "class": "featureText-splash", textContent: a})
    },
    startAllAnimations: function () {
        var a = this;
        a.animationList.items[0].play();
        a.animationList.play();
        a.winUpTo.addCSSClass("show");
        a.waysToWin.addCSSClass("show");
        a.featureText.addCSSClass("show");
        a.continueBtn.addCSSClass("show");
        a.chkBtn.addCSSClass("show")
    },
    createWinUpToText: function () {
        return new Sys.Element({tag: "div", "class": "winuptotext-oct", textContent: this.strWinUpTo})
    },
    createWaysToWinText: function () {
        return new Sys.Element({tag: "div", "class": "waystowintext-oct", textContent: this.strWaysToWin})
    },
    getScaleFactor: function () {
        return Resources.readData("config").desktopResourceToVirtualScale
    },
    createTextStrings: function () {
        var a = this;
        a.strWinUpTo = Services.languageManager.getText("OCTwinUpTo", [Resources.readData("config").clientConfig.coinsfieldscroller.element[0].value]).toUpperCase();
        a.strWaysToWin = Services.languageManager.getText("waysToWin243dup").toUpperCase();
        a.strStartGame = Services.languageManager.getText("button_CONTINUE").toUpperCase();
        a.strCheckBox = Services.languageManager.getText("dontShowNextTime")
    },
    createBackgroundItem: function () {
        var a = this, b = TwinSpin.Layering.Splashes.background;
        return new Animation.CanvasAnimationItem({
            fullScreen: true,
            canvasIndex: 1,
            depth: b,
            image: "Splash_BG",
            width: 1280,
            height: 720
        })
    },
    createStartButton: function () {
        var b = this, a, c, d;
        c = new TwinSpin.PaytableDOMButton({
            id: "splashContinue",
            tag: "div",
            baseCSS: "splash_continue",
            clickCallback: b.close.bind(b)
        });
        c.SOUND_CLICK = b.SOUND_CLICK;
        d = c.getContainer();
        a = new Sys.Element({tag: "label", "class": "continue_text", textContent: b.strStartGame});
        d.add(a);
        return d
    },
    createCheckBoxItem: function () {
        var d = this, c, b, e, a;
        a = new Sys.Element({tag: "div", "class": "checkbox_container"});
        b = new TwinSpin.PaytableDOMButton({
            id: "splashCheckBox",
            tag: "div",
            baseCSS: "splash_checkBox",
            clickCallback: d.onCheckBoxClick.bind(d)
        });
        b.SOUND_CLICK = d.SOUND_CLICK;
        a.add(b.getContainer());
        d.checkBoxContainer = b.getContainer();
        c = new Sys.Element({tag: "label", "class": "checkbox_text", textContent: d.strCheckBox});
        a.add(c);
        return a
    },
    onCheckBoxClick: function () {
        this.fireEvent("view:checkBoxClick")
    },
    show: function () {
        var a = this;
        a.animationList.items[0].play();
        a.animationList.play();
        a.winUpTo.addCSSClass("show");
        a.waysToWin.addCSSClass("show");
        a.featureText.addCSSClass("show");
        a.continueBtn.addCSSClass("show");
        a.chkBtn.addCSSClass("show")
    },
    close: function () {
        var a = this;
        if (a.animationList) {
            a.animationList.items[0].stop();
            a.animationList.stop();
            a.winUpTo.removeCSSClass("show");
            a.waysToWin.removeCSSClass("show");
            a.featureText.removeCSSClass("show");
            a.continueBtn.removeCSSClass("show");
            a.chkBtn.removeCSSClass("show");
            a.fireEvent("view:closed")
        }
    },
    updateCheckBox: function (a) {
        (a) ? this.checkBoxContainer.removeCSSClass("splash_check_active") : this.checkBoxContainer.addCSSClass("splash_check_active")
    }
};
TwinSpin.SplashView = Sys.extend(Core.View, TwinSpin.SplashView, "TwinSpin.SplashView");
Sys.ns("TwinSpin");
Sys.override(Animation.VideoItem, {
    play: function () {
        var a = this;
        if (!a.isRunning()) {
            a.restore();
            a.videoEl.load()
        }
        a.prop.paused = false;
        a.videoEl.play();
        a.videoEl.style.display = "block"
    }, setupVideo: function (c) {
        var e = this, b = document.createElement("video"), d = Resources.readData("videos"),
            a = Resources.readData("animationImages");
        b.src = d[c.src];
        b.preload = "auto";
        b.loop = Sys.isDefined(c.loop) ? c.loop : true;
        b.autoplay = Sys.isDefined(c.autoplay) ? c.autoplay : true;
        b.type = Sys.isDefined(c.type) ? c.type : undefined;
        b.width = Sys.isDefined(c.width) ? c.width : undefined;
        b.height = Sys.isDefined(c.height) ? c.height : undefined;
        b.poster = Sys.isDefined(c.poster) ? a[c.poster].src : undefined;
        b.style.position = Sys.isDefined(c.position) ? c.position : undefined;
        b.style.top = Sys.isDefined(c.top) ? c.top : undefined;
        b.style.left = Sys.isDefined(c.left) ? c.left : undefined;
        b.style.zIndex = Sys.isDefined(c.zIndex) ? c.zIndex : undefined;
        b.style.display = "none";
        Sys.isDefined(c.container) ? c.container.addChildren([b]) : document.body.appendChild(b);
        e.videoEl = b
    }, stop: function () {
        var a = this;
        Animation.VideoItem.superclass.stop.apply(a, arguments);
        a.videoEl.pause();
        if (a.videoEl.currentTime > 0) {
            a.videoEl.currentTime = 0
        }
        a.videoEl.style.display = "none"
    }
});
Sys.ns("TwinSpin");
TwinSpin.StandardWinController = {
    setupEvents: function () {
        var a = this;
        TwinSpin.StandardWinController.superclass.setupEvents.apply(a, arguments);
        a.on({
            "notify:spin.reelStoppedSpinning": a.onReelStoppedSpinningState,
            "notify:quickStopper.quickStop": a.hideWinBanner,
            "notify:linkedReels.SetReels": a.hideWinBanner,
            "notify:settingsManager.settingChanged": a.onSettingChanged
        })
    }, onSettingChanged: function (a, c) {
        var b = this;
        if (a === "autoPlayNrSpins" && c > 0) {
            b.handleUserInput()
        }
    }, handleUserInput: function () {
        var a = this;
        if (a.model.readData("inNoWinPresentation")) {
            a.abortNoWinPresentation()
        } else {
            if (a.model.isState("countingUp")) {
                if (a.model.readData("countUpDisplay") === "winBanner") {
                    a.fireEvent("request:winBanner.showTotal", {showUntilStopped: true})
                } else {
                    a.fireEvent("request:coinsField.showWin")
                }
                a.onShowingTotal();
                a.fireEvent("notify:standardWin.countupAborted")
            } else {
                if (a.model.isState("showingTotal")) {
                    a.endPresentation(true)
                }
            }
        }
    }, onShowingTotal: function () {
        var a = this;
        if (a.model.isState("countingUp")) {
            a.model.setState("showingTotal");
            a.fireEvent("notify:standardWin.showingWinTotal");
            a.fireEvent("request:coinsField.showWin");
            a.fireEvent("request:cashField.showWin");
            if (a.eventsToWaitFor.indexOf("notify:winSituationsDisplay.finishedShowingAllWins") === -1) {
                if (Platform.isDesktopDevice) {
                    a.endPresentation(false)
                } else {
                    a.showWinTimeout = setTimeout(a.endPresentation.bind(a, false), a.model.readData("totalWinDisplayDuration"))
                }
            }
        }
    }, endPresentation: function (b) {
        var a = this;
        if (!a.model.isState("showingTotal") && !a.model.readData("inNoWinPresentation")) {
            return
        }
        a.stopListeningToUserInput();
        a.model.setState("complete");
        a.fireEvent("request:winSituationsDisplay.abort");
        a.showWinTimeout = setTimeout(function () {
            a.hideWinBanner()
        }, a.model.readData("totalWinDisplayDuration"));
        if (a.model.shouldToggleWins()) {
            a.fireEvent("request:winSituationsDisplay.toggleWins")
        }
        a.fireEvent("notify:standardWin.presentationComplete", b)
    }, onReelStoppedSpinningState: function (a) {
        if (!this.model.readData("isNoWin") && a === 0) {
            this.hideWinBanner()
        }
    }, hideWinBanner: function () {
        clearTimeout(this.showWinTimeout);
        this.fireEvent("request:winBanner.hide")
    }, startPresentation: function () {
        var a = this;
        a.model.setCountUpTime();
        TwinSpin.StandardWinController.superclass.startPresentation.apply(a, arguments)
    }
};
TwinSpin.StandardWinController = Sys.extend(Core.Slots.StandardWinController, TwinSpin.StandardWinController, "TwinSpin.StandardWinController");
Sys.ns("TwinSpin");
TwinSpin.StandardWinModel = {
    isAutoPlay: function () {
        var a = Services.settingsManager.getSetting("autoPlayNrSpins");
        return (!Sys.isDefined(a) || a > 0)
    }, setCountUpTime: function () {
        var b = this, a = b.readData("winClip");
        b.storeData("countUpDuration", (Platform.isDesktopDevice && b.isAutoPlay()) ? 0 : b.COUNT_UP_DURATIONS[a])
    }
};
TwinSpin.StandardWinModel = Sys.extend(Core.Slots.StandardWinModel, TwinSpin.StandardWinModel, "TwinSpin.StandardWinModel");
Sys.ns("TwinSpin");
TwinSpin.QuickStopperView = {
    quickStop: function () {
    }
};
TwinSpin.QuickStopperView = Sys.extend(Game.Slots.QuickStopperView, TwinSpin.QuickStopperView, "TwinSpin.QuickStopperView");
Sys.override(Animation.BufferedReelList, {
    getReelItemsForRendering: function (w, j, p) {
        var C = this, z = C.shouldUseMotionBlur(), o = C.maxBlurredSymbolWidth, a = C.maxBlurredSymbolHeight,
            m = C.orientation === "vertical" ? a : o, u, v, y, h = [], r, t, d, b, q,
            B = z ? C.blurredSymbolWidths : C.symbolWidths, g = z ? C.blurredSymbolHeights : C.symbolHeights, l, A, k,
            c, n, x, s, e = Environment.getVirtualToWindowScale(3), f = w.length;
        C.indexOfFirstOutcomeItem = C.animationItems.length - 1;
        for (v = -1; ++v < f;) {
            if (w[v].isOutcomeSymbol && v < C.indexOfFirstOutcomeItem) {
                C.indexOfFirstOutcomeItem = v
            }
            y = C.animationItems[v];
            r = w[v].symbol;
            b = Sys.isDefined(B[r]) ? r : "standard";
            q = Sys.isDefined(g[r]) ? r : "standard";
            t = w[v].position;
            d = m;
            l = B[b];
            A = g[q];
            n = C.orientation === "vertical" ? A : l;
            x = (m - n) / 2;
            s = 0;
            if (z) {
                r += "-BLURRED"
            } else {
                if (C.shouldUseSpecialEffect(r)) {
                    r += "-SPECIAL_EFFECT"
                }
            }
            k = Game.stage.view.animationManager.images[r];
            c = (k.width || k.naturalWidth) / Math.round(l * e);
            if (t < 0) {
                s = -t;
                t = 0;
                d -= s
            }
            if (x > 0) {
                if (s > x) {
                    s -= x;
                    d -= x
                } else {
                    if (s + d < x) {
                        s = 0;
                        d = 0
                    } else {
                        d += (x - s);
                        t += (x - s);
                        s = 0
                    }
                }
                if (s + d > n) {
                    d = n - s
                }
            }
            u = (t + d) - C.reelAreaLength;
            if (u > 0) {
                d -= u
            }
            if (y.isRunning() && d > 0) {
                t = Math.floor(t);
                d = Math.ceil(d);
                s = Math.floor(s);
                if (C.spinDirection === "negative") {
                    t = C.reelAreaLength - t;
                    t -= d;
                    s = s === 0 ? n - d : 0
                }
                if (C.orientation === "vertical") {
                    y.prop = Sys.applyProperties(y.prop, {
                        image: r,
                        SX: 0,
                        SY: Math.floor(s * e),
                        SWidth: Math.floor(l * e),
                        SHeight: Math.floor(d * e),
                        left: Math.floor(C.left + (o - l) / 2),
                        top: C.top + t,
                        width: l,
                        height: d,
                        depth: C.baseDepth,
                        pivot: {x: -(l / 2), y: -(d / 2)}
                    })
                } else {
                    y.prop = Sys.applyProperties(y.prop, {
                        image: r,
                        SX: Math.floor(s * e),
                        SY: 0,
                        SWidth: Math.floor(d * e),
                        SHeight: Math.floor(A * e),
                        left: C.left + t,
                        top: Math.floor(C.top + (a - A) / 2),
                        width: d,
                        height: A,
                        depth: C.baseDepth,
                        pivot: {x: -(d / 2), y: -(A / 2)}
                    })
                }
                if (c !== 1) {
                    y.prop.SWidth = y.prop.SWidth * c;
                    y.prop.SHeight = y.prop.SHeight * c;
                    y.prop.SX = y.prop.SX * c;
                    y.prop.SY = y.prop.SY * c
                }
                if (y.prop.SWidth > 0 && y.prop.SHeight > 0) {
                    y.run(j, p);
                    h.push(y)
                } else {
                    y.prop.image = undefined
                }
            } else {
                y.prop.image = undefined
            }
        }
        return h
    }
});
Sys.ns("Integration.OpenBet");
Integration.OpenBet.ResponseParserControllerOverride = {
    doIntegrationSpecificResponseHandling: function (c) {
        var b, a;
        if (!Sys.isDefined(c) || (c.clientaction === "rcinfo" || c.clientaction === "rcreset")) {
            return c
        }
        b = c.credit + c.openbet.freebets;
        a = c.openbet.rgitoken;
        if (!isNaN(b)) {
            c.credit = b
        }
        if (Sys.isDefined(a)) {
            Resources.readData("extraParams")["openbet.rgitoken"] = encodeURIComponent(a)
        }
        return c
    }
};
Integration.OpenBet.ServerManagerModelOverride = {
    doIntegrationSpecificRequestUrlUpdates: function (a) {
        var c = Resources.readData("extraParams"), b = a;
        Sys.iterate(c, function (e, d) {
            if (e.match(/openbet\.\w+/)) {
                b += "&" + e + "=" + d
            }
        });
        return b
    }
};
Integration.OpenBet.ErrorManagerControllerOverride = {
    handleIntegrationSpecificErrors: function (b) {
        var c = this, d = Sys.utils.getErrorCode(b), a = Sys.utils.getResponseParameter("errordata", b);
        if (!Sys.isDefined(d) || d < 997 || d > 1000) {
            return false
        }
        if (Sys.isDefined(a)) {
            a = decodeURIComponent(a);
            a = a.replace(/\+/g, " ")
        }
        return {title: "Error (" + d + ")", text: a, buttons: c.getButtons([{type: "casino", reason: 3}]), fatal: true}
    }
};
Integration.OpenBet.GameHistoryOverride = function () {
    var a = Game.getHistoryTab;
    Game.getHistoryTab = function (c, d, b) {
        if (b) {
            a(c, d, b)
        }
    }
};
Integration.OpenBet.applyOverrides = function () {
    var a;
    Sys.override(Core.ResponseParserController, Integration.OpenBet.ResponseParserControllerOverride);
    Sys.override(Core.ServerManagerModel, Integration.OpenBet.ServerManagerModelOverride);
    Sys.override(Core.ErrorManagerController, Integration.OpenBet.ErrorManagerControllerOverride);
    a = Integration.OpenBet.GameHistoryOverride;
    a()
};
if (Sys.openBetMode) {
    Integration.OpenBet.applyOverrides()
}
Sys.ns("Integration.GCM");
Integration.GCM.ErrorManagerModel = {
    setupDialogConfig: function () {
        var a = {}, b;
        Sys.each([11, 13], function (c) {
            b = Services.languageManager.getText(String(c));
            a[c] = {
                category: "RECOVERABLE_ERROR",
                severity: "INFO",
                errorCode: "LIMIT_EXCEEDED",
                message: b,
                extraParameters: {
                    originalError: c,
                    originalTitle: Services.languageManager.getText(Language.Keys.playLimit),
                    originalMessage: b
                },
                revert: true
            }
        });
        b = Services.languageManager.getText(Language.Keys.freeRounds_expired);
        a[12] = {
            category: "RECOVERABLE_ERROR",
            severity: "INFO",
            errorCode: "FREEROUNDS_EXPIRED",
            message: b,
            extraParameters: {
                originalError: 12,
                originalTitle: Services.languageManager.getText(Language.Keys.freeRounds_expired)
            },
            revert: false
        };
        b = Services.languageManager.getText(Language.Keys.returnToLobby);
        a[20] = {
            category: "CONNECTION_ERROR",
            severity: "ERROR",
            errorCode: "SESSION_TIMEOUT",
            message: b,
            extraParameters: {
                originalError: 20,
                originalTitle: Services.languageManager.getText(Language.Keys.btn_sessionTimeOut),
                originalMessage: b,
                reason: 3
            },
            revert: false
        };
        Sys.each([10, 15, 51, 100, 101, 102], function (c) {
            b = Services.languageManager.getText(Language.Keys.deposit);
            a[c] = {
                category: "INSUFFICIENT_FUNDS",
                severity: "INFO",
                errorCode: "CLIENT_INSUFFICIENT_FUNDS",
                message: b,
                extraParameters: {
                    originalError: c,
                    originalTitle: Services.languageManager.getText(Language.Keys.outOfMoney),
                    originalMessage: b,
                    reason: 5
                },
                revert: true
            }
        });
        Sys.each([0, 53, 56, 58], function (c) {
            b = Services.languageManager.getText(Language.Keys.gameUnavailable);
            a[c] = {
                category: "CONNECTION_ERROR",
                severity: "ERROR",
                errorCode: "CANNOT_CONNECT_TO_SERVER",
                message: b,
                extraParameters: {
                    originalError: c,
                    originalTitle: Services.languageManager.getText(Language.Keys.gameUnavailable),
                    reason: 9
                },
                revert: false
            }
        });
        b = Services.languageManager.getText(Language.Keys.accountUnavailable);
        a[70] = {
            category: "LOGIN_ERROR",
            severity: "ERROR",
            errorCode: "ACCOUNT_UNAVAILABLE",
            message: b,
            extraParameters: {
                originalError: 70,
                originalTitle: Services.languageManager.getText(Language.Keys.accountUnavailable)
            },
            revert: false
        };
        b = Services.languageManager.getText(Language.Keys.reload);
        a.http = {
            category: "CONNECTION_ERROR",
            severity: "ERROR",
            errorCode: "CANNOT_CONNECT_TO_SERVER",
            message: b,
            extraParameters: {
                originalError: "httpError",
                originalTitle: Services.languageManager.getText(Language.Keys.connectionLost),
                originalMessage: b,
                reason: 9
            },
            revert: false
        };
        b = Services.languageManager.getText(Language.Keys.deposit);
        a.clientOutOfMoney = {
            category: "INSUFFICIENT_FUNDS",
            severity: "INFO",
            errorCode: "CLIENT_INSUFFICIENT_FUNDS",
            message: b,
            extraParameters: {
                originalError: "clientOutOfMoney",
                originalTitle: Services.languageManager.getText(Language.Keys.outOfMoney),
                reason: 9
            },
            revert: false
        };
        b = Services.languageManager.getText(Language.Keys.returnToLobby);
        a.generic = {
            category: "NON_RECOVERABLE_ERROR",
            severity: "ERROR",
            errorCode: "CLIENTERROR",
            message: b,
            extraParameters: {
                originalError: "generic",
                originalTitle: Services.languageManager.getText(Language.Keys.error),
                originalMessage: b,
                reason: 9
            },
            revert: false
        };
        return a
    }
};
Integration.GCM.ErrorManagerDesktopModel = {
    setupDialogConfig: function () {
        return Core.ErrorManagerDesktopModel.superclass.setupDialogConfig.apply(this, arguments)
    }
};
Integration.GCM.ErrorManagerController = {
    showDialog: function (a) {
        var b = (a.errorCode === "http") ? 0 : a.errorCode;
        this.fireEvent("notify:errorManager.error", b, Services.languageManager.getText(b));
        this.fireEvent("request:gcmProxy.handleError", a)
    }, handleIntegrationSpecificErrors: function (b) {
        var a = Sys.utils.getResponseParameter("openbet.error.xml", b), c;
        if (Sys.isDefined(a)) {
            c = {RGIError: true, RGIXML: a.replace(/\+/g, " ")}
        }
        return c
    }, getDialogConfig: function (a) {
        return this.model.getDialogConfig(a)
    }, handleClientOutOfMoneyError: function () {
        this.showDialogForErrorCode("clientOutOfMoney")
    }
};
Integration.GCM.DialogWindowController = {
    onShowDialogRequest: function (b) {
        var c = this, e = b.severity === "stopped", d = {
            category: "MULTI_CHOICE_DIALOG",
            severity: e ? "ERROR" : "INFO",
            message: Sys.isDefined(b.text) ? b.text : b.title,
            errorCode: "ERROR",
            actions: [],
            revert: false,
            extraParameters: {}
        }, a = [];
        Sys.each(b.buttons, function (f) {
            a.push(f.text);
            d.actions.push(f.action)
        });
        d.extraParameters.options = a;
        c.fireEvent("request:gcmProxy.handleError", d);
        c.model.storeData("currentDialogConfig", b);
        c.model.setState("showing")
    }
};
Integration.GCM.SlowRequestAnimationController = {
    onShowDialog: function () {
    }
};
(function () {
    if (Sys.isGcmEnabled) {
        Sys.override(Core.ErrorManagerModel, Integration.GCM.ErrorManagerModel);
        Sys.override(Core.ErrorManagerController, Integration.GCM.ErrorManagerController);
        Sys.override(Core.DialogWindowController, Integration.GCM.DialogWindowController);
        Sys.override(Core.SlowRequestAnimationController, Integration.GCM.SlowRequestAnimationController);
        if (Sys.isDefined(Core.ErrorManagerDesktopModel)) {
            Sys.override(Core.ErrorManagerDesktopModel, Integration.GCM.ErrorManagerDesktopModel)
        }
    }
}());
Sys.ns("Game");
Game.BonusProgramWidget = {
    constructor: function () {
        Game.BonusProgramWidget.superclass.constructor.apply(this, arguments)
    }, getMixinDependencies: function () {
        return ["orientation"]
    }, getDefaultMVCClasses: function () {
        return {
            model: Game.BonusProgramWidgetModel,
            controller: Game.BonusProgramWidgetController,
            view: Game.BonusProgramWidgetView
        }
    }, getStateChanges: function () {
        var b = this.model, c = b.readData("widgetUrl"), a = b.readData("nextAction");
        return {
            beforeLoaderClose: {
                queue: [function (d) {
                    if (b.bonusProgramWidgetEnabled() && c && a === "spin") {
                        d.stateHandler.pushState(d.states.bonusProgramWidget)
                    }
                }]
            },
            checkForAdditionalFreeRounds: {waitEvents: ["notify:bonusProgramWidget.closed"]},
            bonusProgramWidget: {
                state: {
                    name: "BonusProgramWidget", execute: function () {
                    }, waitEvents: {"notify:bonusProgramWidget.closed": false}
                }
            }
        }
    }
};
Game.BonusProgramWidget = Sys.extend(Core.Module, Game.BonusProgramWidget, "Game.BonusProgramWidget");
Sys.ns("Game");
Game.BonusProgramWidgetModel = {
    constructor: function () {
        Game.BonusProgramWidgetModel.superclass.constructor.apply(this, arguments)
    }, setupData: function (b) {
        var a = b || Resources.readData("gameServerInitResponse");
        this.storeData("bonusProgramWidgetEnabled", Boolean(a.freeRoundWidgetEnabled));
        this.storeData("bonusProgramWidgetGameId", a.freeRoundWidgetGameId);
        this.storeData("bonusProgramWidgetSections", a.freeRoundWidgetSections);
        this.storeData("widgetUrl", "../../");
        this.storeData("nextAction", a.nextaction);
        this.storeData("slowServerRequestTimeLimit", 2000)
    }, bonusProgramWidgetEnabled: function () {
        return Boolean(this.readData("bonusProgramWidgetEnabled"))
    }
};
Game.BonusProgramWidgetModel = Sys.extend(Core.Model, Game.BonusProgramWidgetModel, "Game.BonusProgramWidgetModel");
Sys.ns("Game");
Game.BonusProgramWidgetController = {
    constructor: function () {
        Game.BonusProgramWidgetController.superclass.constructor.apply(this, arguments)
    }, setupEvents: function () {
        this.on({
            "notify:stateHandler.enteringBonusProgramWidgetState": this.initBonusProgramWidget,
            "notify:scaling.gameSizeChanged": this.onGameSizeChanged,
            "notify:bonusProgramWidget.notification": this.notificationHandler,
            "notify:bonusProgramWidget.close": this.closeBonusProgramWidget,
            "notify:responseParser.gameConfigurationParsed": this.checkForAdditionalFreeRounds,
            "notify:responseParser.bonusProgramWidgetValuesParsed": this.onBonusProgramWidgetValuesParsed,
            "notify:bonusProgramWidget.reInit": this.reInit,
            "view:orientationChanged": this.notifyOrientation
        })
    }, initBonusProgramWidget: function () {
        var c = this, f = this.model.readData("widgetUrl"), b = this.model.readData("bonusProgramWidgetGameId"),
            a = Resources.readData("queryData").gameId, d = this.model.readData("slowServerRequestTimeLimit"), e;
        this.view.initViewData();
        if (b.indexOf("##") !== -1) {
            e = b.split("##")[1];
            b = b.split("##")[0];
            this.model.storeData("bonusProgramWidgetTheme", e)
        }
        this.fetchWidgetVariants(f, b, d, function (h) {
            var g;
            if (!h) {
                c.view.closeIframePage();
                return
            }
            g = c.parseVariantsResponse(h, f, b, e, a);
            c.startBonusProgramWidget(g)
        })
    }, fetchWidgetVariants: function (g, e, f, b) {
        var c = this.getWidgetLocationByWidgetID(e), d = Sys.utils.httpGet({url: g + c + "/variants.json"}),
            a = setTimeout(function () {
                b(false)
            }, f);
        d.done(function (h) {
            b(h)
        }).fail(function (h) {
            b(false)
        }).always(function () {
            clearTimeout(a)
        })
    }, getWidgetLocationByWidgetID: function (a) {
        return a === "default_w" || a === "game_branded_w" ? "free_rounds_widget" : a
    }, parseVariantsResponse: function (b, i, d, h, c) {
        var a, g;
        try {
            a = JSON.parse(b.response);
            g = h ? a[h] : a[c];
            return i + this.getWidgetLocationByWidgetID(d) + (g || a["default"])
        } catch (f) {
            return false
        }
    }, startBonusProgramWidget: function (a) {
        if (a && this.checkFileExist(a)) {
            this.view.loadIframePage(a);
            this.disableSettingsButton();
            Resources.storeData("bonusProgramWidgetActive", true)
        } else {
            this.closeBonusProgramWidget()
        }
    }, checkFileExist: function (a) {
        var b = new XMLHttpRequest();
        b.open("HEAD", a, false);
        b.send();
        return b.status === 200
    }, reInit: function (a) {
        this.model.setupData(a);
        if (this.model.bonusProgramWidgetEnabled()) {
            this.initBonusProgramWidget()
        }
    }, sendMessage: function (d, c, a) {
        var b = document.getElementById("bonusProgramWidgetIframe");
        if (b) {
            b.contentWindow.postMessage({
                moduleId: "bonusProgramWidget",
                action: d,
                data: c || null,
                dataRoute: a || null
            }, "*")
        }
    }, notificationHandler: function (c) {
        var d, a, b;
        switch (c.action) {
            case"widgetReady":
                d = Resources.readData("language");
                b = Resources.readData("queryData");
                a = d.lang || d.defaultLang;
                this.notifyOrientation(Environment.getOrientation());
                this.notifyLanguage(a);
                this.sendMessage("defaultValues", {
                    operatorId: b.operatorId,
                    gameId: b.gameId,
                    theme: this.model.readData("bonusProgramWidgetTheme")
                });
                break;
            case"getTextStrings":
                this.getTextStrings(c.data, c.dataRoute);
                break;
            case"roundStarted":
                this.roundStarted();
                break;
            case"resumeNormalGameplay":
                this.resumeNormalGameplay();
                break;
            case"playFreeRoundsNow":
                this.playFreeRoundsNow();
                break;
            case"getSectionValues":
                this.sendMessage("populateSectionValues", this.model.readData("bonusProgramWidgetSections"));
                break;
            default:
                this.sendMessage("actionNotSupported")
        }
    }, getTextStrings: function (a, b) {
        var d, c = {};
        Sys.iterate(a, function (f, e) {
            if (Sys.isArray(e) && e.length > 0) {
                d = Services.languageManager.getText(f, e)
            } else {
                d = Services.languageManager.getText(f)
            }
            if (d) {
                c[f] = d
            }
        });
        this.sendMessage("populateTextStrings", c, b)
    }, roundStarted: function () {
        this.requestWidgetAction()
    }, requestWidgetAction: function () {
        this.fireEvent("request:serverManager.sendAction", "widgetspin", "notify:responseParser.bonusProgramWidgetValuesParsed")
    }, checkForAdditionalFreeRounds: function (a) {
        if (!a.freeRoundWidgetEnabled) {
            this.fireEvent("notify:bonusProgramWidget.closed")
        }
    }, onBonusProgramWidgetValuesParsed: function (a) {
        this.sendMessage("processRoundOutcome", {indexToShow: a.indexToShow})
    }, resumeNormalGameplay: function () {
        this.closeBonusProgramWidget();
        this.enableSettingsButton()
    }, playFreeRoundsNow: function () {
        this.closeBonusProgramWidget();
        this.enableSettingsButton();
        this.fireEvent("request:freeRounds.requestGameConfiguration")
    }, closeBonusProgramWidget: function () {
        this.view.closeIframePage();
        this.fireEvent("notify:bonusProgramWidget.closed")
    }, enableSettingsButton: function () {
        this.fireEvent("request:settingsButton.enable")
    }, disableSettingsButton: function () {
        this.fireEvent("request:settingsButton.disable")
    }, notifyOrientation: function (a) {
        this.sendMessage("updateOrientation", {orientation: a})
    }, notifyLanguage: function (a) {
        this.sendMessage("updateLanguage", {lang: a})
    }, onGameSizeChanged: function () {
        if (Sys.isFunc(this.view.refresh)) {
            this.model.storeData("gameSizeChangedTriggered", true);
            this.view.refresh();
            this.notifyOrientation(Environment.getOrientation())
        }
    }
};
Game.BonusProgramWidgetController = Sys.extend(Core.Controller, Game.BonusProgramWidgetController, "Game.BonusProgramWidgetController");
Sys.ns("Game");
Game.BonusProgramWidgetView = {
    PARENT_CONTAINER_ID: "viewport",
    viewElements: {},
    bonusProgramWidgetIframeId: "bonusProgramWidgetIframe",
    constructor: function () {
        Game.BonusProgramWidgetView.superclass.constructor.apply(this, arguments)
    },
    initViewData: function () {
        var c, a, b;
        a = document.createElement("div");
        b = document.createElement("div");
        a.appendChild(b);
        c = document.getElementById(this.PARENT_CONTAINER_ID);
        a.setAttribute("id", "bonusProgramWidgetContainer");
        b.setAttribute("id", "bonusProgramWidgetOverlay");
        c.appendChild(a);
        this.viewElements = {mainContainer: a, overlay: b};
        this.refresh()
    },
    adaptToOrientation: function (a) {
        if (!this.model.readData("gameSizeChangedTriggered")) {
            this.fireEvent("view:orientationChanged", a);
            this.refresh()
        }
    },
    refresh: function () {
        if (this.viewElements.iframe) {
            this.viewElements.iframe.style.width = "100%";
            this.viewElements.iframe.style.height = this.getScreenHeight() + "px"
        }
    },
    getScreenHeight: function () {
        return Sys.utils.toInt(Environment.getGameHeight() + (Sys.isiPad || Platform.isTabletDevice ? 0 : Environment.getSpaceBelowGame()))
    },
    loadIframePage: function (a) {
        this.removeIframeInstance();
        this.createIframeInstance(a)
    },
    createIframeInstance: function (b) {
        var a = document.createElement("iframe");
        a.setAttribute("id", this.bonusProgramWidgetIframeId);
        a.setAttribute("scrolling", "no");
        a.setAttribute("allowtransparency", "true");
        a.setAttribute("src", b);
        a.setAttribute("style", "width: 100%; height: " + this.getScreenHeight() + "px;");
        this.viewElements.mainContainer.appendChild(a);
        this.viewElements.iframe = a
    },
    removeIframeInstance: function () {
        var a = document.getElementById(this.bonusProgramWidgetIframeId);
        if (a) {
            a.parentNode.removeChild(a);
            this.viewElements.iframe = null
        }
    },
    closeIframePage: function () {
        var a = this.viewElements.mainContainer;
        a.parentNode.removeChild(a)
    }
};
Game.BonusProgramWidgetView = Sys.extend(Core.View, Game.BonusProgramWidgetView, "Game.BonusProgramWidgetView");
Sys.ns("Game");
if (Sys.isDefined(window.injectWeinre)) {
    injectWeinre()
}
(function () {
    var b = new Core.StateHandler();
    Game.moduleLoader = new Core.Slots.ModuleLoader({stateHandler: b});
    var a = new Core.Heart();
    b.initStateHandler();
    if (Sys.isDefined(Integration) && Sys.isDefined(Integration.GCM)) {
        Integration.GCM.availableOptions = ["MUTE", "GAME_PREFERENCES", "PAYTABLE", "ABOUT", "TURBO"]
    }
}());